// Package metal provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.0 DO NOT EDIT.
package metal

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	X_auth_tokenScopes = "x_auth_token.Scopes"
)

// Defines values for BGPSessionInputAddressFamily.
const (
	BGPSessionInputAddressFamilyIpv4 BGPSessionInputAddressFamily = "ipv4"

	BGPSessionInputAddressFamilyIpv6 BGPSessionInputAddressFamily = "ipv6"
)

// Defines values for BgpConfigDeploymentType.
const (
	BgpConfigDeploymentTypeGlobal BgpConfigDeploymentType = "global"

	BgpConfigDeploymentTypeLocal BgpConfigDeploymentType = "local"
)

// Defines values for BgpConfigStatus.
const (
	BgpConfigStatusDisabled BgpConfigStatus = "disabled"

	BgpConfigStatusEnabled BgpConfigStatus = "enabled"

	BgpConfigStatusRequested BgpConfigStatus = "requested"
)

// Defines values for BgpSessionAddressFamily.
const (
	BgpSessionAddressFamilyIpv4 BgpSessionAddressFamily = "ipv4"

	BgpSessionAddressFamilyIpv6 BgpSessionAddressFamily = "ipv6"
)

// Defines values for BgpSessionStatus.
const (
	BgpSessionStatusDown BgpSessionStatus = "down"

	BgpSessionStatusUnknown BgpSessionStatus = "unknown"

	BgpSessionStatusUp BgpSessionStatus = "up"
)

// Defines values for CreateSelfServiceReservationRequestPeriodUnit.
const (
	CreateSelfServiceReservationRequestPeriodUnitMonthly CreateSelfServiceReservationRequestPeriodUnit = "monthly"
)

// Defines values for DeviceCreateInputBillingCycle.
const (
	DeviceCreateInputBillingCycleDaily DeviceCreateInputBillingCycle = "daily"

	DeviceCreateInputBillingCycleHourly DeviceCreateInputBillingCycle = "hourly"

	DeviceCreateInputBillingCycleMonthly DeviceCreateInputBillingCycle = "monthly"

	DeviceCreateInputBillingCycleYearly DeviceCreateInputBillingCycle = "yearly"
)

// Defines values for FacilityFeatures.
const (
	FacilityFeaturesBackendTransfer FacilityFeatures = "backend_transfer"

	FacilityFeaturesBaremetal FacilityFeatures = "baremetal"

	FacilityFeaturesGlobalIpv4 FacilityFeatures = "global_ipv4"

	FacilityFeaturesIbx FacilityFeatures = "ibx"

	FacilityFeaturesLayer2 FacilityFeatures = "layer_2"
)

// Defines values for InterconnectionMode.
const (
	InterconnectionModeStandard InterconnectionMode = "standard"

	InterconnectionModeTunnel InterconnectionMode = "tunnel"
)

// Defines values for InterconnectionCreateInputMode.
const (
	InterconnectionCreateInputModeStandard InterconnectionCreateInputMode = "standard"

	InterconnectionCreateInputModeTunnel InterconnectionCreateInputMode = "tunnel"
)

// Defines values for InterconnectionUpdateInputMode.
const (
	InterconnectionUpdateInputModeStandard InterconnectionUpdateInputMode = "standard"

	InterconnectionUpdateInputModeTunnel InterconnectionUpdateInputMode = "tunnel"
)

// Defines values for MetalGatewayState.
const (
	MetalGatewayStateActive MetalGatewayState = "active"

	MetalGatewayStateDeleting MetalGatewayState = "deleting"

	MetalGatewayStateReady MetalGatewayState = "ready"
)

// Defines values for PortVlanAssignmentState.
const (
	PortVlanAssignmentStateAssigned PortVlanAssignmentState = "assigned"

	PortVlanAssignmentStateUnassigning PortVlanAssignmentState = "unassigning"
)

// Defines values for PortVlanAssignmentBatchState.
const (
	PortVlanAssignmentBatchStateCompleted PortVlanAssignmentBatchState = "completed"

	PortVlanAssignmentBatchStateFailed PortVlanAssignmentBatchState = "failed"

	PortVlanAssignmentBatchStateInProgress PortVlanAssignmentBatchState = "in_progress"

	PortVlanAssignmentBatchStateQueued PortVlanAssignmentBatchState = "queued"
)

// Defines values for PortVlanAssignmentBatchCreateInputVlanAssignmentsState.
const (
	PortVlanAssignmentBatchCreateInputVlanAssignmentsStateAssigned PortVlanAssignmentBatchCreateInputVlanAssignmentsState = "assigned"

	PortVlanAssignmentBatchCreateInputVlanAssignmentsStateUnassigned PortVlanAssignmentBatchCreateInputVlanAssignmentsState = "unassigned"
)

// Defines values for PortVlanAssignmentBatchVlanAssignmentsState.
const (
	PortVlanAssignmentBatchVlanAssignmentsStateAssigned PortVlanAssignmentBatchVlanAssignmentsState = "assigned"

	PortVlanAssignmentBatchVlanAssignmentsStateUnassigned PortVlanAssignmentBatchVlanAssignmentsState = "unassigned"
)

// Defines values for SupportRequestInputPriority.
const (
	SupportRequestInputPriorityHigh SupportRequestInputPriority = "high"

	SupportRequestInputPriorityLow SupportRequestInputPriority = "low"

	SupportRequestInputPriorityMedium SupportRequestInputPriority = "medium"

	SupportRequestInputPriorityUrgent SupportRequestInputPriority = "urgent"
)

// Address defines model for Address.
type Address struct {
	Address     string       `json:"address"`
	Address2    *string      `json:"address2,omitempty"`
	City        *string      `json:"city,omitempty"`
	Coordinates *Coordinates `json:"coordinates,omitempty"`
	Country     string       `json:"country"`
	State       *string      `json:"state,omitempty"`
	ZipCode     string       `json:"zip_code"`
}

// AuthToken defines model for AuthToken.
type AuthToken struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Available only for API keys
	Description *string `json:"description,omitempty"`
	Id          *string `json:"id,omitempty"`
	Project     *struct {
		// Embedded struct due to allOf(#/components/schemas/Project)
		Project `yaml:",inline"`
		// Embedded fields due to inline allOf schema
	} `json:"project,omitempty"`
	ReadOnly  *bool      `json:"read_only,omitempty"`
	Token     *string    `json:"token,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	User      *struct {
		// Embedded struct due to allOf(#/components/schemas/User)
		User `yaml:",inline"`
		// Embedded fields due to inline allOf schema
	} `json:"user,omitempty"`
}

// AuthTokenInput defines model for AuthTokenInput.
type AuthTokenInput struct {
	Description *string `json:"description,omitempty"`
	ReadOnly    *bool   `json:"read_only,omitempty"`
}

// AuthTokenList defines model for AuthTokenList.
type AuthTokenList struct {
	ApiKeys *[]AuthToken `json:"api_keys,omitempty"`
}

// BGPSessionInput defines model for BGPSessionInput.
type BGPSessionInput struct {
	// Address family for BGP session.
	AddressFamily *BGPSessionInputAddressFamily `json:"address_family,omitempty"`

	// Set the default route policy.
	DefaultRoute *bool `json:"default_route,omitempty"`
}

// Address family for BGP session.
type BGPSessionInputAddressFamily string

// Batch defines model for Batch.
type Batch struct {
	CreatedAt     *time.Time `json:"created_at,omitempty"`
	Devices       *[]Href    `json:"devices,omitempty"`
	ErrorMessages *[]string  `json:"error_messages,omitempty"`
	Id            *string    `json:"id,omitempty"`
	Project       *Href      `json:"project,omitempty"`
	Quantity      *int       `json:"quantity,omitempty"`
	State         *string    `json:"state,omitempty"`
	UpdatedAt     *time.Time `json:"updated_at,omitempty"`
}

// BatchesList defines model for BatchesList.
type BatchesList struct {
	Batches *[]Batch `json:"batches,omitempty"`
}

// BgpConfig defines model for BgpConfig.
type BgpConfig struct {
	// Autonomous System Number. ASN is required with Global BGP. With Local BGP the private ASN, 65000, is assigned.
	Asn       *int32     `json:"asn,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// In a Local BGP deployment, a customer uses an internal ASN to control routes within a single Equinix Metal datacenter. This means that the routes are never advertised to the global Internet. Global BGP, on the other hand, requires a customer to have a registered ASN and IP space.
	DeploymentType *BgpConfigDeploymentType `json:"deployment_type,omitempty"`
	Href           *string                  `json:"href,omitempty"`
	Id             *string                  `json:"id,omitempty"`

	// The maximum number of route filters allowed per server
	MaxPrefix *int `json:"max_prefix,omitempty"`

	// (Optional) Password for BGP session in plaintext (not a checksum)
	Md5     *string `json:"md5"`
	Project *Href   `json:"project,omitempty"`

	// The IP block ranges associated to the ASN (Populated in Global BGP only)
	Ranges      *[]GlobalBgpRange `json:"ranges,omitempty"`
	RequestedAt *time.Time        `json:"requested_at,omitempty"`

	// Specifies AS-MACRO (aka AS-SET) to use when building client route filters
	RouteObject *string `json:"route_object,omitempty"`

	// The direct connections between neighboring routers that want to exchange routing information.
	Sessions *[]BgpSession `json:"sessions,omitempty"`

	// Status of the BGP Config. Status "requested" is valid only with the "global" deployment_type.
	Status *BgpConfigStatus `json:"status,omitempty"`
}

// In a Local BGP deployment, a customer uses an internal ASN to control routes within a single Equinix Metal datacenter. This means that the routes are never advertised to the global Internet. Global BGP, on the other hand, requires a customer to have a registered ASN and IP space.
type BgpConfigDeploymentType string

// Status of the BGP Config. Status "requested" is valid only with the "global" deployment_type.
type BgpConfigStatus string

// BgpConfigRequestInput defines model for BgpConfigRequestInput.
type BgpConfigRequestInput struct {
	Asn            int     `json:"asn"`
	DeploymentType string  `json:"deployment_type"`
	Md5            *string `json:"md5,omitempty"`
	UseCase        *string `json:"use_case,omitempty"`
}

// BgpNeighborData defines model for BgpNeighborData.
type BgpNeighborData struct {
	// Address Family for IP Address. Accepted values are 4 or 6
	AddressFamily *int32 `json:"address_family,omitempty"`

	// The customer's ASN. In a local BGP deployment, this will be an internal ASN used to route within the data center. For a global BGP deployment, this will be the your own ASN, configured when you set up BGP for your project.
	CustomerAs *int32 `json:"customer_as,omitempty"`

	// The device's IP address. For an IPv4 BGP session, this is typically the private bond0 address for the device.
	CustomerIp *string `json:"customer_ip,omitempty"`

	// True if an MD5 password is configured for the project.
	Md5Enabled *bool `json:"md5_enabled,omitempty"`

	// The MD5 password configured for the project, if set.
	Md5Password *string `json:"md5_password,omitempty"`

	// True when the BGP session should be configured as multihop.
	Multihop *bool `json:"multihop,omitempty"`

	// The Peer ASN to use when configuring BGP on your device.
	PeerAs *int32 `json:"peer_as,omitempty"`

	// A list of one or more IP addresses to use for the Peer IP section of your BGP configuration. For non-multihop sessions, this will typically be a single gateway address for the device. For multihop sessions, it will be a list of IPs.
	PeerIps *[]string `json:"peer_ips,omitempty"`

	// A list of project subnets
	RoutesIn *[]BgpNeighborDataRoutesIn `json:"routes_in,omitempty"`

	// A list of outgoing routes. Only populated if the BGP session has default route enabled.
	RoutesOut *[]BgpNeighborDataRoutesOut `json:"routes_out,omitempty"`
}

// BgpNeighborDataRoutesIn defines model for BgpNeighborData_routes_in.
type BgpNeighborDataRoutesIn struct {
	Exact *bool `json:"exact,omitempty"`

	// A project network
	Route *string `json:"route,omitempty"`
}

// BgpNeighborDataRoutesOut defines model for BgpNeighborData_routes_out.
type BgpNeighborDataRoutesOut struct {
	Exact *bool   `json:"exact,omitempty"`
	Route *string `json:"route,omitempty"`
}

// BgpSession defines model for BgpSession.
type BgpSession struct {
	AddressFamily BgpSessionAddressFamily `json:"address_family"`
	CreatedAt     *time.Time              `json:"created_at,omitempty"`
	DefaultRoute  *bool                   `json:"default_route,omitempty"`
	Device        *Href                   `json:"device,omitempty"`
	Href          *string                 `json:"href,omitempty"`
	Id            *string                 `json:"id,omitempty"`
	LearnedRoutes *[]string               `json:"learned_routes,omitempty"`

	//  The status of the BGP Session. Multiple status values may be reported when the device is connected to multiple switches, one value per switch. Each status will start with "unknown" and progress to "up" or "down" depending on the connected device. Subsequent "unknown" values indicate a problem acquiring status from the switch.
	Status    *BgpSessionStatus `json:"status,omitempty"`
	UpdatedAt *time.Time        `json:"updated_at,omitempty"`
}

// BgpSessionAddressFamily defines model for BgpSession.AddressFamily.
type BgpSessionAddressFamily string

//  The status of the BGP Session. Multiple status values may be reported when the device is connected to multiple switches, one value per switch. Each status will start with "unknown" and progress to "up" or "down" depending on the connected device. Subsequent "unknown" values indicate a problem acquiring status from the switch.
type BgpSessionStatus string

// BgpSessionList defines model for BgpSessionList.
type BgpSessionList struct {
	BgpSessions *[]BgpSession `json:"bgp_sessions,omitempty"`
}

// BgpSessionNeighbors defines model for BgpSessionNeighbors.
type BgpSessionNeighbors struct {
	// A list of BGP session neighbor data
	BgpNeighbors *[]BgpNeighborData `json:"bgp_neighbors,omitempty"`
}

// CapacityCheckPerFacilityInfo defines model for CapacityCheckPerFacilityInfo.
type CapacityCheckPerFacilityInfo struct {
	Available *bool   `json:"available,omitempty"`
	Facility  *string `json:"facility,omitempty"`
	Plan      *string `json:"plan,omitempty"`
	Quantity  *string `json:"quantity,omitempty"`
}

// CapacityCheckPerFacilityList defines model for CapacityCheckPerFacilityList.
type CapacityCheckPerFacilityList struct {
	Servers *[]CapacityCheckPerFacilityInfo `json:"servers,omitempty"`
}

// CapacityCheckPerMetroInfo defines model for CapacityCheckPerMetroInfo.
type CapacityCheckPerMetroInfo struct {
	// Returns true if there is enough capacity in the metro to fulfill the quantity set. Returns false if there is not enough.
	Available *bool `json:"available,omitempty"`

	// The metro ID or code sent to check capacity.
	Metro *string `json:"metro,omitempty"`

	// The plan ID or slug sent to check capacity.
	Plan *string `json:"plan,omitempty"`

	// The number of servers sent to check capacity.
	Quantity *string `json:"quantity,omitempty"`
}

// CapacityCheckPerMetroList defines model for CapacityCheckPerMetroList.
type CapacityCheckPerMetroList struct {
	Servers *[]CapacityCheckPerMetroInfo `json:"servers,omitempty"`
}

// CapacityInput defines model for CapacityInput.
type CapacityInput struct {
	Servers *[]ServerInfo `json:"servers,omitempty"`
}

// CapacityLevelPerBaremetal defines model for CapacityLevelPerBaremetal.
type CapacityLevelPerBaremetal struct {
	Level *string `json:"level,omitempty"`
}

// CapacityList defines model for CapacityList.
type CapacityList struct {
	Capacity *CapacityReport `json:"capacity,omitempty"`
}

// CapacityPerFacility defines model for CapacityPerFacility.
type CapacityPerFacility struct {
	Baremetal0   *CapacityLevelPerBaremetal `json:"baremetal_0,omitempty"`
	Baremetal1   *CapacityLevelPerBaremetal `json:"baremetal_1,omitempty"`
	Baremetal2   *CapacityLevelPerBaremetal `json:"baremetal_2,omitempty"`
	Baremetal2a  *CapacityLevelPerBaremetal `json:"baremetal_2a,omitempty"`
	Baremetal2a2 *CapacityLevelPerBaremetal `json:"baremetal_2a2,omitempty"`
	Baremetal3   *CapacityLevelPerBaremetal `json:"baremetal_3,omitempty"`
	BaremetalS   *CapacityLevelPerBaremetal `json:"baremetal_s,omitempty"`
	C2MediumX86  *CapacityLevelPerBaremetal `json:"c2.medium.x86,omitempty"`
	M2XlargeX86  *CapacityLevelPerBaremetal `json:"m2.xlarge.x86,omitempty"`
}

// CapacityPerMetroInput defines model for CapacityPerMetroInput.
type CapacityPerMetroInput struct {
	Servers *[]MetroServerInfo `json:"servers,omitempty"`
}

// CapacityPerNewFacility defines model for CapacityPerNewFacility.
type CapacityPerNewFacility struct {
	Baremetal1e *CapacityLevelPerBaremetal `json:"baremetal_1e,omitempty"`
}

// CapacityReport defines model for CapacityReport.
type CapacityReport struct {
	Ams1 *CapacityPerFacility    `json:"ams1,omitempty"`
	Atl1 *CapacityPerNewFacility `json:"atl1,omitempty"`
	Dfw1 *CapacityPerNewFacility `json:"dfw1,omitempty"`
	Ewr1 *CapacityPerFacility    `json:"ewr1,omitempty"`
	Fra1 *CapacityPerNewFacility `json:"fra1,omitempty"`
	Iad1 *CapacityPerNewFacility `json:"iad1,omitempty"`
	Lax1 *CapacityPerNewFacility `json:"lax1,omitempty"`
	Nrt1 *CapacityPerFacility    `json:"nrt1,omitempty"`
	Ord1 *CapacityPerNewFacility `json:"ord1,omitempty"`
	Sea1 *CapacityPerNewFacility `json:"sea1,omitempty"`
	Sin1 *CapacityPerNewFacility `json:"sin1,omitempty"`
	Sjc1 *CapacityPerFacility    `json:"sjc1,omitempty"`
	Syd1 *CapacityPerNewFacility `json:"syd1,omitempty"`
	Yyz1 *CapacityPerNewFacility `json:"yyz1,omitempty"`
}

// Coordinates defines model for Coordinates.
type Coordinates struct {
	Latitude  *string `json:"latitude,omitempty"`
	Longitude *string `json:"longitude,omitempty"`
}

// CreateEmailInput defines model for CreateEmailInput.
type CreateEmailInput struct {
	Address string `json:"address"`
}

// CreateSelfServiceReservationRequest defines model for CreateSelfServiceReservationRequest.
type CreateSelfServiceReservationRequest struct {
	Item      *[]SelfServiceReservationItemRequest       `json:"item,omitempty"`
	Notes     *string                                    `json:"notes,omitempty"`
	Period    *CreateSelfServiceReservationRequestPeriod `json:"period,omitempty"`
	StartDate *time.Time                                 `json:"start_date,omitempty"`
}

// CreateSelfServiceReservationRequestPeriod defines model for CreateSelfServiceReservationRequest_period.
type CreateSelfServiceReservationRequestPeriod struct {
	Count *int                                           `json:"count,omitempty"`
	Unit  *CreateSelfServiceReservationRequestPeriodUnit `json:"unit,omitempty"`
}

// CreateSelfServiceReservationRequestPeriodUnit defines model for CreateSelfServiceReservationRequestPeriod.Unit.
type CreateSelfServiceReservationRequestPeriodUnit string

// Device defines model for Device.
type Device struct {
	AlwaysPxe           *bool                   `json:"always_pxe,omitempty"`
	BillingCycle        *string                 `json:"billing_cycle,omitempty"`
	BondingMode         *int                    `json:"bonding_mode,omitempty"`
	CreatedAt           *time.Time              `json:"created_at,omitempty"`
	Customdata          *map[string]interface{} `json:"customdata,omitempty"`
	Description         *string                 `json:"description,omitempty"`
	Facility            *Facility               `json:"facility,omitempty"`
	HardwareReservation *Href                   `json:"hardware_reservation,omitempty"`
	Hostname            *string                 `json:"hostname,omitempty"`
	Href                *string                 `json:"href,omitempty"`
	Id                  *string                 `json:"id,omitempty"`
	ImageUrl            *string                 `json:"image_url,omitempty"`
	IpAddresses         *[]IPAssignment         `json:"ip_addresses,omitempty"`
	IpxeScriptUrl       *string                 `json:"ipxe_script_url,omitempty"`
	Iqn                 *string                 `json:"iqn,omitempty"`
	Locked              *bool                   `json:"locked,omitempty"`
	Metro               *struct {
		// Embedded struct due to allOf(#/components/schemas/Metro)
		Metro `yaml:",inline"`
		// Embedded fields due to inline allOf schema
	} `json:"metro,omitempty"`
	NetworkPorts *struct {
		// Embedded struct due to allOf(#/components/schemas/Port)
		Port `yaml:",inline"`
		// Embedded fields due to inline allOf schema
	} `json:"network_ports,omitempty"`
	OperatingSystem *OperatingSystem `json:"operating_system,omitempty"`
	Plan            *Plan            `json:"plan,omitempty"`
	Project         *struct {
		// Embedded struct due to allOf(#/components/schemas/Href)
		Href `yaml:",inline"`
		// Embedded fields due to inline allOf schema
	} `json:"project,omitempty"`
	ProjectLite *struct {
		// Embedded struct due to allOf(#/components/schemas/Href)
		Href `yaml:",inline"`
		// Embedded fields due to inline allOf schema
	} `json:"project_lite,omitempty"`
	ProvisioningEvents *[]Event `json:"provisioning_events,omitempty"`

	// Only visible while device provisioning
	ProvisioningPercentage *float32 `json:"provisioning_percentage,omitempty"`

	// Root password is automatically generated when server is provisioned and it is removed after 24 hours
	RootPassword *string `json:"root_password,omitempty"`
	ShortId      *string `json:"short_id,omitempty"`

	// Whether or not the device is a spot instance.
	SpotInstance *bool `json:"spot_instance,omitempty"`

	// The maximum price per hour you are willing to pay to keep this spot instance.  If you are outbid, the termination will be set allowing two minutes before shutdown.
	SpotPriceMax *float32 `json:"spot_price_max,omitempty"`
	SshKeys      *[]Href  `json:"ssh_keys,omitempty"`
	State        *string  `json:"state,omitempty"`

	// Switch short id. This can be used to determine if two devices are connected to the same switch, for example.
	SwitchUuid *string   `json:"switch_uuid,omitempty"`
	Tags       *[]string `json:"tags,omitempty"`

	// When the device will be terminated. This is commonly set in advance for ephemeral spot market instances but this field may also be set with on-demand and reservation instances to automatically delete the resource at a given time. The termination time can also be used to release a hardware reservation instance at a given time, keeping the reservation open for other uses.  On a spot market device, the termination time will be set automatically when outbid.
	TerminationTime *time.Time `json:"termination_time,omitempty"`
	UpdatedAt       *time.Time `json:"updated_at,omitempty"`
	User            *string    `json:"user,omitempty"`
	Userdata        *string    `json:"userdata,omitempty"`
	Volumes         *[]Href    `json:"volumes,omitempty"`
}

// DeviceCreateInput defines model for DeviceCreateInput.
type DeviceCreateInput struct {
	// When true, devices with a `custom_ipxe` OS will always boot to iPXE. The default setting of false ensures that iPXE will be used on only the first boot.
	AlwaysPxe *bool `json:"always_pxe,omitempty"`

	// The billing cycle of the device.
	BillingCycle *DeviceCreateInputBillingCycle `json:"billing_cycle,omitempty"`

	// Customdata is an arbitrary JSON value that can be accessed via the metadata service.
	Customdata *map[string]interface{} `json:"customdata,omitempty"`

	// Any description of the device or how it will be used. This may be used to inform other API consumers with project access.
	Description *string `json:"description,omitempty"`

	// The datacenter where the device should be created.
	//
	// The API will accept either a single facility `{ "facility": "f1" }`, or it can be instructed to create the device in the best available datacenter `{ "facility": "any" }`.
	//
	// Additionally it is possible to set a prioritized location selection. For example `{ "facility": ["f3", "f2", "any"] }` can be used to prioritize `f3` and then `f2` before accepting `any` facility. If none of the facilities provided have availability for the requested device the request will fail.
	Facility string `json:"facility"`

	// The features attribute allows you to optionally specify what features your server should have.
	//
	// In the API shorthand syntax, all features listed are `required`:
	//
	// ```
	// { "features": ["tpm"] }
	// ```
	//
	// Alternatively, if you do not require a certain feature, but would prefer to be assigned a server with that feature if there are any available, you may specify that feature with a `preferred` value. The request will not fail if we have no servers with that feature in our inventory. The API offers an alternative syntax for mixing preferred and required features:
	//
	// ```
	// { "features": { "tpm": "required", "raid": "preferred" } }
	// ```
	//
	// The request will only fail if there are no available servers matching the required `tpm` criteria.
	Features *[]string `json:"features,omitempty"`

	// The Hardware Reservation UUID to provision. Alternatively, `next-available` can be specified to select from any of the available hardware reservations. An error will be returned if the requested reservation option is not available.
	//
	//       See [Reserved Hardware](https://metal.equinix.com/developers/docs/deploy/reserved/) for more details.
	HardwareReservationId *string `json:"hardware_reservation_id,omitempty"`

	// The hostname to use within the operating system. The same hostname may be used on multiple devices within a project.
	Hostname *string `json:"hostname,omitempty"`

	// The `ip_addresses attribute will allow you to specify the addresses you want created with your device.
	//
	// The default value configures public IPv4, public IPv6, and private IPv4.
	//
	// Private IPv4 address is required. When specifying `ip_addresses`, one of the array items must enable private IPv4.
	//
	// Some operating systems require public IPv4 address. In those cases you will receive an error message if public IPv4 is not enabled.
	//
	// For example, to only configure your server with a private IPv4 address, you can send `{ "ip_addresses": [{ "address_family": 4, "public": false }] }`.
	//
	// It is possible to request a subnet size larger than a `/30` by assigning addresses using the UUID(s) of ip_reservations in your project.
	//
	// For example, `{ "ip_addresses": [..., {"address_family": 4, "public": true, "ip_reservations": ["uuid1", "uuid2"]}] }`
	//
	// To access a server without public IPs, you can use our Out-of-Band console access (SOS) or proxy through another server in the project with public IPs enabled.
	IpAddresses *[]DeviceCreateInputIpAddresses `json:"ip_addresses,omitempty"`

	// When set, the device will chainload an iPXE Script at boot fetched from the supplied URL.
	//
	//       See [Custom iPXE](https://metal.equinix.com/developers/docs/operating-systems/custom-ipxe/) for more details.
	IpxeScriptUrl *string `json:"ipxe_script_url,omitempty"`

	// Whether the device should be locked, preventing accidental deletion.
	Locked *bool `json:"locked,omitempty"`

	// Metro code or ID of where the instance should be provisioned in.
	Metro *string `json:"metro,omitempty"`

	// Overrides default behaviour of attaching all of the organization members ssh keys and project ssh keys to device if no specific keys specified
	NoSshKeys *bool `json:"no_ssh_keys"`

	// The slug of the operating system to provision. Check the Equinix Metal operating system documentation for rules that may be imposed per operating system, including restrictions on IP address options and device plans.
	OperatingSystem string `json:"operating_system"`

	// The slug of the device plan to provision.
	Plan string `json:"plan"`

	// Deprecated. Use ip_addresses. Subnet range for addresses allocated to this device.
	PrivateIpv4SubnetSize *int32 `json:"private_ipv4_subnet_size,omitempty"`

	// A list of UUIDs identifying the device parent project
	// that should be authorized to access this device (typically
	// via /root/.ssh/authorized_keys). These keys will also appear in the device metadata.
	//
	// If no SSH keys are specified (`user_ssh_keys`, `project_ssh_keys`, and `ssh_keys` are all empty lists or omitted),
	// all parent project keys, parent project members keys and organization members keys will be included. This behaviour can
	// be changed with 'no_ssh_keys' option to omit any SSH key being added.
	//
	ProjectSshKeys *[]string `json:"project_ssh_keys"`

	// Deprecated. Use ip_addresses. Subnet range for addresses allocated to this device. Your project must have addresses available for a non-default request.
	PublicIpv4SubnetSize *int32   `json:"public_ipv4_subnet_size,omitempty"`
	SpotInstance         *bool    `json:"spot_instance,omitempty"`
	SpotPriceMax         *float64 `json:"spot_price_max,omitempty"`

	// A list of new or existing project ssh_keys
	// that should be authorized to access this device (typically
	// via /root/.ssh/authorized_keys). These keys will also
	// appear in the device metadata.
	//
	// These keys are added in addition to any keys defined by
	//   `project_ssh_keys` and `user_ssh_keys`.
	SshKeys         *[]SSHKeyInput `json:"ssh_keys"`
	Tags            *[]string      `json:"tags,omitempty"`
	TerminationTime *time.Time     `json:"termination_time,omitempty"`

	// A list of UUIDs identifying the users
	// that should be authorized to access this device (typically
	// via /root/.ssh/authorized_keys).  These keys will also
	// appear in the device metadata.
	//
	// The users must be members of the project or organization.
	//
	// If no SSH keys are specified (`user_ssh_keys`, `project_ssh_keys`, and `ssh_keys` are all empty lists or omitted),
	// all parent project keys, parent project members keys and organization members keys will be included. This behaviour can
	// be changed with 'no_ssh_keys' option to omit any SSH key being added.
	UserSshKeys *[]string `json:"user_ssh_keys"`

	// The userdata presented in the metadata service for this device.  Userdata is fetched and interpretted by the operating system installed on the device. Acceptable formats are determined by the operating system, with the exception of a special iPXE enabling syntax which is handled before the operating system starts.
	//
	//       See [Server User Data](https://metal.equinix.com/developers/docs/servers/user-data/) and [Provisioning with Custom iPXE](https://metal.equinix.com/developers/docs/operating-systems/custom-ipxe/#provisioning-with-custom-ipxe) for more details.
	Userdata *string `json:"userdata,omitempty"`
}

// The billing cycle of the device.
type DeviceCreateInputBillingCycle string

// DeviceCreateInputIpAddresses defines model for DeviceCreateInput_ip_addresses.
type DeviceCreateInputIpAddresses struct {
	// Address Family for IP Address
	AddressFamily *int32 `json:"address_family,omitempty"`

	// Cidr Size for the IP Block created. Valid values depends on the operating system being provisioned. (28..32 for IPv4 addresses, 124..127 for IPv6 addresses)
	Cidr *int32 `json:"cidr,omitempty"`

	// UUIDs of any IP reservations to use when assigning IPs
	IpReservations *[]string `json:"ip_reservations,omitempty"`

	// Address Type for IP Address
	Public *bool `json:"public,omitempty"`
}

// DeviceList defines model for DeviceList.
type DeviceList struct {
	Devices *[]Device `json:"devices,omitempty"`
	Meta    *Meta     `json:"meta,omitempty"`
}

// DeviceUpdateInput defines model for DeviceUpdateInput.
type DeviceUpdateInput struct {
	AlwaysPxe     *bool                   `json:"always_pxe,omitempty"`
	BillingCycle  *string                 `json:"billing_cycle,omitempty"`
	Customdata    *map[string]interface{} `json:"customdata,omitempty"`
	Description   *string                 `json:"description,omitempty"`
	Hostname      *string                 `json:"hostname,omitempty"`
	IpxeScriptUrl *string                 `json:"ipxe_script_url,omitempty"`
	Locked        *bool                   `json:"locked,omitempty"`

	// If true, this instance can not be converted to a different network type.
	NetworkFrozen *bool     `json:"network_frozen,omitempty"`
	SpotInstance  *bool     `json:"spot_instance,omitempty"`
	Tags          *[]string `json:"tags,omitempty"`
	Userdata      *string   `json:"userdata,omitempty"`
}

// DeviceUsage defines model for DeviceUsage.
type DeviceUsage struct {
	Quantity *string `json:"quantity,omitempty"`
	Total    *string `json:"total,omitempty"`
	Unit     *string `json:"unit,omitempty"`
}

// DeviceUsageList defines model for DeviceUsageList.
type DeviceUsageList struct {
	Usages *[]DeviceUsage `json:"usages,omitempty"`
}

// Email defines model for Email.
type Email struct {
	Address  *string `json:"address,omitempty"`
	Default  *bool   `json:"default,omitempty"`
	Href     *string `json:"href,omitempty"`
	Id       *string `json:"id,omitempty"`
	Verified *bool   `json:"verified,omitempty"`
}

// EmailInput defines model for EmailInput.
type EmailInput struct {
	Address string `json:"address"`
	Default *bool  `json:"default,omitempty"`
}

// Entitlement defines model for Entitlement.
type Entitlement struct {
	Description   *string                 `json:"description,omitempty"`
	FeatureAccess *map[string]interface{} `json:"feature_access,omitempty"`
	Href          *string                 `json:"href,omitempty"`
	Id            string                  `json:"id"`
	InstanceQuota *map[string]interface{} `json:"instance_quota,omitempty"`
	IpQuota       *map[string]interface{} `json:"ip_quota,omitempty"`
	Name          *string                 `json:"name,omitempty"`
	ProjectQuota  *int                    `json:"project_quota,omitempty"`
	Slug          string                  `json:"slug"`
	VolumeLimits  *map[string]interface{} `json:"volume_limits,omitempty"`
	VolumeQuota   *map[string]interface{} `json:"volume_quota,omitempty"`
	Weight        int                     `json:"weight"`
}

// Error responses are included with 4xx and 5xx HTTP responses from the API service. Either "error" or "errors" will be set.
type Error struct {
	// A description of the error that caused the request to fail.
	Error *string `json:"error,omitempty"`

	// A list of errors that contributed to the request failing.
	Errors *[]string `json:"errors,omitempty"`
}

// Event defines model for Event.
type Event struct {
	Body          *string    `json:"body,omitempty"`
	CreatedAt     *time.Time `json:"created_at,omitempty"`
	Href          *string    `json:"href,omitempty"`
	Id            *string    `json:"id,omitempty"`
	Interpolated  *string    `json:"interpolated,omitempty"`
	Relationships *[]Href    `json:"relationships,omitempty"`
	State         *string    `json:"state,omitempty"`
	Type          *string    `json:"type,omitempty"`
}

// EventList defines model for EventList.
type EventList struct {
	Events *[]Event `json:"events,omitempty"`
	Meta   *Meta    `json:"meta,omitempty"`
}

// Facility defines model for Facility.
type Facility struct {
	Address  *Address            `json:"address,omitempty"`
	Code     *string             `json:"code,omitempty"`
	Features *[]FacilityFeatures `json:"features,omitempty"`
	Id       *string             `json:"id,omitempty"`

	// IP ranges registered in facility. Can be used for GeoIP location
	IpRanges *[]string `json:"ip_ranges,omitempty"`
	Metro    *struct {
		// Embedded struct due to allOf(#/components/schemas/Metro)
		Metro `yaml:",inline"`
		// Embedded fields due to inline allOf schema
	} `json:"metro,omitempty"`
	Name *string `json:"name,omitempty"`
}

// FacilityFeatures defines model for Facility.Features.
type FacilityFeatures string

// FacilityList defines model for FacilityList.
type FacilityList struct {
	Facilities *[]Facility `json:"facilities,omitempty"`
}

// GlobalBgpRange defines model for GlobalBgpRange.
type GlobalBgpRange struct {
	AddressFamily *int    `json:"address_family,omitempty"`
	Href          *string `json:"href,omitempty"`
	Id            *string `json:"id,omitempty"`
	Project       *Href   `json:"project,omitempty"`
	Range         *string `json:"range,omitempty"`
}

// GlobalBgpRangeList defines model for GlobalBgpRangeList.
type GlobalBgpRangeList struct {
	GlobalBgpRanges *[]GlobalBgpRange `json:"global_bgp_ranges,omitempty"`
}

// HardwareReservation defines model for HardwareReservation.
type HardwareReservation struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Amount that will be charged for every billing_cycle.
	CustomRate *float64  `json:"custom_rate,omitempty"`
	Device     *Device   `json:"device,omitempty"`
	Facility   *Facility `json:"facility,omitempty"`
	Href       *string   `json:"href,omitempty"`
	Id         *string   `json:"id,omitempty"`

	// Whether this Device requires assistance from Metal Equinix.
	NeedOfService *bool    `json:"need_of_service,omitempty"`
	Plan          *Plan    `json:"plan,omitempty"`
	Project       *Project `json:"project,omitempty"`

	// Whether the reserved server is provisionable or not. Spare devices can't be provisioned unless they are activated first.
	Provisionable *bool `json:"provisionable,omitempty"`

	// Short version of the ID.
	ShortId *string `json:"short_id,omitempty"`

	// Whether the Hardware Reservation is a spare. Spare Hardware Reservations are used when a Hardware Reservations requires service from Metal Equinix
	Spare *bool `json:"spare,omitempty"`

	// Switch short id. This can be used to determine if two devices are connected to the same switch, for example.
	SwitchUuid *string `json:"switch_uuid,omitempty"`
}

// HardwareReservationList defines model for HardwareReservationList.
type HardwareReservationList struct {
	HardwareReservations *[]HardwareReservation `json:"hardware_reservations,omitempty"`
	Meta                 *Meta                  `json:"meta,omitempty"`
}

// Href defines model for Href.
type Href struct {
	Href string `json:"href"`
}

// IPAssignment defines model for IPAssignment.
type IPAssignment struct {
	Address       *string    `json:"address,omitempty"`
	AddressFamily *int       `json:"address_family,omitempty"`
	AssignedTo    *Href      `json:"assigned_to,omitempty"`
	Cidr          *int       `json:"cidr,omitempty"`
	CreatedAt     *time.Time `json:"created_at,omitempty"`
	Enabled       *bool      `json:"enabled,omitempty"`
	Gateway       *string    `json:"gateway,omitempty"`
	GlobalIp      *bool      `json:"global_ip,omitempty"`
	Href          *string    `json:"href,omitempty"`
	Id            *string    `json:"id,omitempty"`
	Manageable    *bool      `json:"manageable,omitempty"`
	Management    *bool      `json:"management,omitempty"`
	Metro         *struct {
		// Embedded struct due to allOf(#/components/schemas/Metro)
		Metro `yaml:",inline"`
		// Embedded fields due to inline allOf schema
	} `json:"metro,omitempty"`
	Netmask     *string      `json:"netmask,omitempty"`
	Network     *string      `json:"network,omitempty"`
	ParentBlock *ParentBlock `json:"parent_block,omitempty"`
	Public      *bool        `json:"public,omitempty"`
}

// IPAssignmentInput defines model for IPAssignmentInput.
type IPAssignmentInput struct {
	Address    string                  `json:"address"`
	Customdata *map[string]interface{} `json:"customdata,omitempty"`
	Manageable *bool                   `json:"manageable,omitempty"`
}

// IPAssignmentList defines model for IPAssignmentList.
type IPAssignmentList struct {
	IpAddresses *[]IPAssignment `json:"ip_addresses,omitempty"`
}

// IPAvailabilitiesList defines model for IPAvailabilitiesList.
type IPAvailabilitiesList struct {
	Available *[]string `json:"available,omitempty"`
}

// IPReservation defines model for IPReservation.
type IPReservation struct {
	Addon         *bool           `json:"addon,omitempty"`
	AddressFamily *int            `json:"address_family,omitempty"`
	Assignments   *[]IPAssignment `json:"assignments,omitempty"`
	Bill          *bool           `json:"bill,omitempty"`
	Cidr          *int            `json:"cidr,omitempty"`
	CreatedAt     *time.Time      `json:"created_at,omitempty"`
	Enabled       *bool           `json:"enabled,omitempty"`
	Facility      *struct {
		// Embedded struct due to allOf(#/components/schemas/Facility)
		Facility `yaml:",inline"`
		// Embedded fields due to inline allOf schema
	} `json:"facility,omitempty"`
	GlobalIp   *bool   `json:"global_ip,omitempty"`
	Href       *string `json:"href,omitempty"`
	Id         *string `json:"id,omitempty"`
	Manageable *bool   `json:"manageable,omitempty"`
	Management *bool   `json:"management,omitempty"`
	Metro      *struct {
		// Embedded struct due to allOf(#/components/schemas/Metro)
		Metro `yaml:",inline"`
		// Embedded fields due to inline allOf schema
	} `json:"metro,omitempty"`
	Netmask *string   `json:"netmask,omitempty"`
	Network *string   `json:"network,omitempty"`
	Public  *bool     `json:"public,omitempty"`
	State   *string   `json:"state,omitempty"`
	Tags    *[]string `json:"tags,omitempty"`
}

// IPReservationList defines model for IPReservationList.
type IPReservationList struct {
	IpAddresses *[]IPReservation `json:"ip_addresses,omitempty"`
}

// IPReservationRequestInput defines model for IPReservationRequestInput.
type IPReservationRequestInput struct {
	Comments               *string                 `json:"comments,omitempty"`
	Customdata             *map[string]interface{} `json:"customdata,omitempty"`
	Details                *string                 `json:"details,omitempty"`
	Facility               *string                 `json:"facility,omitempty"`
	FailOnApprovalRequired *bool                   `json:"fail_on_approval_required,omitempty"`

	// The code of the metro you are requesting the IP reservation in.
	Metro    *string   `json:"metro,omitempty"`
	Quantity int       `json:"quantity"`
	Tags     *[]string `json:"tags,omitempty"`
	Type     string    `json:"type"`
}

// InstancesBatchCreateInput defines model for InstancesBatchCreateInput.
type InstancesBatchCreateInput struct {
	Batches *[]InstancesBatchCreateInputBatches `json:"batches,omitempty"`
}

// InstancesBatchCreateInputBatches defines model for InstancesBatchCreateInput_batches.
type InstancesBatchCreateInputBatches struct {
	AlwaysPxe    *bool                   `json:"always_pxe,omitempty"`
	BillingCycle *string                 `json:"billing_cycle,omitempty"`
	Customdata   *map[string]interface{} `json:"customdata,omitempty"`
	Description  *string                 `json:"description,omitempty"`

	// Array of facility codes the batch can use for provisioning. This param also takes a string if you want the batch to be fulfilled in only one facility. Cannot be set if the metro is already set.
	Facility    *[]string                               `json:"facility,omitempty"`
	Features    *[]string                               `json:"features,omitempty"`
	Hostname    *string                                 `json:"hostname,omitempty"`
	Hostnames   *[]string                               `json:"hostnames,omitempty"`
	IpAddresses *[]InstancesBatchCreateInputIpAddresses `json:"ip_addresses,omitempty"`
	Locked      *bool                                   `json:"locked,omitempty"`

	// The metro ID or code the batch can use for provisioning. Cannot be set if the facility is already set.
	Metro           *string    `json:"metro,omitempty"`
	NoSshKeys       *bool      `json:"no_ssh_keys,omitempty"`
	OperatingSystem *string    `json:"operating_system,omitempty"`
	Plan            *string    `json:"plan,omitempty"`
	ProjectSshKeys  *[]string  `json:"project_ssh_keys,omitempty"`
	Tags            *[]string  `json:"tags,omitempty"`
	TerminationTime *time.Time `json:"termination_time,omitempty"`

	// The UUIDs of users whose SSH keys should be included on the provisioned device.
	UserSshKeys *[]string `json:"user_ssh_keys,omitempty"`
	Userdata    *string   `json:"userdata,omitempty"`
}

// InstancesBatchCreateInputIpAddresses defines model for InstancesBatchCreateInput_ip_addresses.
type InstancesBatchCreateInputIpAddresses struct {
	// Address Family for IP Address
	AddressFamily *int32 `json:"address_family,omitempty"`

	// Cidr Size for the IP Block created. Valid values depends on the operating system been provisioned (28..32 for IPv4 addresses, 124..127 for IPv6 addresses).
	Cidr *int32 `json:"cidr,omitempty"`

	// UUIDs of any IP reservations to use when assigning IPs
	IpReservations *[]string `json:"ip_reservations,omitempty"`

	// Address Type for IP Address
	Public *bool `json:"public,omitempty"`
}

// Interconnection defines model for Interconnection.
type Interconnection struct {
	ContactEmail *string `json:"contact_email,omitempty"`
	Description  *string `json:"description,omitempty"`
	Facility     *Href   `json:"facility,omitempty"`
	Id           *string `json:"id,omitempty"`
	Metro        *struct {
		// Embedded struct due to allOf(#/components/schemas/Metro)
		Metro `yaml:",inline"`
		// Embedded fields due to inline allOf schema
	} `json:"metro,omitempty"`

	// The mode of the connection (only relevant to dedicated connections). Shared connections won't have this field. Can be either 'standard' or 'tunnel'.
	//   The default mode of a dedicated connection is 'standard'. The mode can only be changed when there are no associated virtual circuits on the connection.
	//   In tunnel mode, an 802.1q tunnel is added to a port to send/receive double tagged packets from server instances.
	Mode         *InterconnectionMode   `json:"mode,omitempty"`
	Name         *string                `json:"name,omitempty"`
	Organization *Href                  `json:"organization,omitempty"`
	Ports        *[]InterconnectionPort `json:"ports,omitempty"`
	Redundancy   *string                `json:"redundancy,omitempty"`

	// The connection's speed in bps.
	Speed  *int      `json:"speed,omitempty"`
	Status *string   `json:"status,omitempty"`
	Tags   *[]string `json:"tags,omitempty"`
	Type   *string   `json:"type,omitempty"`
}

// The mode of the connection (only relevant to dedicated connections). Shared connections won't have this field. Can be either 'standard' or 'tunnel'.
//   The default mode of a dedicated connection is 'standard'. The mode can only be changed when there are no associated virtual circuits on the connection.
//   In tunnel mode, an 802.1q tunnel is added to a port to send/receive double tagged packets from server instances.
type InterconnectionMode string

// InterconnectionCreateInput defines model for InterconnectionCreateInput.
type InterconnectionCreateInput struct {
	ContactEmail *string `json:"contact_email,omitempty"`
	Description  *string `json:"description,omitempty"`

	// A Facility ID or code.
	Facility string `json:"facility"`

	// A Metro ID or code. Required for creating a connection, unless creating with facility.
	Metro *string `json:"metro,omitempty"`

	// The mode of the connection (only relevant to dedicated connections). Shared connections won't have this field. Can be either 'standard' or 'tunnel'.
	//   The default mode of a dedicated connection is 'standard'. The mode can only be changed when there are no associated virtual circuits on the connection.
	//   In tunnel mode, an 802.1q tunnel is added to a port to send/receive double tagged packets from server instances.
	Mode    *InterconnectionCreateInputMode `json:"mode,omitempty"`
	Name    string                          `json:"name"`
	Project *string                         `json:"project,omitempty"`

	// Either 'primary' or 'redundant'.
	Redundancy string `json:"redundancy"`

	// A connection speed, in bps, mbps, or gbps. Ex: '100000000' or '100 mbps'.
	Speed *string   `json:"speed,omitempty"`
	Tags  *[]string `json:"tags,omitempty"`

	// Either 'shared' or 'dedicated'.
	Type string `json:"type"`
}

// The mode of the connection (only relevant to dedicated connections). Shared connections won't have this field. Can be either 'standard' or 'tunnel'.
//   The default mode of a dedicated connection is 'standard'. The mode can only be changed when there are no associated virtual circuits on the connection.
//   In tunnel mode, an 802.1q tunnel is added to a port to send/receive double tagged packets from server instances.
type InterconnectionCreateInputMode string

// InterconnectionList defines model for InterconnectionList.
type InterconnectionList struct {
	Interconnections *[]Interconnection `json:"interconnections,omitempty"`
}

// InterconnectionPort defines model for InterconnectionPort.
type InterconnectionPort struct {
	Id           *string `json:"id,omitempty"`
	Organization *Href   `json:"organization,omitempty"`

	// Either 'primary' or 'secondary'.
	Role   *string `json:"role,omitempty"`
	Status *string `json:"status,omitempty"`

	// A switch 'short ID'
	SwitchId        *string             `json:"switch_id,omitempty"`
	VirtualCircuits *VirtualCircuitList `json:"virtual_circuits,omitempty"`
}

// InterconnectionPortList defines model for InterconnectionPortList.
type InterconnectionPortList struct {
	Ports *[]InterconnectionPort `json:"ports,omitempty"`
}

// InterconnectionUpdateInput defines model for InterconnectionUpdateInput.
type InterconnectionUpdateInput struct {
	ContactEmail *string `json:"contact_email,omitempty"`
	Description  *string `json:"description,omitempty"`

	// The mode of the connection (only relevant to dedicated connections). Shared connections won't have this field. Can be either 'standard' or 'tunnel'.
	//   The default mode of a dedicated connection is 'standard'. The mode can only be changed when there are no associated virtual circuits on the connection.
	//   In tunnel mode, an 802.1q tunnel is added to a port to send/receive double tagged packets from server instances.
	Mode *InterconnectionUpdateInputMode `json:"mode,omitempty"`
	Name *string                         `json:"name,omitempty"`

	// Updating from 'redundant' to 'primary' will remove a secondary port, while updating from 'primary' to 'redundant' will add one.
	Redundancy *string   `json:"redundancy,omitempty"`
	Tags       *[]string `json:"tags,omitempty"`
}

// The mode of the connection (only relevant to dedicated connections). Shared connections won't have this field. Can be either 'standard' or 'tunnel'.
//   The default mode of a dedicated connection is 'standard'. The mode can only be changed when there are no associated virtual circuits on the connection.
//   In tunnel mode, an 802.1q tunnel is added to a port to send/receive double tagged packets from server instances.
type InterconnectionUpdateInputMode string

// Invitation defines model for Invitation.
type Invitation struct {
	CreatedAt    *time.Time `json:"created_at,omitempty"`
	Href         *string    `json:"href,omitempty"`
	Id           *string    `json:"id,omitempty"`
	Invitation   *Href      `json:"invitation,omitempty"`
	InvitedBy    *Href      `json:"invited_by,omitempty"`
	Invitee      *string    `json:"invitee,omitempty"`
	Organization *Href      `json:"organization,omitempty"`
	ProjectsIds  *[]string  `json:"projects_ids,omitempty"`
	Roles        *[]string  `json:"roles,omitempty"`
	UpdatedAt    *time.Time `json:"updated_at,omitempty"`
}

// InvitationInput defines model for InvitationInput.
type InvitationInput struct {
	Invitee     string    `json:"invitee"`
	Message     *string   `json:"message,omitempty"`
	ProjectsIds *[]string `json:"projects_ids,omitempty"`
	Roles       *[]string `json:"roles,omitempty"`
}

// InvitationList defines model for InvitationList.
type InvitationList struct {
	Invitations *[]Membership `json:"invitations,omitempty"`
}

// License defines model for License.
type License struct {
	Description     *string `json:"description,omitempty"`
	Id              *string `json:"id,omitempty"`
	LicenseKey      *string `json:"license_key,omitempty"`
	LicenseeProduct *Href   `json:"licensee_product,omitempty"`
	Project         *Href   `json:"project,omitempty"`
	Size            *int    `json:"size,omitempty"`
}

// LicenseCreateInput defines model for LicenseCreateInput.
type LicenseCreateInput struct {
	Description       *string `json:"description,omitempty"`
	LicenseeProductId *string `json:"licensee_product_id,omitempty"`
	Size              *int    `json:"size,omitempty"`
}

// LicenseList defines model for LicenseList.
type LicenseList struct {
	Licenses *[]License `json:"licenses,omitempty"`
}

// LicenseUpdateInput defines model for LicenseUpdateInput.
type LicenseUpdateInput struct {
	Description *string `json:"description,omitempty"`
	Size        *int    `json:"size,omitempty"`
}

// Membership defines model for Membership.
type Membership struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Href      *string    `json:"href,omitempty"`
	Id        *string    `json:"id,omitempty"`
	Project   *Href      `json:"project,omitempty"`
	Roles     *[]string  `json:"roles,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	User      *Href      `json:"user,omitempty"`
}

// MembershipInput defines model for MembershipInput.
type MembershipInput struct {
	Role *[]string `json:"role,omitempty"`
}

// MembershipList defines model for MembershipList.
type MembershipList struct {
	Memberships *[]Membership `json:"memberships,omitempty"`
}

// Meta defines model for Meta.
type Meta struct {
	First    *Href `json:"first,omitempty"`
	Last     *Href `json:"last,omitempty"`
	Next     *Href `json:"next,omitempty"`
	Previous *Href `json:"previous,omitempty"`
	Self     *Href `json:"self,omitempty"`
	Total    *int  `json:"total,omitempty"`
}

// MetalGateway defines model for MetalGateway.
type MetalGateway struct {
	CreatedAt     *time.Time `json:"created_at,omitempty"`
	CreatedBy     *Href      `json:"created_by,omitempty"`
	Href          *string    `json:"href,omitempty"`
	Id            *string    `json:"id,omitempty"`
	IpReservation *Href      `json:"ip_reservation,omitempty"`
	Project       *Href      `json:"project,omitempty"`

	// The current state of the Metal Gateway. 'Ready' indicates the gateway record has been configured, but is currently not active on the network. 'Active' indicates the gateway has been configured on the network. 'Deleting' is a temporary state used to indicate that the gateway is in the process of being un-configured from the network, after which the gateway record will be deleted.
	State          *MetalGatewayState `json:"state,omitempty"`
	UpdatedAt      *time.Time         `json:"updated_at,omitempty"`
	VirtualNetwork *Href              `json:"virtual_network,omitempty"`
}

// The current state of the Metal Gateway. 'Ready' indicates the gateway record has been configured, but is currently not active on the network. 'Active' indicates the gateway has been configured on the network. 'Deleting' is a temporary state used to indicate that the gateway is in the process of being un-configured from the network, after which the gateway record will be deleted.
type MetalGatewayState string

// MetalGatewayInput defines model for MetalGatewayInput.
type MetalGatewayInput struct {
	// The UUID of an IP reservation that belongs to the same project as where the metal gateway will be created in. This field is required unless the private IPv4 subnet size is specified.
	IpReservationId *string `json:"ip_reservation_id,omitempty"`

	// The subnet size (8, 16, 32, 64, or 128) of the private IPv4 reservation that will be created for the metal gateway. This field is required unless a project IP reservation was specified.
	//           Please keep in mind that the number of private metal gateway ranges are limited per project. If you would like to increase the limit per project, please contact support for assistance.
	PrivateIpv4SubnetSize *int `json:"private_ipv4_subnet_size,omitempty"`

	// The UUID of a metro virtual network that belongs to the same project as where the metal gateway will be created in.
	VirtualNetworkId string `json:"virtual_network_id"`
}

// MetalGatewayList defines model for MetalGatewayList.
type MetalGatewayList struct {
	MetalGateways *[]MetalGateway `json:"MetalGateways,omitempty"`
}

// Metro defines model for Metro.
type Metro struct {
	Code    *string `json:"code,omitempty"`
	Country *string `json:"country,omitempty"`
	Id      *string `json:"id,omitempty"`
	Name    *string `json:"name,omitempty"`
}

// MetroCapacityList defines model for MetroCapacityList.
type MetroCapacityList struct {
	Capacity *MetroCapacityReport `json:"capacity,omitempty"`
}

// MetroCapacityReport defines model for MetroCapacityReport.
type MetroCapacityReport struct {
	Am *CapacityPerFacility `json:"am,omitempty"`
	Ch *CapacityPerFacility `json:"ch,omitempty"`
	Da *CapacityPerFacility `json:"da,omitempty"`
	La *CapacityPerFacility `json:"la,omitempty"`
	Ny *CapacityPerFacility `json:"ny,omitempty"`
	Sg *CapacityPerFacility `json:"sg,omitempty"`
	Sv *CapacityPerFacility `json:"sv,omitempty"`
}

// MetroList defines model for MetroList.
type MetroList struct {
	Metros *[]Metro `json:"metros,omitempty"`
}

// MetroServerInfo defines model for MetroServerInfo.
type MetroServerInfo struct {
	// The metro ID or code to check the capacity in.
	Metro *string `json:"metro,omitempty"`

	// The plan ID or slug to check the capacity of.
	Plan *string `json:"plan,omitempty"`

	// The number of servers to check the capacity of.
	Quantity *string `json:"quantity,omitempty"`
}

// NewPassword defines model for NewPassword.
type NewPassword struct {
	NewPassword *string `json:"new_password,omitempty"`
}

// OperatingSystem defines model for OperatingSystem.
type OperatingSystem struct {
	Distro *string `json:"distro,omitempty"`
	Id     *string `json:"id,omitempty"`

	// Licenced OS is priced according to pricing property
	Licensed *bool   `json:"licensed,omitempty"`
	Name     *string `json:"name,omitempty"`

	// Servers can be already preinstalled with OS in order to shorten provision time.
	Preinstallable *bool `json:"preinstallable,omitempty"`

	// This object contains price per time unit and optional multiplier value if licence price depends on hardware plan or components (e.g. number of cores)
	Pricing         *map[string]interface{} `json:"pricing,omitempty"`
	ProvisionableOn *[]string               `json:"provisionable_on,omitempty"`
	Slug            *string                 `json:"slug,omitempty"`
	Version         *string                 `json:"version,omitempty"`
}

// OperatingSystemList defines model for OperatingSystemList.
type OperatingSystemList []OperatingSystem

// Organization defines model for Organization.
type Organization struct {
	Address        *Address                `json:"address,omitempty"`
	BillingAddress *Address                `json:"billing_address,omitempty"`
	CreatedAt      *time.Time              `json:"created_at,omitempty"`
	CreditAmount   *float64                `json:"credit_amount,omitempty"`
	Customdata     *map[string]interface{} `json:"customdata,omitempty"`
	Description    *string                 `json:"description,omitempty"`

	// Force to all members to have enabled the two factor authentication after that date, unless the value is null
	Enforce2faAt *time.Time   `json:"enforce_2fa_at,omitempty"`
	Entitlement  *Entitlement `json:"entitlement,omitempty"`
	Id           *string      `json:"id,omitempty"`
	Logo         *string      `json:"logo,omitempty"`
	Members      *[]Href      `json:"members,omitempty"`
	Memberships  *[]Href      `json:"memberships,omitempty"`
	Name         *string      `json:"name,omitempty"`
	Projects     *[]Href      `json:"projects,omitempty"`
	Terms        *int         `json:"terms,omitempty"`
	Twitter      *string      `json:"twitter,omitempty"`
	UpdatedAt    *time.Time   `json:"updated_at,omitempty"`
	Website      *string      `json:"website,omitempty"`
}

// OrganizationInput defines model for OrganizationInput.
type OrganizationInput struct {
	Address        *Address                `json:"address,omitempty"`
	BillingAddress *Address                `json:"billing_address,omitempty"`
	Customdata     *map[string]interface{} `json:"customdata,omitempty"`
	Description    *string                 `json:"description,omitempty"`

	// Force to all members to have enabled the two factor authentication after that date, unless the value is null
	Enforce2faAt *time.Time `json:"enforce_2fa_at,omitempty"`
	Logo         *string    `json:"logo,omitempty"`
	Name         *string    `json:"name,omitempty"`
	Twitter      *string    `json:"twitter,omitempty"`
	Website      *string    `json:"website,omitempty"`
}

// OrganizationList defines model for OrganizationList.
type OrganizationList struct {
	Meta          *Meta           `json:"meta,omitempty"`
	Organizations *[]Organization `json:"organizations,omitempty"`
}

// ParentBlock defines model for ParentBlock.
type ParentBlock struct {
	Cidr    *int    `json:"cidr,omitempty"`
	Href    *string `json:"href,omitempty"`
	Netmask *string `json:"netmask,omitempty"`
	Network *string `json:"network,omitempty"`
}

// PaymentMethod defines model for PaymentMethod.
type PaymentMethod struct {
	BillingAddress  *PaymentMethodBillingAddress `json:"billing_address,omitempty"`
	CardType        *string                      `json:"card_type,omitempty"`
	CardholderName  *string                      `json:"cardholder_name,omitempty"`
	CreatedAt       *time.Time                   `json:"created_at,omitempty"`
	CreatedByUser   *Href                        `json:"created_by_user,omitempty"`
	Default         *bool                        `json:"default,omitempty"`
	Email           *string                      `json:"email,omitempty"`
	ExpirationMonth *string                      `json:"expiration_month,omitempty"`
	ExpirationYear  *string                      `json:"expiration_year,omitempty"`
	Id              *string                      `json:"id,omitempty"`
	Name            *string                      `json:"name,omitempty"`
	Organization    *Href                        `json:"organization,omitempty"`
	Projects        *[]Href                      `json:"projects,omitempty"`
	Type            *string                      `json:"type,omitempty"`
	UpdatedAt       *time.Time                   `json:"updated_at,omitempty"`
}

// PaymentMethodBillingAddress defines model for PaymentMethodBillingAddress.
type PaymentMethodBillingAddress struct {
	CountryCodeAlpha2 *string `json:"country_code_alpha2,omitempty"`
	PostalCode        *string `json:"postal_code,omitempty"`
	StreetAddress     *string `json:"street_address,omitempty"`
}

// PaymentMethodCreateInput defines model for PaymentMethodCreateInput.
type PaymentMethodCreateInput struct {
	Default *bool  `json:"default,omitempty"`
	Name    string `json:"name"`
	Nonce   string `json:"nonce"`
}

// PaymentMethodList defines model for PaymentMethodList.
type PaymentMethodList struct {
	PaymentMethods *[]PaymentMethod `json:"payment_methods,omitempty"`
}

// PaymentMethodUpdateInput defines model for PaymentMethodUpdateInput.
type PaymentMethodUpdateInput struct {
	BillingAddress  *map[string]interface{} `json:"billing_address,omitempty"`
	CardholderName  *string                 `json:"cardholder_name,omitempty"`
	Default         *bool                   `json:"default,omitempty"`
	ExpirationMonth *string                 `json:"expiration_month,omitempty"`
	ExpirationYear  *int                    `json:"expiration_year,omitempty"`
	Name            *string                 `json:"name,omitempty"`
}

// Plan defines model for Plan.
type Plan struct {
	// Shows which facilities the plan is available in, and the facility-based price if it is different from the default price.
	AvailableIn *[]Href                 `json:"available_in,omitempty"`
	Class       *string                 `json:"class,omitempty"`
	Description *string                 `json:"description,omitempty"`
	Id          *string                 `json:"id,omitempty"`
	Legacy      *bool                   `json:"legacy,omitempty"`
	Line        *string                 `json:"line,omitempty"`
	Name        *string                 `json:"name,omitempty"`
	Pricing     *map[string]interface{} `json:"pricing,omitempty"`
	Slug        *string                 `json:"slug,omitempty"`
	Specs       *map[string]interface{} `json:"specs,omitempty"`
}

// PlanList defines model for PlanList.
type PlanList struct {
	Plans *[]Plan `json:"plans,omitempty"`
}

// Port defines model for Port.
type Port struct {
	Data *map[string]interface{} `json:"data,omitempty"`

	// Indicates whether or not the bond can be broken on the port (when applicable).
	DisbondOperationSupported *bool   `json:"disbond_operation_supported,omitempty"`
	Href                      *string `json:"href,omitempty"`
	Id                        *string `json:"id,omitempty"`
	Name                      *string `json:"name,omitempty"`
	Type                      *string `json:"type,omitempty"`
	VirtualNetworks           *[]Href `json:"virtual_networks,omitempty"`
}

// PortAssignInput defines model for PortAssignInput.
type PortAssignInput struct {
	// The UUID of the Virtual Network record, or the VLAN value itself (ex: '1001').
	Vnid *string `json:"vnid,omitempty"`
}

// PortConvertLayer3Input defines model for PortConvertLayer3Input.
type PortConvertLayer3Input struct {
	RequestIps *[]PortConvertLayer3InputRequestIps `json:"request_ips,omitempty"`
}

// PortConvertLayer3InputRequestIps defines model for PortConvertLayer3Input_request_ips.
type PortConvertLayer3InputRequestIps struct {
	AddressFamily *int  `json:"address_family,omitempty"`
	Public        *bool `json:"public,omitempty"`
}

// PortVlanAssignment defines model for PortVlanAssignment.
type PortVlanAssignment struct {
	CreatedAt      *time.Time               `json:"created_at,omitempty"`
	Id             *string                  `json:"id,omitempty"`
	Native         *bool                    `json:"native,omitempty"`
	Port           *Href                    `json:"port,omitempty"`
	State          *PortVlanAssignmentState `json:"state,omitempty"`
	UpdatedAt      *time.Time               `json:"updated_at,omitempty"`
	VirtualNetwork *Href                    `json:"virtual_network,omitempty"`
	Vlan           *int                     `json:"vlan,omitempty"`
}

// PortVlanAssignmentState defines model for PortVlanAssignment.State.
type PortVlanAssignmentState string

// PortVlanAssignmentBatch defines model for PortVlanAssignmentBatch.
type PortVlanAssignmentBatch struct {
	CreatedAt       *time.Time                                `json:"created_at,omitempty"`
	ErrorMessages   *[]string                                 `json:"error_messages,omitempty"`
	Id              *string                                   `json:"id,omitempty"`
	Port            *Port                                     `json:"port,omitempty"`
	Quantity        *int                                      `json:"quantity,omitempty"`
	State           *PortVlanAssignmentBatchState             `json:"state,omitempty"`
	UpdatedAt       *time.Time                                `json:"updated_at,omitempty"`
	VlanAssignments *[]PortVlanAssignmentBatchVlanAssignments `json:"vlan_assignments,omitempty"`
}

// PortVlanAssignmentBatchState defines model for PortVlanAssignmentBatch.State.
type PortVlanAssignmentBatchState string

// PortVlanAssignmentBatchCreateInput defines model for PortVlanAssignmentBatchCreateInput.
type PortVlanAssignmentBatchCreateInput struct {
	VlanAssignments *[]PortVlanAssignmentBatchCreateInputVlanAssignments `json:"vlan_assignments,omitempty"`
}

// PortVlanAssignmentBatchCreateInputVlanAssignments defines model for PortVlanAssignmentBatchCreateInput_vlan_assignments.
type PortVlanAssignmentBatchCreateInputVlanAssignments struct {
	Native *bool                                                   `json:"native,omitempty"`
	State  *PortVlanAssignmentBatchCreateInputVlanAssignmentsState `json:"state,omitempty"`
	Vlan   *string                                                 `json:"vlan,omitempty"`
}

// PortVlanAssignmentBatchCreateInputVlanAssignmentsState defines model for PortVlanAssignmentBatchCreateInputVlanAssignments.State.
type PortVlanAssignmentBatchCreateInputVlanAssignmentsState string

// PortVlanAssignmentBatchList defines model for PortVlanAssignmentBatchList.
type PortVlanAssignmentBatchList struct {
	Batches *[]PortVlanAssignmentBatch `json:"batches,omitempty"`
}

// PortVlanAssignmentBatchVlanAssignments defines model for PortVlanAssignmentBatch_vlan_assignments.
type PortVlanAssignmentBatchVlanAssignments struct {
	Id     *string                                      `json:"id,omitempty"`
	Native *bool                                        `json:"native,omitempty"`
	State  *PortVlanAssignmentBatchVlanAssignmentsState `json:"state,omitempty"`
	Vlan   *int                                         `json:"vlan,omitempty"`
}

// PortVlanAssignmentBatchVlanAssignmentsState defines model for PortVlanAssignmentBatchVlanAssignments.State.
type PortVlanAssignmentBatchVlanAssignmentsState string

// PortVlanAssignmentList defines model for PortVlanAssignmentList.
type PortVlanAssignmentList struct {
	VlanAssignments *[]PortVlanAssignment `json:"vlan_assignments,omitempty"`
}

// Project defines model for Project.
type Project struct {
	BgpConfig     *Href                   `json:"bgp_config,omitempty"`
	CreatedAt     *time.Time              `json:"created_at,omitempty"`
	Customdata    *map[string]interface{} `json:"customdata,omitempty"`
	Devices       *[]Href                 `json:"devices,omitempty"`
	Id            *string                 `json:"id,omitempty"`
	Invitations   *[]Href                 `json:"invitations,omitempty"`
	MaxDevices    *map[string]interface{} `json:"max_devices,omitempty"`
	Members       *[]Href                 `json:"members,omitempty"`
	Memberships   *[]Href                 `json:"memberships,omitempty"`
	Name          *string                 `json:"name,omitempty"`
	NetworkStatus *map[string]interface{} `json:"network_status,omitempty"`
	PaymentMethod *Href                   `json:"payment_method,omitempty"`
	SshKeys       *[]Href                 `json:"ssh_keys,omitempty"`
	UpdatedAt     *time.Time              `json:"updated_at,omitempty"`
	Volumes       *[]Href                 `json:"volumes,omitempty"`
}

// ProjectCreateFromRootInput defines model for ProjectCreateFromRootInput.
type ProjectCreateFromRootInput struct {
	Customdata      *map[string]interface{} `json:"customdata,omitempty"`
	Name            string                  `json:"name"`
	OrganizationId  *string                 `json:"organization_id,omitempty"`
	PaymentMethodId *string                 `json:"payment_method_id,omitempty"`
}

// ProjectCreateInput defines model for ProjectCreateInput.
type ProjectCreateInput struct {
	Customdata      *map[string]interface{} `json:"customdata,omitempty"`
	Name            string                  `json:"name"`
	PaymentMethodId *string                 `json:"payment_method_id,omitempty"`
}

// ProjectList defines model for ProjectList.
type ProjectList struct {
	Meta     *Meta      `json:"meta,omitempty"`
	Projects *[]Project `json:"projects,omitempty"`
}

// ProjectUpdateInput defines model for ProjectUpdateInput.
type ProjectUpdateInput struct {
	BackendTransferEnabled *bool                   `json:"backend_transfer_enabled,omitempty"`
	Customdata             *map[string]interface{} `json:"customdata,omitempty"`
	Name                   *string                 `json:"name,omitempty"`
	PaymentMethodId        *string                 `json:"payment_method_id,omitempty"`
}

// ProjectUsage defines model for ProjectUsage.
type ProjectUsage struct {
	Facility    *string `json:"facility,omitempty"`
	Name        *string `json:"name,omitempty"`
	Plan        *string `json:"plan,omitempty"`
	PlanVersion *string `json:"plan_version,omitempty"`
	Price       *string `json:"price,omitempty"`
	Quantity    *string `json:"quantity,omitempty"`
	Total       *string `json:"total,omitempty"`
	Type        *string `json:"type,omitempty"`
	Unit        *string `json:"unit,omitempty"`
}

// ProjectUsageList defines model for ProjectUsageList.
type ProjectUsageList struct {
	Usages *[]ProjectUsage `json:"usages,omitempty"`
}

// RecoveryCodeList defines model for RecoveryCodeList.
type RecoveryCodeList struct {
	RecoveryCodes *[]string `json:"recovery_codes,omitempty"`
}

// SSHKey defines model for SSHKey.
type SSHKey struct {
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	Entity      *Href      `json:"entity,omitempty"`
	Fingerprint *string    `json:"fingerprint,omitempty"`
	Href        *string    `json:"href,omitempty"`
	Id          *string    `json:"id,omitempty"`
	Key         *string    `json:"key,omitempty"`
	Label       *string    `json:"label,omitempty"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
}

// SSHKeyCreateInput defines model for SSHKeyCreateInput.
type SSHKeyCreateInput struct {
	// List of instance UUIDs to associate SSH key with, when empty array is sent all instances belonging
	//       to entity will be included
	InstancesIds *[]string `json:"instances_ids,omitempty"`
	Key          *string   `json:"key,omitempty"`
	Label        *string   `json:"label,omitempty"`
}

// SSHKeyInput defines model for SSHKeyInput.
type SSHKeyInput struct {
	Key   *string `json:"key,omitempty"`
	Label *string `json:"label,omitempty"`
}

// SSHKeyList defines model for SSHKeyList.
type SSHKeyList struct {
	SshKeys *[]SSHKey `json:"ssh_keys,omitempty"`
}

// SelfServiceReservationItemRequest defines model for SelfServiceReservationItemRequest.
type SelfServiceReservationItemRequest struct {
	Amount   *float64 `json:"amount,omitempty"`
	MetroId  *string  `json:"metro_id,omitempty"`
	PlanId   *string  `json:"plan_id,omitempty"`
	Quantity *int     `json:"quantity,omitempty"`
	Term     *string  `json:"term,omitempty"`
}

// SelfServiceReservationItemResponse defines model for SelfServiceReservationItemResponse.
type SelfServiceReservationItemResponse struct {
	Amount    *float64 `json:"amount,omitempty"`
	Id        *string  `json:"id,omitempty"`
	MetroCode *string  `json:"metro_code,omitempty"`
	MetroId   *string  `json:"metro_id,omitempty"`
	MetroName *string  `json:"metro_name,omitempty"`
	PlanId    *string  `json:"plan_id,omitempty"`
	PlanName  *string  `json:"plan_name,omitempty"`
	PlanSlug  *string  `json:"plan_slug,omitempty"`
	Quantity  *int     `json:"quantity,omitempty"`
	Term      *string  `json:"term,omitempty"`
}

// SelfServiceReservationList defines model for SelfServiceReservationList.
type SelfServiceReservationList struct {
	Reservations *[]SelfServiceReservationResponse `json:"reservations,omitempty"`
}

// SelfServiceReservationResponse defines model for SelfServiceReservationResponse.
type SelfServiceReservationResponse struct {
	CreatedAt      *time.Time                                 `json:"created_at,omitempty"`
	Item           *[]SelfServiceReservationItemResponse      `json:"item,omitempty"`
	Notes          *string                                    `json:"notes,omitempty"`
	Organization   *string                                    `json:"organization,omitempty"`
	OrganizationId *string                                    `json:"organization_id,omitempty"`
	Period         *CreateSelfServiceReservationRequestPeriod `json:"period,omitempty"`
	Project        *string                                    `json:"project,omitempty"`
	ProjectId      *string                                    `json:"project_id,omitempty"`
	StartDate      *time.Time                                 `json:"start_date,omitempty"`
	Status         *string                                    `json:"status,omitempty"`
	TotalCost      *int                                       `json:"total_cost,omitempty"`
}

// ServerInfo defines model for ServerInfo.
type ServerInfo struct {
	Facility *string `json:"facility,omitempty"`
	Plan     *string `json:"plan,omitempty"`
	Quantity *string `json:"quantity,omitempty"`
}

// SnapshotPolicy defines model for SnapshotPolicy.
type SnapshotPolicy struct {
	CreatedAt         *time.Time `json:"created_at,omitempty"`
	Href              *string    `json:"href,omitempty"`
	Id                *string    `json:"id,omitempty"`
	SnapshotCount     *int       `json:"snapshot_count,omitempty"`
	SnapshotFrequency *string    `json:"snapshot_frequency,omitempty"`
	UpdatedAt         *time.Time `json:"updated_at,omitempty"`
	Volume            *Href      `json:"volume,omitempty"`
}

// SnapshotPolicyInput defines model for SnapshotPolicyInput.
type SnapshotPolicyInput struct {
	SnapshotCount     *int    `json:"snapshot_count,omitempty"`
	SnapshotFrequency *string `json:"snapshot_frequency,omitempty"`
}

// SpotMarketPricesList defines model for SpotMarketPricesList.
type SpotMarketPricesList struct {
	SpotMarketPrices *SpotPricesReport `json:"spot_market_prices,omitempty"`
}

// SpotMarketPricesPerMetroList defines model for SpotMarketPricesPerMetroList.
type SpotMarketPricesPerMetroList struct {
	SpotMarketPrices *SpotMarketPricesPerMetroReport `json:"spot_market_prices,omitempty"`
}

// SpotMarketPricesPerMetroReport defines model for SpotMarketPricesPerMetroReport.
type SpotMarketPricesPerMetroReport struct {
	Am *SpotPricesPerFacility `json:"am,omitempty"`
	Ch *SpotPricesPerFacility `json:"ch,omitempty"`
	Da *SpotPricesPerFacility `json:"da,omitempty"`
	La *SpotPricesPerFacility `json:"la,omitempty"`
	Ny *SpotPricesPerFacility `json:"ny,omitempty"`
	Sg *SpotPricesPerFacility `json:"sg,omitempty"`
	Sv *SpotPricesPerFacility `json:"sv,omitempty"`
}

// SpotMarketRequest defines model for SpotMarketRequest.
type SpotMarketRequest struct {
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	DevicesMax  *int       `json:"devices_max,omitempty"`
	DevicesMin  *int       `json:"devices_min,omitempty"`
	EndAt       *time.Time `json:"end_at,omitempty"`
	Facilities  *Href      `json:"facilities,omitempty"`
	Href        *string    `json:"href,omitempty"`
	Id          *string    `json:"id,omitempty"`
	Instances   *Href      `json:"instances,omitempty"`
	MaxBidPrice *float64   `json:"max_bid_price,omitempty"`
	Metro       *struct {
		// Embedded struct due to allOf(#/components/schemas/Metro)
		Metro `yaml:",inline"`
		// Embedded fields due to inline allOf schema
	} `json:"metro,omitempty"`
	Project *Href `json:"project,omitempty"`
}

// SpotMarketRequestCreateInput defines model for SpotMarketRequestCreateInput.
type SpotMarketRequestCreateInput struct {
	DevicesMax         *int                                            `json:"devices_max,omitempty"`
	DevicesMin         *int                                            `json:"devices_min,omitempty"`
	EndAt              *time.Time                                      `json:"end_at,omitempty"`
	Facilities         *[]string                                       `json:"facilities,omitempty"`
	InstanceAttributes *SpotMarketRequestCreateInputInstanceAttributes `json:"instance_attributes,omitempty"`
	MaxBidPrice        *float64                                        `json:"max_bid_price,omitempty"`

	// The metro ID or code the spot market request will be created in.
	Metro *string `json:"metro,omitempty"`
}

// SpotMarketRequestCreateInputInstanceAttributes defines model for SpotMarketRequestCreateInput_instance_attributes.
type SpotMarketRequestCreateInputInstanceAttributes struct {
	AlwaysPxe             *bool                   `json:"always_pxe,omitempty"`
	BillingCycle          *string                 `json:"billing_cycle,omitempty"`
	Customdata            *map[string]interface{} `json:"customdata,omitempty"`
	Description           *string                 `json:"description,omitempty"`
	Features              *[]string               `json:"features,omitempty"`
	Hostname              *string                 `json:"hostname,omitempty"`
	Hostnames             *[]string               `json:"hostnames,omitempty"`
	Locked                *bool                   `json:"locked,omitempty"`
	NoSshKeys             *bool                   `json:"no_ssh_keys,omitempty"`
	OperatingSystem       *string                 `json:"operating_system,omitempty"`
	Plan                  *string                 `json:"plan,omitempty"`
	PrivateIpv4SubnetSize *int                    `json:"private_ipv4_subnet_size,omitempty"`
	ProjectSshKeys        *[]string               `json:"project_ssh_keys,omitempty"`
	PublicIpv4SubnetSize  *int                    `json:"public_ipv4_subnet_size,omitempty"`
	Tags                  *[]string               `json:"tags,omitempty"`
	TerminationTime       *time.Time              `json:"termination_time,omitempty"`

	// The UUIDs of users whose SSH keys should be included on the provisioned device.
	UserSshKeys *[]string `json:"user_ssh_keys,omitempty"`
	Userdata    *string   `json:"userdata,omitempty"`
}

// SpotMarketRequestList defines model for SpotMarketRequestList.
type SpotMarketRequestList struct {
	SpotMarketRequests *[]SpotMarketRequest `json:"spot_market_requests,omitempty"`
}

// SpotPricesDatapoints defines model for SpotPricesDatapoints.
type SpotPricesDatapoints struct {
	Datapoints *[]SpotPricesDatapointsList `json:"datapoints,omitempty"`
}

// SpotPricesDatapointsList defines model for SpotPricesDatapointsList.
type SpotPricesDatapointsList []int

// SpotPricesHistoryReport defines model for SpotPricesHistoryReport.
type SpotPricesHistoryReport struct {
	PricesHistory *SpotPricesDatapoints `json:"prices_history,omitempty"`
}

// SpotPricesPerBaremetal defines model for SpotPricesPerBaremetal.
type SpotPricesPerBaremetal struct {
	Price *float64 `json:"price,omitempty"`
}

// SpotPricesPerFacility defines model for SpotPricesPerFacility.
type SpotPricesPerFacility struct {
	Baremetal0   *SpotPricesPerBaremetal `json:"baremetal_0,omitempty"`
	Baremetal1   *SpotPricesPerBaremetal `json:"baremetal_1,omitempty"`
	Baremetal2   *SpotPricesPerBaremetal `json:"baremetal_2,omitempty"`
	Baremetal2a  *SpotPricesPerBaremetal `json:"baremetal_2a,omitempty"`
	Baremetal2a2 *SpotPricesPerBaremetal `json:"baremetal_2a2,omitempty"`
	Baremetal3   *SpotPricesPerBaremetal `json:"baremetal_3,omitempty"`
	BaremetalS   *SpotPricesPerBaremetal `json:"baremetal_s,omitempty"`
	C2MediumX86  *SpotPricesPerBaremetal `json:"c2.medium.x86,omitempty"`
	M2XlargeX86  *SpotPricesPerBaremetal `json:"m2.xlarge.x86,omitempty"`
}

// SpotPricesPerNewFacility defines model for SpotPricesPerNewFacility.
type SpotPricesPerNewFacility struct {
	Baremetal1e *SpotPricesPerBaremetal `json:"baremetal_1e,omitempty"`
}

// SpotPricesReport defines model for SpotPricesReport.
type SpotPricesReport struct {
	Ams1 *SpotPricesPerFacility    `json:"ams1,omitempty"`
	Atl1 *SpotPricesPerNewFacility `json:"atl1,omitempty"`
	Dfw1 *SpotPricesPerNewFacility `json:"dfw1,omitempty"`
	Ewr1 *SpotPricesPerFacility    `json:"ewr1,omitempty"`
	Fra1 *SpotPricesPerNewFacility `json:"fra1,omitempty"`
	Iad1 *SpotPricesPerNewFacility `json:"iad1,omitempty"`
	Lax1 *SpotPricesPerNewFacility `json:"lax1,omitempty"`
	Nrt1 *SpotPricesPerFacility    `json:"nrt1,omitempty"`
	Ord1 *SpotPricesPerNewFacility `json:"ord1,omitempty"`
	Sea1 *SpotPricesPerNewFacility `json:"sea1,omitempty"`
	Sin1 *SpotPricesPerNewFacility `json:"sin1,omitempty"`
	Sjc1 *SpotPricesPerFacility    `json:"sjc1,omitempty"`
	Syd1 *SpotPricesPerNewFacility `json:"syd1,omitempty"`
	Yyz1 *SpotPricesPerNewFacility `json:"yyz1,omitempty"`
}

// SupportRequestInput defines model for SupportRequestInput.
type SupportRequestInput struct {
	DeviceId  *string                      `json:"device_id,omitempty"`
	Message   string                       `json:"message"`
	Priority  *SupportRequestInputPriority `json:"priority,omitempty"`
	ProjectId *string                      `json:"project_id,omitempty"`
	Subject   string                       `json:"subject"`
}

// SupportRequestInputPriority defines model for SupportRequestInput.Priority.
type SupportRequestInputPriority string

// Timeframe defines model for Timeframe.
type Timeframe struct {
	EndedAt   time.Time `json:"ended_at"`
	StartedAt time.Time `json:"started_at"`
}

// TransferRequest defines model for TransferRequest.
type TransferRequest struct {
	CreatedAt          *time.Time `json:"created_at,omitempty"`
	Href               *string    `json:"href,omitempty"`
	Id                 *string    `json:"id,omitempty"`
	Project            *Href      `json:"project,omitempty"`
	TargetOrganization *Href      `json:"target_organization,omitempty"`
	UpdatedAt          *time.Time `json:"updated_at,omitempty"`
}

// TransferRequestInput defines model for TransferRequestInput.
type TransferRequestInput struct {
	TargetOrganizationId *string `json:"target_organization_id,omitempty"`
}

// TransferRequestList defines model for TransferRequestList.
type TransferRequestList struct {
	Transfers *[]TransferRequest `json:"transfers,omitempty"`
}

// UpdateEmailInput defines model for UpdateEmailInput.
type UpdateEmailInput struct {
	Default *bool `json:"default,omitempty"`
}

// User defines model for User.
type User struct {
	AvatarThumbUrl   *string                 `json:"avatar_thumb_url,omitempty"`
	AvatarUrl        *string                 `json:"avatar_url,omitempty"`
	CreatedAt        *time.Time              `json:"created_at,omitempty"`
	Customdata       *map[string]interface{} `json:"customdata,omitempty"`
	Email            *string                 `json:"email,omitempty"`
	Emails           *[]Href                 `json:"emails,omitempty"`
	FirstName        *string                 `json:"first_name,omitempty"`
	FraudScore       *string                 `json:"fraud_score,omitempty"`
	FullName         *string                 `json:"full_name,omitempty"`
	Href             *string                 `json:"href,omitempty"`
	Id               *string                 `json:"id,omitempty"`
	LastLoginAt      *time.Time              `json:"last_login_at,omitempty"`
	LastName         *string                 `json:"last_name,omitempty"`
	MaxOrganizations *int                    `json:"max_organizations,omitempty"`
	MaxProjects      *int                    `json:"max_projects,omitempty"`
	PhoneNumber      *string                 `json:"phone_number,omitempty"`
	ShortId          *string                 `json:"short_id,omitempty"`
	Timezone         *string                 `json:"timezone,omitempty"`
	TwoFactorAuth    *string                 `json:"two_factor_auth,omitempty"`
	UpdatedAt        *time.Time              `json:"updated_at,omitempty"`
}

// UserCreateInput defines model for UserCreateInput.
type UserCreateInput struct {
	Avatar         *string                 `json:"avatar,omitempty"`
	CompanyName    *string                 `json:"company_name,omitempty"`
	CompanyUrl     *string                 `json:"company_url,omitempty"`
	Customdata     *map[string]interface{} `json:"customdata,omitempty"`
	Emails         []EmailInput            `json:"emails"`
	FirstName      string                  `json:"first_name"`
	LastName       string                  `json:"last_name"`
	Level          *string                 `json:"level,omitempty"`
	Locked         *bool                   `json:"locked,omitempty"`
	Password       *string                 `json:"password,omitempty"`
	PhoneNumber    *string                 `json:"phone_number,omitempty"`
	SocialAccounts *map[string]interface{} `json:"social_accounts,omitempty"`
	Timezone       *string                 `json:"timezone,omitempty"`
	Title          *string                 `json:"title,omitempty"`
	TwoFactorAuth  *string                 `json:"two_factor_auth,omitempty"`
	VerifiedAt     *time.Time              `json:"verified_at,omitempty"`
}

// UserList defines model for UserList.
type UserList struct {
	Meta  *Meta   `json:"meta,omitempty"`
	Users *[]User `json:"users,omitempty"`
}

// UserUpdateInput defines model for UserUpdateInput.
type UserUpdateInput struct {
	Avatar      *string                 `json:"avatar,omitempty"`
	Customdata  *map[string]interface{} `json:"customdata,omitempty"`
	FirstName   *string                 `json:"first_name,omitempty"`
	LastName    *string                 `json:"last_name,omitempty"`
	Password    *string                 `json:"password,omitempty"`
	PhoneNumber *string                 `json:"phone_number,omitempty"`
	Timezone    *string                 `json:"timezone,omitempty"`
}

// VirtualCircuit defines model for VirtualCircuit.
type VirtualCircuit struct {
	Description *string `json:"description,omitempty"`
	Id          *string `json:"id,omitempty"`
	Name        *string `json:"name,omitempty"`
	NniVlan     *int    `json:"nni_vlan,omitempty"`
	Project     *Href   `json:"project,omitempty"`

	// integer representing bps speed
	Speed          *int      `json:"speed,omitempty"`
	Status         *string   `json:"status,omitempty"`
	Tags           *[]string `json:"tags,omitempty"`
	VirtualNetwork *Href     `json:"virtual_network,omitempty"`
	Vnid           *int      `json:"vnid,omitempty"`
}

// VirtualCircuitCreateInput defines model for VirtualCircuitCreateInput.
type VirtualCircuitCreateInput struct {
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
	NniVlan     *int    `json:"nni_vlan,omitempty"`
	Project     *string `json:"project,omitempty"`

	// speed can be passed as integer number representing bps speed or string (e.g. '52m' or '100g' or '4 gbps')
	Speed *int      `json:"speed,omitempty"`
	Tags  *[]string `json:"tags,omitempty"`

	// A Virtual Network record UUID or the VNID of a Virtual Network in your project (sent as integer).
	Vnid *string `json:"vnid,omitempty"`
}

// VirtualCircuitList defines model for VirtualCircuitList.
type VirtualCircuitList struct {
	VirtualCircuits *[]VirtualCircuit `json:"virtual_circuits,omitempty"`
}

// VirtualCircuitUpdateInput defines model for VirtualCircuitUpdateInput.
type VirtualCircuitUpdateInput struct {
	Description *string   `json:"description,omitempty"`
	Name        *string   `json:"name,omitempty"`
	Speed       *string   `json:"speed,omitempty"`
	Tags        *[]string `json:"tags,omitempty"`

	// A Virtual Network record UUID or the VNID of a Virtual Network in your project.
	Vnid *string `json:"vnid,omitempty"`
}

// VirtualNetwork defines model for VirtualNetwork.
type VirtualNetwork struct {
	AssignedTo *Href `json:"assigned_to,omitempty"`

	// True if the virtual network is attached to a virtual circuit. False if not.
	AssignedToVirtualCircuit *bool   `json:"assigned_to_virtual_circuit,omitempty"`
	Description              *string `json:"description,omitempty"`
	Facility                 *Href   `json:"facility,omitempty"`
	Href                     *string `json:"href,omitempty"`
	Id                       *string `json:"id,omitempty"`

	// A list of instances with ports currently associated to this Virtual Network.
	Instances *[]Href `json:"instances,omitempty"`
	Metro     *Href   `json:"metro,omitempty"`

	// The Metro code of the metro in which this Virtual Network is defined.
	MetroCode *string `json:"metro_code,omitempty"`
	Vxlan     *int    `json:"vxlan,omitempty"`
}

// VirtualNetworkCreateInput defines model for VirtualNetworkCreateInput.
type VirtualNetworkCreateInput struct {
	Description *string `json:"description,omitempty"`

	// The UUID (or facility code) for the Facility in which to create this Virtual network.
	Facility *string `json:"facility,omitempty"`

	// The UUID (or metro code) for the Metro in which to create this Virtual Network.
	Metro     *string `json:"metro,omitempty"`
	ProjectId string  `json:"project_id"`

	// VLAN ID between 2-3999. Must be unique for the project within the Metro in which this Virtual Network is being created. If no value is specified, the next-available VLAN ID in the range 1000-1999 will be automatically selected.
	Vxlan *int `json:"vxlan,omitempty"`
}

// VirtualNetworkList defines model for VirtualNetworkList.
type VirtualNetworkList struct {
	VirtualNetworks *[]VirtualNetwork `json:"virtual_networks,omitempty"`
}

// Volume defines model for Volume.
type Volume struct {
	Attachments      *[]Href                 `json:"attachments,omitempty"`
	BillingCycle     *string                 `json:"billing_cycle,omitempty"`
	CreatedAt        *time.Time              `json:"created_at,omitempty"`
	Customdata       *map[string]interface{} `json:"customdata,omitempty"`
	Description      *string                 `json:"description,omitempty"`
	Facility         *Href                   `json:"facility,omitempty"`
	Href             *string                 `json:"href,omitempty"`
	Id               *string                 `json:"id,omitempty"`
	Locked           *bool                   `json:"locked,omitempty"`
	Name             *string                 `json:"name,omitempty"`
	Plan             *Plan                   `json:"plan,omitempty"`
	Project          *Href                   `json:"project,omitempty"`
	Size             *int                    `json:"size,omitempty"`
	SnapshotPolicies *[]Href                 `json:"snapshot_policies,omitempty"`
	State            *string                 `json:"state,omitempty"`
	UpdatedAt        *time.Time              `json:"updated_at,omitempty"`
}

// VolumeAttachment defines model for VolumeAttachment.
type VolumeAttachment struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Device    *Href      `json:"device,omitempty"`
	Href      *string    `json:"href,omitempty"`
	Id        *string    `json:"id,omitempty"`
	Volume    *Href      `json:"volume,omitempty"`
}

// VolumeAttachmentInput defines model for VolumeAttachmentInput.
type VolumeAttachmentInput struct {
	DeviceId string `json:"device_id"`
}

// VolumeAttachmentList defines model for VolumeAttachmentList.
type VolumeAttachmentList struct {
	Attachments *[]VolumeAttachment `json:"attachments,omitempty"`
}

// VolumeCreateInput defines model for VolumeCreateInput.
type VolumeCreateInput struct {
	// hourly
	BillingCycle *string                 `json:"billing_cycle,omitempty"`
	Customdata   *map[string]interface{} `json:"customdata,omitempty"`
	Description  *string                 `json:"description,omitempty"`

	// ams1, ewr1, nrt1, sjc1
	Facility string `json:"facility"`
	Locked   *bool  `json:"locked,omitempty"`

	// storage_1, storage_2
	Plan             string               `json:"plan"`
	Size             int                  `json:"size"`
	SnapshotPolicies *SnapshotPolicyInput `json:"snapshot_policies,omitempty"`
}

// VolumeList defines model for VolumeList.
type VolumeList struct {
	Meta    *Meta     `json:"meta,omitempty"`
	Volumes *[]Volume `json:"volumes,omitempty"`
}

// VolumeSnapshot defines model for VolumeSnapshot.
type VolumeSnapshot struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Id        *string    `json:"id,omitempty"`
	Status    *string    `json:"status,omitempty"`
	Timestamp *time.Time `json:"timestamp,omitempty"`
	Volume    *Href      `json:"volume,omitempty"`
}

// VolumeSnapshotList defines model for VolumeSnapshotList.
type VolumeSnapshotList struct {
	Snapshots *[]VolumeSnapshot `json:"snapshots,omitempty"`
}

// VolumeUpdateInput defines model for VolumeUpdateInput.
type VolumeUpdateInput struct {
	// hourly
	BillingCycle *string                 `json:"billing_cycle,omitempty"`
	Customdata   *map[string]interface{} `json:"customdata,omitempty"`
	Description  *string                 `json:"description,omitempty"`
	Locked       *bool                   `json:"locked,omitempty"`
	Size         *int                    `json:"size,omitempty"`
}

// DeleteBatchParams defines parameters for DeleteBatch.
type DeleteBatchParams struct {
	// Delete all instances created from this batch
	RemoveAssociatedInstances *bool `json:"remove_associated_instances,omitempty"`
}

// FindBatchByIdParams defines parameters for FindBatchById.
type FindBatchByIdParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// FindBgpSessionByIdParams defines parameters for FindBgpSessionById.
type FindBgpSessionByIdParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// UpdateBgpSessionJSONBody defines parameters for UpdateBgpSession.
type UpdateBgpSessionJSONBody bool

// CheckCapacityForFacilityJSONBody defines parameters for CheckCapacityForFacility.
type CheckCapacityForFacilityJSONBody CapacityInput

// CheckCapacityForMetroJSONBody defines parameters for CheckCapacityForMetro.
type CheckCapacityForMetroJSONBody CapacityPerMetroInput

// UpdateInterconnectionJSONBody defines parameters for UpdateInterconnection.
type UpdateInterconnectionJSONBody InterconnectionUpdateInput

// FindConnectionEventsParams defines parameters for FindConnectionEvents.
type FindConnectionEventsParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// FindConnectionPortEventsParams defines parameters for FindConnectionPortEvents.
type FindConnectionPortEventsParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// CreateConnectionPortVirtualCircuitJSONBody defines parameters for CreateConnectionPortVirtualCircuit.
type CreateConnectionPortVirtualCircuitJSONBody VirtualCircuitCreateInput

// DeleteDeviceParams defines parameters for DeleteDevice.
type DeleteDeviceParams struct {
	// Force the deletion of the device, by detaching any storage volume still active.
	ForceDelete *bool `json:"force_delete,omitempty"`
}

// FindDeviceByIdParams defines parameters for FindDeviceById.
type FindDeviceByIdParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// UpdateDeviceJSONBody defines parameters for UpdateDevice.
type UpdateDeviceJSONBody DeviceUpdateInput

// PerformActionParams defines parameters for PerformAction.
type PerformActionParams struct {
	// Action to perform
	Type PerformActionParamsType `json:"type"`
}

// PerformActionParamsType defines parameters for PerformAction.
type PerformActionParamsType string

// FindInstanceBandwidthParams defines parameters for FindInstanceBandwidth.
type FindInstanceBandwidthParams struct {
	// Timestamp from range
	From string `json:"from"`

	// Timestamp to range
	Until string `json:"until"`
}

// CreateBgpSessionJSONBody defines parameters for CreateBgpSession.
type CreateBgpSessionJSONBody BGPSessionInput

// FindDeviceEventsParams defines parameters for FindDeviceEvents.
type FindDeviceEventsParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// FindIPAssignmentsParams defines parameters for FindIPAssignments.
type FindIPAssignmentsParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// CreateIPAssignmentJSONBody defines parameters for CreateIPAssignment.
type CreateIPAssignmentJSONBody IPAssignmentInput

// FindDeviceSSHKeysParams defines parameters for FindDeviceSSHKeys.
type FindDeviceSSHKeysParams struct {
	// Search by key, label, or fingerprint
	SearchString *string `json:"Search string,omitempty"`

	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// FindTrafficJSONBody defines parameters for FindTraffic.
type FindTrafficJSONBody Timeframe

// FindTrafficParams defines parameters for FindTraffic.
type FindTrafficParams struct {
	// Traffic direction
	Direction FindTrafficParamsDirection `json:"direction"`

	// Traffic interval
	Interval *FindTrafficParamsInterval `json:"interval,omitempty"`

	// Traffic bucket
	Bucket *FindTrafficParamsBucket `json:"bucket,omitempty"`
}

// FindTrafficParamsDirection defines parameters for FindTraffic.
type FindTrafficParamsDirection string

// FindTrafficParamsInterval defines parameters for FindTraffic.
type FindTrafficParamsInterval string

// FindTrafficParamsBucket defines parameters for FindTraffic.
type FindTrafficParamsBucket string

// FindDeviceUsagesParams defines parameters for FindDeviceUsages.
type FindDeviceUsagesParams struct {
	// Filter usages created after this date
	CreatedAfter *string `json:"created[after],omitempty"`

	// Filter usages created before this date
	CreatedBefore *string `json:"created[before],omitempty"`
}

// CreateEmailJSONBody defines parameters for CreateEmail.
type CreateEmailJSONBody CreateEmailInput

// FindEmailByIdParams defines parameters for FindEmailById.
type FindEmailByIdParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// UpdateEmailJSONBody defines parameters for UpdateEmail.
type UpdateEmailJSONBody UpdateEmailInput

// FindEventsParams defines parameters for FindEvents.
type FindEventsParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// FindEventByIdParams defines parameters for FindEventById.
type FindEventByIdParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// FindFacilitiesParams defines parameters for FindFacilities.
type FindFacilitiesParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]FindFacilitiesParamsInclude `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]FindFacilitiesParamsExclude `json:"exclude,omitempty"`
}

// FindFacilitiesParamsInclude defines parameters for FindFacilities.
type FindFacilitiesParamsInclude string

// FindFacilitiesParamsExclude defines parameters for FindFacilities.
type FindFacilitiesParamsExclude string

// FindHardwareReservationByIdParams defines parameters for FindHardwareReservationById.
type FindHardwareReservationByIdParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// MoveHardwareReservationJSONBody defines parameters for MoveHardwareReservation.
type MoveHardwareReservationJSONBody string

// FindIncidentsParams defines parameters for FindIncidents.
type FindIncidentsParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// FindInvitationsParams defines parameters for FindInvitations.
type FindInvitationsParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// FindInvitationByIdParams defines parameters for FindInvitationById.
type FindInvitationByIdParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// FindIPAddressByIdParams defines parameters for FindIPAddressById.
type FindIPAddressByIdParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// UpdateIPAddressParams defines parameters for UpdateIPAddress.
type UpdateIPAddressParams struct {
	// Notes for this IP Assignment
	Details string `json:"details"`

	// Provides the custom metadata stored for this IP Assignment in json format
	Customdata string `json:"customdata"`
}

// FindIPAvailabilitiesParams defines parameters for FindIPAvailabilities.
type FindIPAvailabilitiesParams struct {
	// Size of subnets in bits
	Cidr FindIPAvailabilitiesParamsCidr `json:"cidr"`
}

// FindIPAvailabilitiesParamsCidr defines parameters for FindIPAvailabilities.
type FindIPAvailabilitiesParamsCidr string

// FindLicenseByIdParams defines parameters for FindLicenseById.
type FindLicenseByIdParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// UpdateLicenseJSONBody defines parameters for UpdateLicense.
type UpdateLicenseJSONBody LicenseUpdateInput

// FindSpotMarketPricesParams defines parameters for FindSpotMarketPrices.
type FindSpotMarketPricesParams struct {
	// Facility to check spot market prices
	Facility *string `json:"facility,omitempty"`

	// Plan to check spot market prices
	Plan *string `json:"plan,omitempty"`
}

// FindSpotMarketPricesHistoryParams defines parameters for FindSpotMarketPricesHistory.
type FindSpotMarketPricesHistoryParams struct {
	// Facility to check spot market prices
	Facility string `json:"facility"`

	// Plan to check spot market prices
	Plan string `json:"plan"`

	// Metro to check spot market price history
	Metro *string `json:"metro,omitempty"`

	// Timestamp from range
	From string `json:"from"`

	// Timestamp to range
	Until string `json:"until"`
}

// FindMetroSpotMarketPricesParams defines parameters for FindMetroSpotMarketPrices.
type FindMetroSpotMarketPricesParams struct {
	// Metro to filter spot market prices
	Metro *string `json:"metro,omitempty"`

	// Plan to filter spot market prices
	Plan *string `json:"plan,omitempty"`
}

// FindMembershipByIdParams defines parameters for FindMembershipById.
type FindMembershipByIdParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// UpdateMembershipJSONBody defines parameters for UpdateMembership.
type UpdateMembershipJSONBody MembershipInput

// FindOrganizationsParams defines parameters for FindOrganizations.
type FindOrganizationsParams struct {
	// Include, exclude or show only personal organizations.
	Personal *FindOrganizationsParamsPersonal `json:"personal,omitempty"`

	// Include, exclude or show only organizations that have no projects.
	WithoutProjects *FindOrganizationsParamsWithoutProjects `json:"without_projects,omitempty"`

	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// FindOrganizationsParamsPersonal defines parameters for FindOrganizations.
type FindOrganizationsParamsPersonal string

// FindOrganizationsParamsWithoutProjects defines parameters for FindOrganizations.
type FindOrganizationsParamsWithoutProjects string

// CreateOrganizationJSONBody defines parameters for CreateOrganization.
type CreateOrganizationJSONBody OrganizationInput

// FindOrganizationByIdParams defines parameters for FindOrganizationById.
type FindOrganizationByIdParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// UpdateOrganizationJSONBody defines parameters for UpdateOrganization.
type UpdateOrganizationJSONBody OrganizationInput

// FindOrganizationDevicesParams defines parameters for FindOrganizationDevices.
type FindOrganizationDevicesParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// FindOrganizationEventsParams defines parameters for FindOrganizationEvents.
type FindOrganizationEventsParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// FindFacilitiesByOrganizationParams defines parameters for FindFacilitiesByOrganization.
type FindFacilitiesByOrganizationParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// FindOrganizationInvitationsParams defines parameters for FindOrganizationInvitations.
type FindOrganizationInvitationsParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// CreateOrganizationInvitationJSONBody defines parameters for CreateOrganizationInvitation.
type CreateOrganizationInvitationJSONBody InvitationInput

// FindOperatingSystemsByOrganizationParams defines parameters for FindOperatingSystemsByOrganization.
type FindOperatingSystemsByOrganizationParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// FindOrganizationPaymentMethodsParams defines parameters for FindOrganizationPaymentMethods.
type FindOrganizationPaymentMethodsParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// CreatePaymentMethodJSONBody defines parameters for CreatePaymentMethod.
type CreatePaymentMethodJSONBody PaymentMethodCreateInput

// FindPlansByOrganizationParams defines parameters for FindPlansByOrganization.
type FindPlansByOrganizationParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// FindOrganizationProjectsParams defines parameters for FindOrganizationProjects.
type FindOrganizationProjectsParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// CreateOrganizationProjectJSONBody defines parameters for CreateOrganizationProject.
type CreateOrganizationProjectJSONBody ProjectCreateInput

// FindOrganizationTransfersParams defines parameters for FindOrganizationTransfers.
type FindOrganizationTransfersParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// CreateOrganizationInterconnectionJSONBody defines parameters for CreateOrganizationInterconnection.
type CreateOrganizationInterconnectionJSONBody InterconnectionCreateInput

// FindPaymentMethodByIdParams defines parameters for FindPaymentMethodById.
type FindPaymentMethodByIdParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// UpdatePaymentMethodJSONBody defines parameters for UpdatePaymentMethod.
type UpdatePaymentMethodJSONBody PaymentMethodUpdateInput

// FindPlansParams defines parameters for FindPlans.
type FindPlansParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// FindPortByIdParams defines parameters for FindPortById.
type FindPortByIdParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// AssignPortJSONBody defines parameters for AssignPort.
type AssignPortJSONBody PortAssignInput

// BondPortParams defines parameters for BondPort.
type BondPortParams struct {
	// enable both ports
	BulkEnable *bool `json:"bulk_enable,omitempty"`
}

// ConvertLayer2JSONBody defines parameters for ConvertLayer2.
type ConvertLayer2JSONBody PortAssignInput

// ConvertLayer3JSONBody defines parameters for ConvertLayer3.
type ConvertLayer3JSONBody PortConvertLayer3Input

// DisbondPortParams defines parameters for DisbondPort.
type DisbondPortParams struct {
	// disable both ports
	BulkDisable *bool `json:"bulk_disable,omitempty"`
}

// AssignNativeVlanParams defines parameters for AssignNativeVlan.
type AssignNativeVlanParams struct {
	// Virtual Network ID. May be the UUID of the Virtual Network record, or the VLAN value itself (ex: '1001').
	Vnid string `json:"vnid"`
}

// UnassignPortJSONBody defines parameters for UnassignPort.
type UnassignPortJSONBody PortAssignInput

// FindPortVlanAssignmentsParams defines parameters for FindPortVlanAssignments.
type FindPortVlanAssignmentsParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// CreatePortVlanAssignmentBatchJSONBody defines parameters for CreatePortVlanAssignmentBatch.
type CreatePortVlanAssignmentBatchJSONBody PortVlanAssignmentBatchCreateInput

// FindPortVlanAssignmentByPortIdAndAssignmentIdParams defines parameters for FindPortVlanAssignmentByPortIdAndAssignmentId.
type FindPortVlanAssignmentByPortIdAndAssignmentIdParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// FindProjectsParams defines parameters for FindProjects.
type FindProjectsParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// CreateProjectJSONBody defines parameters for CreateProject.
type CreateProjectJSONBody ProjectCreateFromRootInput

// FindProjectByIdParams defines parameters for FindProjectById.
type FindProjectByIdParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// UpdateProjectJSONBody defines parameters for UpdateProject.
type UpdateProjectJSONBody ProjectUpdateInput

// FindProjectAPIKeysParams defines parameters for FindProjectAPIKeys.
type FindProjectAPIKeysParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// CreateProjectAPIKeyJSONBody defines parameters for CreateProjectAPIKey.
type CreateProjectAPIKeyJSONBody AuthTokenInput

// FindBatchesByProjectParams defines parameters for FindBatchesByProject.
type FindBatchesByProjectParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// FindBgpConfigByProjectParams defines parameters for FindBgpConfigByProject.
type FindBgpConfigByProjectParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// RequestBgpConfigJSONBody defines parameters for RequestBgpConfig.
type RequestBgpConfigJSONBody BgpConfigRequestInput

// FindProjectDevicesParams defines parameters for FindProjectDevices.
type FindProjectDevicesParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// CreateDeviceJSONBody defines parameters for CreateDevice.
type CreateDeviceJSONBody DeviceCreateInput

// CreateDeviceBatchJSONBody defines parameters for CreateDeviceBatch.
type CreateDeviceBatchJSONBody InstancesBatchCreateInput

// FindProjectEventsParams defines parameters for FindProjectEvents.
type FindProjectEventsParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// FindFacilitiesByProjectParams defines parameters for FindFacilitiesByProject.
type FindFacilitiesByProjectParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// FindProjectHardwareReservationsParams defines parameters for FindProjectHardwareReservations.
type FindProjectHardwareReservationsParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// FindIPReservationsParams defines parameters for FindIPReservations.
type FindIPReservationsParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// RequestIPReservationJSONBody defines parameters for RequestIPReservation.
type RequestIPReservationJSONBody IPReservationRequestInput

// FindProjectLicensesParams defines parameters for FindProjectLicenses.
type FindProjectLicensesParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// CreateLicenseJSONBody defines parameters for CreateLicense.
type CreateLicenseJSONBody LicenseCreateInput

// FindPlansByProjectParams defines parameters for FindPlansByProject.
type FindPlansByProjectParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// CreateSpotMarketRequestJSONBody defines parameters for CreateSpotMarketRequest.
type CreateSpotMarketRequestJSONBody SpotMarketRequestCreateInput

// FindProjectSSHKeysParams defines parameters for FindProjectSSHKeys.
type FindProjectSSHKeysParams struct {
	// Search by key, label, or fingerprint
	SearchString *string `json:"Search string,omitempty"`

	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// CreateProjectSSHKeyJSONBody defines parameters for CreateProjectSSHKey.
type CreateProjectSSHKeyJSONBody SSHKeyCreateInput

// FindVolumesParams defines parameters for FindVolumes.
type FindVolumesParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// CreateVolumeJSONBody defines parameters for CreateVolume.
type CreateVolumeJSONBody VolumeCreateInput

// CreateTransferRequestJSONBody defines parameters for CreateTransferRequest.
type CreateTransferRequestJSONBody TransferRequestInput

// FindProjectUsageParams defines parameters for FindProjectUsage.
type FindProjectUsageParams struct {
	// Filter usages created after this date
	CreatedAfter *string `json:"created[after],omitempty"`

	// Filter usages created before this date
	CreatedBefore *string `json:"created[before],omitempty"`
}

// FindVirtualNetworksParams defines parameters for FindVirtualNetworks.
type FindVirtualNetworksParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Filter by Facility ID (uuid) or Facility Code
	Facility *string `json:"facility,omitempty"`

	// Filter by Metro ID (uuid) or Metro Code
	Metro *string `json:"metro,omitempty"`
}

// CreateVirtualNetworkJSONBody defines parameters for CreateVirtualNetwork.
type CreateVirtualNetworkJSONBody VirtualNetworkCreateInput

// CreateProjectInterconnectionJSONBody defines parameters for CreateProjectInterconnection.
type CreateProjectInterconnectionJSONBody InterconnectionCreateInput

// FindProjectInvitationsParams defines parameters for FindProjectInvitations.
type FindProjectInvitationsParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// CreateProjectInvitationJSONBody defines parameters for CreateProjectInvitation.
type CreateProjectInvitationJSONBody InvitationInput

// FindProjectMembershipsParams defines parameters for FindProjectMemberships.
type FindProjectMembershipsParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// FindMetalGatewaysByProjectParams defines parameters for FindMetalGatewaysByProject.
type FindMetalGatewaysByProjectParams struct {
	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// CreateMetalGatewayJSONBody defines parameters for CreateMetalGateway.
type CreateMetalGatewayJSONBody MetalGatewayInput

// CreateMetalGatewayParams defines parameters for CreateMetalGateway.
type CreateMetalGatewayParams struct {
	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// FindSelfServiceReservationsParams defines parameters for FindSelfServiceReservations.
type FindSelfServiceReservationsParams struct {
	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// CreateSelfServiceReservationJSONBody defines parameters for CreateSelfServiceReservation.
type CreateSelfServiceReservationJSONBody CreateSelfServiceReservationRequest

// CreatePasswordResetTokenParams defines parameters for CreatePasswordResetToken.
type CreatePasswordResetTokenParams struct {
	// Email of user to create password reset token
	Email string `json:"email"`
}

// DeleteSpotMarketRequestParams defines parameters for DeleteSpotMarketRequest.
type DeleteSpotMarketRequestParams struct {
	// Terminate associated spot instances
	ForceTermination *bool `json:"force_termination,omitempty"`
}

// FindSpotMarketRequestByIdParams defines parameters for FindSpotMarketRequestById.
type FindSpotMarketRequestByIdParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// FindSSHKeysParams defines parameters for FindSSHKeys.
type FindSSHKeysParams struct {
	// Search by key, label, or fingerprint
	SearchString *string `json:"Search string,omitempty"`

	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// CreateSSHKeyJSONBody defines parameters for CreateSSHKey.
type CreateSSHKeyJSONBody SSHKeyCreateInput

// FindSSHKeyByIdParams defines parameters for FindSSHKeyById.
type FindSSHKeyByIdParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// UpdateSSHKeyJSONBody defines parameters for UpdateSSHKey.
type UpdateSSHKeyJSONBody SSHKeyInput

// FindVolumeAttachmentByIdParams defines parameters for FindVolumeAttachmentById.
type FindVolumeAttachmentByIdParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// UpdateVolumeSnapshotPolicyParams defines parameters for UpdateVolumeSnapshotPolicy.
type UpdateVolumeSnapshotPolicyParams struct {
	// Snapshot count
	SnapshotCount *int `json:"snapshot_count,omitempty"`

	// Snapshot frequency
	SnapshotFrequency UpdateVolumeSnapshotPolicyParamsSnapshotFrequency `json:"snapshot_frequency"`
}

// UpdateVolumeSnapshotPolicyParamsSnapshotFrequency defines parameters for UpdateVolumeSnapshotPolicy.
type UpdateVolumeSnapshotPolicyParamsSnapshotFrequency string

// FindVolumeByIdParams defines parameters for FindVolumeById.
type FindVolumeByIdParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// UpdateVolumeJSONBody defines parameters for UpdateVolume.
type UpdateVolumeJSONBody VolumeUpdateInput

// FindVolumeAttachmentsParams defines parameters for FindVolumeAttachments.
type FindVolumeAttachmentsParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// CreateVolumeAttachmentJSONBody defines parameters for CreateVolumeAttachment.
type CreateVolumeAttachmentJSONBody VolumeAttachmentInput

// CloneVolumeParams defines parameters for CloneVolume.
type CloneVolumeParams struct {
	// snapshot timestamp
	SnapshotTimestamp *string `json:"snapshot_timestamp,omitempty"`
}

// RestoreVolumeParams defines parameters for RestoreVolume.
type RestoreVolumeParams struct {
	// restore point
	RestorePoint string `json:"restore_point"`
}

// CreateVolumeSnapshotPolicyParams defines parameters for CreateVolumeSnapshotPolicy.
type CreateVolumeSnapshotPolicyParams struct {
	// Snapshot count
	SnapshotCount *int `json:"snapshot_count,omitempty"`

	// Snapshot frequency
	SnapshotFrequency CreateVolumeSnapshotPolicyParamsSnapshotFrequency `json:"snapshot_frequency"`
}

// CreateVolumeSnapshotPolicyParamsSnapshotFrequency defines parameters for CreateVolumeSnapshotPolicy.
type CreateVolumeSnapshotPolicyParamsSnapshotFrequency string

// FindVolumeSnapshotsParams defines parameters for FindVolumeSnapshots.
type FindVolumeSnapshotsParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// RequestSuppertJSONBody defines parameters for RequestSuppert.
type RequestSuppertJSONBody SupportRequestInput

// FindTransferRequestByIdParams defines parameters for FindTransferRequestById.
type FindTransferRequestByIdParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// FindCurrentUserParams defines parameters for FindCurrentUser.
type FindCurrentUserParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// UpdateCurrentUserJSONBody defines parameters for UpdateCurrentUser.
type UpdateCurrentUserJSONBody UserUpdateInput

// FindAPIKeysParams defines parameters for FindAPIKeys.
type FindAPIKeysParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// CreateAPIKeyJSONBody defines parameters for CreateAPIKey.
type CreateAPIKeyJSONBody AuthTokenInput

// ValidateUserdataParams defines parameters for ValidateUserdata.
type ValidateUserdataParams struct {
	// Userdata to validate
	Userdata *string `json:"userdata,omitempty"`
}

// FindUsersParams defines parameters for FindUsers.
type FindUsersParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody UserCreateInput

// FindUserByIdParams defines parameters for FindUserById.
type FindUserByIdParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`
}

// CreateValidationRequestParams defines parameters for CreateValidationRequest.
type CreateValidationRequestParams struct {
	// Email for verification request
	Login string `json:"login"`
}

// ConsumeVerificationRequestParams defines parameters for ConsumeVerificationRequest.
type ConsumeVerificationRequestParams struct {
	// User verification token
	Token string `json:"token"`
}

// FindVirtualCircuitEventsParams defines parameters for FindVirtualCircuitEvents.
type FindVirtualCircuitEventsParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// UpdateVirtualCircuitJSONBody defines parameters for UpdateVirtualCircuit.
type UpdateVirtualCircuitJSONBody VirtualCircuitUpdateInput

// FindVolumeEventsParams defines parameters for FindVolumeEvents.
type FindVolumeEventsParams struct {
	// Nested attributes to include. Included objects will return their full attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
	Include *[]string `json:"include,omitempty"`

	// Nested attributes to exclude. Excluded objects will return only the href attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
	Exclude *[]string `json:"exclude,omitempty"`

	// Page to return
	Page *int32 `json:"page,omitempty"`

	// Items returned per page
	PerPage *int32 `json:"per_page,omitempty"`
}

// UpdateBgpSessionJSONRequestBody defines body for UpdateBgpSession for application/json ContentType.
type UpdateBgpSessionJSONRequestBody UpdateBgpSessionJSONBody

// CheckCapacityForFacilityJSONRequestBody defines body for CheckCapacityForFacility for application/json ContentType.
type CheckCapacityForFacilityJSONRequestBody CheckCapacityForFacilityJSONBody

// CheckCapacityForMetroJSONRequestBody defines body for CheckCapacityForMetro for application/json ContentType.
type CheckCapacityForMetroJSONRequestBody CheckCapacityForMetroJSONBody

// UpdateInterconnectionJSONRequestBody defines body for UpdateInterconnection for application/json ContentType.
type UpdateInterconnectionJSONRequestBody UpdateInterconnectionJSONBody

// CreateConnectionPortVirtualCircuitJSONRequestBody defines body for CreateConnectionPortVirtualCircuit for application/json ContentType.
type CreateConnectionPortVirtualCircuitJSONRequestBody CreateConnectionPortVirtualCircuitJSONBody

// UpdateDeviceJSONRequestBody defines body for UpdateDevice for application/json ContentType.
type UpdateDeviceJSONRequestBody UpdateDeviceJSONBody

// CreateBgpSessionJSONRequestBody defines body for CreateBgpSession for application/json ContentType.
type CreateBgpSessionJSONRequestBody CreateBgpSessionJSONBody

// CreateIPAssignmentJSONRequestBody defines body for CreateIPAssignment for application/json ContentType.
type CreateIPAssignmentJSONRequestBody CreateIPAssignmentJSONBody

// FindTrafficJSONRequestBody defines body for FindTraffic for application/json ContentType.
type FindTrafficJSONRequestBody FindTrafficJSONBody

// CreateEmailJSONRequestBody defines body for CreateEmail for application/json ContentType.
type CreateEmailJSONRequestBody CreateEmailJSONBody

// UpdateEmailJSONRequestBody defines body for UpdateEmail for application/json ContentType.
type UpdateEmailJSONRequestBody UpdateEmailJSONBody

// MoveHardwareReservationJSONRequestBody defines body for MoveHardwareReservation for application/json ContentType.
type MoveHardwareReservationJSONRequestBody MoveHardwareReservationJSONBody

// UpdateLicenseJSONRequestBody defines body for UpdateLicense for application/json ContentType.
type UpdateLicenseJSONRequestBody UpdateLicenseJSONBody

// UpdateMembershipJSONRequestBody defines body for UpdateMembership for application/json ContentType.
type UpdateMembershipJSONRequestBody UpdateMembershipJSONBody

// CreateOrganizationJSONRequestBody defines body for CreateOrganization for application/json ContentType.
type CreateOrganizationJSONRequestBody CreateOrganizationJSONBody

// UpdateOrganizationJSONRequestBody defines body for UpdateOrganization for application/json ContentType.
type UpdateOrganizationJSONRequestBody UpdateOrganizationJSONBody

// CreateOrganizationInvitationJSONRequestBody defines body for CreateOrganizationInvitation for application/json ContentType.
type CreateOrganizationInvitationJSONRequestBody CreateOrganizationInvitationJSONBody

// CreatePaymentMethodJSONRequestBody defines body for CreatePaymentMethod for application/json ContentType.
type CreatePaymentMethodJSONRequestBody CreatePaymentMethodJSONBody

// CreateOrganizationProjectJSONRequestBody defines body for CreateOrganizationProject for application/json ContentType.
type CreateOrganizationProjectJSONRequestBody CreateOrganizationProjectJSONBody

// CreateOrganizationInterconnectionJSONRequestBody defines body for CreateOrganizationInterconnection for application/json ContentType.
type CreateOrganizationInterconnectionJSONRequestBody CreateOrganizationInterconnectionJSONBody

// UpdatePaymentMethodJSONRequestBody defines body for UpdatePaymentMethod for application/json ContentType.
type UpdatePaymentMethodJSONRequestBody UpdatePaymentMethodJSONBody

// AssignPortJSONRequestBody defines body for AssignPort for application/json ContentType.
type AssignPortJSONRequestBody AssignPortJSONBody

// ConvertLayer2JSONRequestBody defines body for ConvertLayer2 for application/json ContentType.
type ConvertLayer2JSONRequestBody ConvertLayer2JSONBody

// ConvertLayer3JSONRequestBody defines body for ConvertLayer3 for application/json ContentType.
type ConvertLayer3JSONRequestBody ConvertLayer3JSONBody

// UnassignPortJSONRequestBody defines body for UnassignPort for application/json ContentType.
type UnassignPortJSONRequestBody UnassignPortJSONBody

// CreatePortVlanAssignmentBatchJSONRequestBody defines body for CreatePortVlanAssignmentBatch for application/json ContentType.
type CreatePortVlanAssignmentBatchJSONRequestBody CreatePortVlanAssignmentBatchJSONBody

// CreateProjectJSONRequestBody defines body for CreateProject for application/json ContentType.
type CreateProjectJSONRequestBody CreateProjectJSONBody

// UpdateProjectJSONRequestBody defines body for UpdateProject for application/json ContentType.
type UpdateProjectJSONRequestBody UpdateProjectJSONBody

// CreateProjectAPIKeyJSONRequestBody defines body for CreateProjectAPIKey for application/json ContentType.
type CreateProjectAPIKeyJSONRequestBody CreateProjectAPIKeyJSONBody

// RequestBgpConfigJSONRequestBody defines body for RequestBgpConfig for application/json ContentType.
type RequestBgpConfigJSONRequestBody RequestBgpConfigJSONBody

// CreateDeviceJSONRequestBody defines body for CreateDevice for application/json ContentType.
type CreateDeviceJSONRequestBody CreateDeviceJSONBody

// CreateDeviceBatchJSONRequestBody defines body for CreateDeviceBatch for application/json ContentType.
type CreateDeviceBatchJSONRequestBody CreateDeviceBatchJSONBody

// RequestIPReservationJSONRequestBody defines body for RequestIPReservation for application/json ContentType.
type RequestIPReservationJSONRequestBody RequestIPReservationJSONBody

// CreateLicenseJSONRequestBody defines body for CreateLicense for application/json ContentType.
type CreateLicenseJSONRequestBody CreateLicenseJSONBody

// CreateSpotMarketRequestJSONRequestBody defines body for CreateSpotMarketRequest for application/json ContentType.
type CreateSpotMarketRequestJSONRequestBody CreateSpotMarketRequestJSONBody

// CreateProjectSSHKeyJSONRequestBody defines body for CreateProjectSSHKey for application/json ContentType.
type CreateProjectSSHKeyJSONRequestBody CreateProjectSSHKeyJSONBody

// CreateVolumeJSONRequestBody defines body for CreateVolume for application/json ContentType.
type CreateVolumeJSONRequestBody CreateVolumeJSONBody

// CreateTransferRequestJSONRequestBody defines body for CreateTransferRequest for application/json ContentType.
type CreateTransferRequestJSONRequestBody CreateTransferRequestJSONBody

// CreateVirtualNetworkJSONRequestBody defines body for CreateVirtualNetwork for application/json ContentType.
type CreateVirtualNetworkJSONRequestBody CreateVirtualNetworkJSONBody

// CreateProjectInterconnectionJSONRequestBody defines body for CreateProjectInterconnection for application/json ContentType.
type CreateProjectInterconnectionJSONRequestBody CreateProjectInterconnectionJSONBody

// CreateProjectInvitationJSONRequestBody defines body for CreateProjectInvitation for application/json ContentType.
type CreateProjectInvitationJSONRequestBody CreateProjectInvitationJSONBody

// CreateMetalGatewayJSONRequestBody defines body for CreateMetalGateway for application/json ContentType.
type CreateMetalGatewayJSONRequestBody CreateMetalGatewayJSONBody

// CreateSelfServiceReservationJSONRequestBody defines body for CreateSelfServiceReservation for application/json ContentType.
type CreateSelfServiceReservationJSONRequestBody CreateSelfServiceReservationJSONBody

// CreateSSHKeyJSONRequestBody defines body for CreateSSHKey for application/json ContentType.
type CreateSSHKeyJSONRequestBody CreateSSHKeyJSONBody

// UpdateSSHKeyJSONRequestBody defines body for UpdateSSHKey for application/json ContentType.
type UpdateSSHKeyJSONRequestBody UpdateSSHKeyJSONBody

// UpdateVolumeJSONRequestBody defines body for UpdateVolume for application/json ContentType.
type UpdateVolumeJSONRequestBody UpdateVolumeJSONBody

// CreateVolumeAttachmentJSONRequestBody defines body for CreateVolumeAttachment for application/json ContentType.
type CreateVolumeAttachmentJSONRequestBody CreateVolumeAttachmentJSONBody

// RequestSuppertJSONRequestBody defines body for RequestSuppert for application/json ContentType.
type RequestSuppertJSONRequestBody RequestSuppertJSONBody

// UpdateCurrentUserJSONRequestBody defines body for UpdateCurrentUser for application/json ContentType.
type UpdateCurrentUserJSONRequestBody UpdateCurrentUserJSONBody

// CreateAPIKeyJSONRequestBody defines body for CreateAPIKey for application/json ContentType.
type CreateAPIKeyJSONRequestBody CreateAPIKeyJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserJSONBody

// UpdateVirtualCircuitJSONRequestBody defines body for UpdateVirtualCircuit for application/json ContentType.
type UpdateVirtualCircuitJSONRequestBody UpdateVirtualCircuitJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// DeleteAPIKey request
	DeleteAPIKey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBatch request
	DeleteBatch(ctx context.Context, id string, params *DeleteBatchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindBatchById request
	FindBatchById(ctx context.Context, id string, params *FindBatchByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBgpSession request
	DeleteBgpSession(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindBgpSessionById request
	FindBgpSessionById(ctx context.Context, id string, params *FindBgpSessionByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBgpSession request with any body
	UpdateBgpSessionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBgpSession(ctx context.Context, id string, body UpdateBgpSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindCapacityForFacility request
	FindCapacityForFacility(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckCapacityForFacility request with any body
	CheckCapacityForFacilityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CheckCapacityForFacility(ctx context.Context, body CheckCapacityForFacilityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindCapacityForMetro request
	FindCapacityForMetro(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckCapacityForMetro request with any body
	CheckCapacityForMetroWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CheckCapacityForMetro(ctx context.Context, body CheckCapacityForMetroJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInterconnection request
	DeleteInterconnection(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInterconnection request
	GetInterconnection(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateInterconnection request with any body
	UpdateInterconnectionWithBody(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateInterconnection(ctx context.Context, connectionId string, body UpdateInterconnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindConnectionEvents request
	FindConnectionEvents(ctx context.Context, connectionId string, params *FindConnectionEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListConnectionPorts request
	ListConnectionPorts(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConnectionPort request
	GetConnectionPort(ctx context.Context, connectionId string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindConnectionPortEvents request
	FindConnectionPortEvents(ctx context.Context, connectionId string, id string, params *FindConnectionPortEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListConnectionPortVirtualCircuits request
	ListConnectionPortVirtualCircuits(ctx context.Context, connectionId string, portId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateConnectionPortVirtualCircuit request with any body
	CreateConnectionPortVirtualCircuitWithBody(ctx context.Context, connectionId string, portId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateConnectionPortVirtualCircuit(ctx context.Context, connectionId string, portId string, body CreateConnectionPortVirtualCircuitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDevice request
	DeleteDevice(ctx context.Context, id string, params *DeleteDeviceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindDeviceById request
	FindDeviceById(ctx context.Context, id string, params *FindDeviceByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDevice request with any body
	UpdateDeviceWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDevice(ctx context.Context, id string, body UpdateDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PerformAction request
	PerformAction(ctx context.Context, id string, params *PerformActionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindInstanceBandwidth request
	FindInstanceBandwidth(ctx context.Context, id string, params *FindInstanceBandwidthParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBgpNeighborData request
	GetBgpNeighborData(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindBgpSessions request
	FindBgpSessions(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBgpSession request with any body
	CreateBgpSessionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBgpSession(ctx context.Context, id string, body CreateBgpSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindDeviceCustomdata request
	FindDeviceCustomdata(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindDeviceEvents request
	FindDeviceEvents(ctx context.Context, id string, params *FindDeviceEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindIPAssignments request
	FindIPAssignments(ctx context.Context, id string, params *FindIPAssignmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIPAssignment request with any body
	CreateIPAssignmentWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIPAssignment(ctx context.Context, id string, body CreateIPAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindDeviceSSHKeys request
	FindDeviceSSHKeys(ctx context.Context, id string, params *FindDeviceSSHKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindTraffic request with any body
	FindTrafficWithBody(ctx context.Context, id string, params *FindTrafficParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FindTraffic(ctx context.Context, id string, params *FindTrafficParams, body FindTrafficJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindDeviceUsages request
	FindDeviceUsages(ctx context.Context, id string, params *FindDeviceUsagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindIPAssignmentCustomdata request
	FindIPAssignmentCustomdata(ctx context.Context, instanceId string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEmail request with any body
	CreateEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEmail(ctx context.Context, body CreateEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEmail request
	DeleteEmail(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindEmailById request
	FindEmailById(ctx context.Context, id string, params *FindEmailByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEmail request with any body
	UpdateEmailWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEmail(ctx context.Context, id string, body UpdateEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindEvents request
	FindEvents(ctx context.Context, params *FindEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindEventById request
	FindEventById(ctx context.Context, id string, params *FindEventByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindFacilities request
	FindFacilities(ctx context.Context, params *FindFacilitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindHardwareReservationById request
	FindHardwareReservationById(ctx context.Context, id string, params *FindHardwareReservationByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MoveHardwareReservation request with any body
	MoveHardwareReservationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MoveHardwareReservation(ctx context.Context, id string, body MoveHardwareReservationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindIncidents request
	FindIncidents(ctx context.Context, params *FindIncidentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindInvitations request
	FindInvitations(ctx context.Context, params *FindInvitationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeclineInvitation request
	DeclineInvitation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindInvitationById request
	FindInvitationById(ctx context.Context, id string, params *FindInvitationByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcceptInvitation request
	AcceptInvitation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIPAddress request
	DeleteIPAddress(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindIPAddressById request
	FindIPAddressById(ctx context.Context, id string, params *FindIPAddressByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateIPAddress request
	UpdateIPAddress(ctx context.Context, id string, params *UpdateIPAddressParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindIPAvailabilities request
	FindIPAvailabilities(ctx context.Context, id string, params *FindIPAvailabilitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindIPAddressCustomdata request
	FindIPAddressCustomdata(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLicense request
	DeleteLicense(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindLicenseById request
	FindLicenseById(ctx context.Context, id string, params *FindLicenseByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLicense request with any body
	UpdateLicenseWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLicense(ctx context.Context, id string, body UpdateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindMetros request
	FindMetros(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetro request
	GetMetro(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindSpotMarketPrices request
	FindSpotMarketPrices(ctx context.Context, params *FindSpotMarketPricesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindSpotMarketPricesHistory request
	FindSpotMarketPricesHistory(ctx context.Context, params *FindSpotMarketPricesHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindMetroSpotMarketPrices request
	FindMetroSpotMarketPrices(ctx context.Context, params *FindMetroSpotMarketPricesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMembership request
	DeleteMembership(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindMembershipById request
	FindMembershipById(ctx context.Context, id string, params *FindMembershipByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMembership request with any body
	UpdateMembershipWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMembership(ctx context.Context, id string, body UpdateMembershipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMetalGateway request
	DeleteMetalGateway(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindMetalGatewayById request
	FindMetalGatewayById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindOperatingSystemVersion request
	FindOperatingSystemVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindOperatingSystems request
	FindOperatingSystems(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindOrganizations request
	FindOrganizations(ctx context.Context, params *FindOrganizationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrganization request with any body
	CreateOrganizationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrganization(ctx context.Context, body CreateOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrganization request
	DeleteOrganization(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindOrganizationById request
	FindOrganizationById(ctx context.Context, id string, params *FindOrganizationByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOrganization request with any body
	UpdateOrganizationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOrganization(ctx context.Context, id string, body UpdateOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindOrganizationCapacityPerFacility request
	FindOrganizationCapacityPerFacility(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindOrganizationCapacityPerMetro request
	FindOrganizationCapacityPerMetro(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindOrganizationCustomdata request
	FindOrganizationCustomdata(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindOrganizationDevices request
	FindOrganizationDevices(ctx context.Context, id string, params *FindOrganizationDevicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindOrganizationEvents request
	FindOrganizationEvents(ctx context.Context, id string, params *FindOrganizationEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindFacilitiesByOrganization request
	FindFacilitiesByOrganization(ctx context.Context, id string, params *FindFacilitiesByOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindOrganizationInvitations request
	FindOrganizationInvitations(ctx context.Context, id string, params *FindOrganizationInvitationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrganizationInvitation request with any body
	CreateOrganizationInvitationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrganizationInvitation(ctx context.Context, id string, body CreateOrganizationInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindOperatingSystemsByOrganization request
	FindOperatingSystemsByOrganization(ctx context.Context, id string, params *FindOperatingSystemsByOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindOrganizationPaymentMethods request
	FindOrganizationPaymentMethods(ctx context.Context, id string, params *FindOrganizationPaymentMethodsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePaymentMethod request with any body
	CreatePaymentMethodWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePaymentMethod(ctx context.Context, id string, body CreatePaymentMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindPlansByOrganization request
	FindPlansByOrganization(ctx context.Context, id string, params *FindPlansByOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindOrganizationProjects request
	FindOrganizationProjects(ctx context.Context, id string, params *FindOrganizationProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrganizationProject request with any body
	CreateOrganizationProjectWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrganizationProject(ctx context.Context, id string, body CreateOrganizationProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindOrganizationTransfers request
	FindOrganizationTransfers(ctx context.Context, id string, params *FindOrganizationTransfersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrganizationListInterconnections request
	OrganizationListInterconnections(ctx context.Context, organizationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrganizationInterconnection request with any body
	CreateOrganizationInterconnectionWithBody(ctx context.Context, organizationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrganizationInterconnection(ctx context.Context, organizationId string, body CreateOrganizationInterconnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePaymentMethod request
	DeletePaymentMethod(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindPaymentMethodById request
	FindPaymentMethodById(ctx context.Context, id string, params *FindPaymentMethodByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePaymentMethod request with any body
	UpdatePaymentMethodWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePaymentMethod(ctx context.Context, id string, body UpdatePaymentMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindPlans request
	FindPlans(ctx context.Context, params *FindPlansParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindPortById request
	FindPortById(ctx context.Context, id string, params *FindPortByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignPort request with any body
	AssignPortWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssignPort(ctx context.Context, id string, body AssignPortJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BondPort request
	BondPort(ctx context.Context, id string, params *BondPortParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConvertLayer2 request with any body
	ConvertLayer2WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConvertLayer2(ctx context.Context, id string, body ConvertLayer2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConvertLayer3 request with any body
	ConvertLayer3WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConvertLayer3(ctx context.Context, id string, body ConvertLayer3JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisbondPort request
	DisbondPort(ctx context.Context, id string, params *DisbondPortParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNativeVlan request
	DeleteNativeVlan(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignNativeVlan request
	AssignNativeVlan(ctx context.Context, id string, params *AssignNativeVlanParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignPort request with any body
	UnassignPortWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnassignPort(ctx context.Context, id string, body UnassignPortJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindPortVlanAssignments request
	FindPortVlanAssignments(ctx context.Context, id string, params *FindPortVlanAssignmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindPortVlanAssignmentBatches request
	FindPortVlanAssignmentBatches(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePortVlanAssignmentBatch request with any body
	CreatePortVlanAssignmentBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePortVlanAssignmentBatch(ctx context.Context, id string, body CreatePortVlanAssignmentBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindPortVlanAssignmentBatchByPortIdAndBatchId request
	FindPortVlanAssignmentBatchByPortIdAndBatchId(ctx context.Context, id string, batchId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindPortVlanAssignmentByPortIdAndAssignmentId request
	FindPortVlanAssignmentByPortIdAndAssignmentId(ctx context.Context, id string, assignmentId string, params *FindPortVlanAssignmentByPortIdAndAssignmentIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindProjects request
	FindProjects(ctx context.Context, params *FindProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProject request with any body
	CreateProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProject(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProject request
	DeleteProject(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindProjectById request
	FindProjectById(ctx context.Context, id string, params *FindProjectByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProject request with any body
	UpdateProjectWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProject(ctx context.Context, id string, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindProjectAPIKeys request
	FindProjectAPIKeys(ctx context.Context, id string, params *FindProjectAPIKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectAPIKey request with any body
	CreateProjectAPIKeyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProjectAPIKey(ctx context.Context, id string, body CreateProjectAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindBatchesByProject request
	FindBatchesByProject(ctx context.Context, id string, params *FindBatchesByProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindBgpConfigByProject request
	FindBgpConfigByProject(ctx context.Context, id string, params *FindBgpConfigByProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestBgpConfig request with any body
	RequestBgpConfigWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RequestBgpConfig(ctx context.Context, id string, body RequestBgpConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindProjectBgpSessions request
	FindProjectBgpSessions(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindProjectCustomdata request
	FindProjectCustomdata(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindProjectDevices request
	FindProjectDevices(ctx context.Context, id string, params *FindProjectDevicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDevice request with any body
	CreateDeviceWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDevice(ctx context.Context, id string, body CreateDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDeviceBatch request with any body
	CreateDeviceBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDeviceBatch(ctx context.Context, id string, body CreateDeviceBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindProjectEvents request
	FindProjectEvents(ctx context.Context, id string, params *FindProjectEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindFacilitiesByProject request
	FindFacilitiesByProject(ctx context.Context, id string, params *FindFacilitiesByProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindGlobalBgpRanges request
	FindGlobalBgpRanges(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindProjectHardwareReservations request
	FindProjectHardwareReservations(ctx context.Context, id string, params *FindProjectHardwareReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindIPReservations request
	FindIPReservations(ctx context.Context, id string, params *FindIPReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestIPReservation request with any body
	RequestIPReservationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RequestIPReservation(ctx context.Context, id string, body RequestIPReservationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindProjectLicenses request
	FindProjectLicenses(ctx context.Context, id string, params *FindProjectLicensesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLicense request with any body
	CreateLicenseWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLicense(ctx context.Context, id string, body CreateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindPlansByProject request
	FindPlansByProject(ctx context.Context, id string, params *FindPlansByProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSpotMarketRequests request
	ListSpotMarketRequests(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpotMarketRequest request with any body
	CreateSpotMarketRequestWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpotMarketRequest(ctx context.Context, id string, body CreateSpotMarketRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindProjectSSHKeys request
	FindProjectSSHKeys(ctx context.Context, id string, params *FindProjectSSHKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectSSHKey request with any body
	CreateProjectSSHKeyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProjectSSHKey(ctx context.Context, id string, body CreateProjectSSHKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindVolumes request
	FindVolumes(ctx context.Context, id string, params *FindVolumesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVolume request with any body
	CreateVolumeWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVolume(ctx context.Context, id string, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTransferRequest request with any body
	CreateTransferRequestWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTransferRequest(ctx context.Context, id string, body CreateTransferRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindProjectUsage request
	FindProjectUsage(ctx context.Context, id string, params *FindProjectUsageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindVirtualNetworks request
	FindVirtualNetworks(ctx context.Context, id string, params *FindVirtualNetworksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVirtualNetwork request with any body
	CreateVirtualNetworkWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVirtualNetwork(ctx context.Context, id string, body CreateVirtualNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectListInterconnections request
	ProjectListInterconnections(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectInterconnection request with any body
	CreateProjectInterconnectionWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProjectInterconnection(ctx context.Context, projectId string, body CreateProjectInterconnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindProjectInvitations request
	FindProjectInvitations(ctx context.Context, projectId string, params *FindProjectInvitationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectInvitation request with any body
	CreateProjectInvitationWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProjectInvitation(ctx context.Context, projectId string, body CreateProjectInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindIPReservationCustomdata request
	FindIPReservationCustomdata(ctx context.Context, projectId string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindProjectMemberships request
	FindProjectMemberships(ctx context.Context, projectId string, params *FindProjectMembershipsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindMetalGatewaysByProject request
	FindMetalGatewaysByProject(ctx context.Context, projectId string, params *FindMetalGatewaysByProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMetalGateway request with any body
	CreateMetalGatewayWithBody(ctx context.Context, projectId string, params *CreateMetalGatewayParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMetalGateway(ctx context.Context, projectId string, params *CreateMetalGatewayParams, body CreateMetalGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindSelfServiceReservations request
	FindSelfServiceReservations(ctx context.Context, projectId string, params *FindSelfServiceReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSelfServiceReservation request with any body
	CreateSelfServiceReservationWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSelfServiceReservation(ctx context.Context, projectId string, body CreateSelfServiceReservationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindSelfServiceReservation request
	FindSelfServiceReservation(ctx context.Context, projectId string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetPassword request
	ResetPassword(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePasswordResetToken request
	CreatePasswordResetToken(ctx context.Context, params *CreatePasswordResetTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpotMarketRequest request
	DeleteSpotMarketRequest(ctx context.Context, id string, params *DeleteSpotMarketRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindSpotMarketRequestById request
	FindSpotMarketRequestById(ctx context.Context, id string, params *FindSpotMarketRequestByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindSSHKeys request
	FindSSHKeys(ctx context.Context, params *FindSSHKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSSHKey request with any body
	CreateSSHKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSSHKey(ctx context.Context, body CreateSSHKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSSHKey request
	DeleteSSHKey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindSSHKeyById request
	FindSSHKeyById(ctx context.Context, id string, params *FindSSHKeyByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSSHKey request with any body
	UpdateSSHKeyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSSHKey(ctx context.Context, id string, body UpdateSSHKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVolumeAttachment request
	DeleteVolumeAttachment(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindVolumeAttachmentById request
	FindVolumeAttachmentById(ctx context.Context, id string, params *FindVolumeAttachmentByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVolumeSnapshotPolicy request
	DeleteVolumeSnapshotPolicy(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVolumeSnapshotPolicy request
	UpdateVolumeSnapshotPolicy(ctx context.Context, id string, params *UpdateVolumeSnapshotPolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVolume request
	DeleteVolume(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindVolumeById request
	FindVolumeById(ctx context.Context, id string, params *FindVolumeByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVolume request with any body
	UpdateVolumeWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVolume(ctx context.Context, id string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindVolumeAttachments request
	FindVolumeAttachments(ctx context.Context, id string, params *FindVolumeAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVolumeAttachment request with any body
	CreateVolumeAttachmentWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVolumeAttachment(ctx context.Context, id string, body CreateVolumeAttachmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CloneVolume request
	CloneVolume(ctx context.Context, id string, params *CloneVolumeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindVolumeCustomdata request
	FindVolumeCustomdata(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreVolume request
	RestoreVolume(ctx context.Context, id string, params *RestoreVolumeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVolumeSnapshotPolicy request
	CreateVolumeSnapshotPolicy(ctx context.Context, id string, params *CreateVolumeSnapshotPolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindVolumeSnapshots request
	FindVolumeSnapshots(ctx context.Context, id string, params *FindVolumeSnapshotsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVolumeSnapshot request
	DeleteVolumeSnapshot(ctx context.Context, volumeId string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestSuppert request with any body
	RequestSuppertWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RequestSuppert(ctx context.Context, body RequestSuppertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeclineTransferRequest request
	DeclineTransferRequest(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindTransferRequestById request
	FindTransferRequestById(ctx context.Context, id string, params *FindTransferRequestByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcceptTransferRequest request
	AcceptTransferRequest(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindCurrentUser request
	FindCurrentUser(ctx context.Context, params *FindCurrentUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCurrentUser request with any body
	UpdateCurrentUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCurrentUser(ctx context.Context, body UpdateCurrentUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAPIKeys request
	FindAPIKeys(ctx context.Context, params *FindAPIKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAPIKey request with any body
	CreateAPIKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAPIKey(ctx context.Context, body CreateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserAPIKey request
	DeleteUserAPIKey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableTfaApp request
	DisableTfaApp(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableTfaApp request
	EnableTfaApp(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindRecoveryCodes request
	FindRecoveryCodes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegenerateCodes request
	RegenerateCodes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableTfaSms request
	DisableTfaSms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableTfaSms request
	EnableTfaSms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReceiveCodes request
	ReceiveCodes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindEnsureOtp request
	FindEnsureOtp(ctx context.Context, otp string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateUserdata request
	ValidateUserdata(ctx context.Context, params *ValidateUserdataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindUsers request
	FindUsers(ctx context.Context, params *FindUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUser request with any body
	CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindUserById request
	FindUserById(ctx context.Context, id string, params *FindUserByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindUserCustomdata request
	FindUserCustomdata(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateValidationRequest request
	CreateValidationRequest(ctx context.Context, params *CreateValidationRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConsumeVerificationRequest request
	ConsumeVerificationRequest(ctx context.Context, params *ConsumeVerificationRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindVirtualCircuitEvents request
	FindVirtualCircuitEvents(ctx context.Context, id string, params *FindVirtualCircuitEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVirtualCircuit request
	DeleteVirtualCircuit(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVirtualCircuit request
	GetVirtualCircuit(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVirtualCircuit request with any body
	UpdateVirtualCircuitWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVirtualCircuit(ctx context.Context, id string, body UpdateVirtualCircuitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVirtualNetwork request
	DeleteVirtualNetwork(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVirtualNetwork request
	GetVirtualNetwork(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindVolumeEvents request
	FindVolumeEvents(ctx context.Context, id string, params *FindVolumeEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) DeleteAPIKey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAPIKeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBatch(ctx context.Context, id string, params *DeleteBatchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBatchRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindBatchById(ctx context.Context, id string, params *FindBatchByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindBatchByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBgpSession(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBgpSessionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindBgpSessionById(ctx context.Context, id string, params *FindBgpSessionByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindBgpSessionByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBgpSessionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBgpSessionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBgpSession(ctx context.Context, id string, body UpdateBgpSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBgpSessionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindCapacityForFacility(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindCapacityForFacilityRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckCapacityForFacilityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckCapacityForFacilityRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckCapacityForFacility(ctx context.Context, body CheckCapacityForFacilityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckCapacityForFacilityRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindCapacityForMetro(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindCapacityForMetroRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckCapacityForMetroWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckCapacityForMetroRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckCapacityForMetro(ctx context.Context, body CheckCapacityForMetroJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckCapacityForMetroRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInterconnection(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInterconnectionRequest(c.Server, connectionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInterconnection(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInterconnectionRequest(c.Server, connectionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInterconnectionWithBody(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInterconnectionRequestWithBody(c.Server, connectionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInterconnection(ctx context.Context, connectionId string, body UpdateInterconnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInterconnectionRequest(c.Server, connectionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindConnectionEvents(ctx context.Context, connectionId string, params *FindConnectionEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindConnectionEventsRequest(c.Server, connectionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListConnectionPorts(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListConnectionPortsRequest(c.Server, connectionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConnectionPort(ctx context.Context, connectionId string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConnectionPortRequest(c.Server, connectionId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindConnectionPortEvents(ctx context.Context, connectionId string, id string, params *FindConnectionPortEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindConnectionPortEventsRequest(c.Server, connectionId, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListConnectionPortVirtualCircuits(ctx context.Context, connectionId string, portId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListConnectionPortVirtualCircuitsRequest(c.Server, connectionId, portId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConnectionPortVirtualCircuitWithBody(ctx context.Context, connectionId string, portId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConnectionPortVirtualCircuitRequestWithBody(c.Server, connectionId, portId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConnectionPortVirtualCircuit(ctx context.Context, connectionId string, portId string, body CreateConnectionPortVirtualCircuitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConnectionPortVirtualCircuitRequest(c.Server, connectionId, portId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDevice(ctx context.Context, id string, params *DeleteDeviceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDeviceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindDeviceById(ctx context.Context, id string, params *FindDeviceByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindDeviceByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDeviceWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDeviceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDevice(ctx context.Context, id string, body UpdateDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDeviceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PerformAction(ctx context.Context, id string, params *PerformActionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPerformActionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindInstanceBandwidth(ctx context.Context, id string, params *FindInstanceBandwidthParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindInstanceBandwidthRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBgpNeighborData(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBgpNeighborDataRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindBgpSessions(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindBgpSessionsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBgpSessionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBgpSessionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBgpSession(ctx context.Context, id string, body CreateBgpSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBgpSessionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindDeviceCustomdata(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindDeviceCustomdataRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindDeviceEvents(ctx context.Context, id string, params *FindDeviceEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindDeviceEventsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindIPAssignments(ctx context.Context, id string, params *FindIPAssignmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindIPAssignmentsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIPAssignmentWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIPAssignmentRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIPAssignment(ctx context.Context, id string, body CreateIPAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIPAssignmentRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindDeviceSSHKeys(ctx context.Context, id string, params *FindDeviceSSHKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindDeviceSSHKeysRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindTrafficWithBody(ctx context.Context, id string, params *FindTrafficParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindTrafficRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindTraffic(ctx context.Context, id string, params *FindTrafficParams, body FindTrafficJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindTrafficRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindDeviceUsages(ctx context.Context, id string, params *FindDeviceUsagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindDeviceUsagesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindIPAssignmentCustomdata(ctx context.Context, instanceId string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindIPAssignmentCustomdataRequest(c.Server, instanceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEmailRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEmail(ctx context.Context, body CreateEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEmailRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEmail(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEmailRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindEmailById(ctx context.Context, id string, params *FindEmailByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindEmailByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEmailWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEmailRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEmail(ctx context.Context, id string, body UpdateEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEmailRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindEvents(ctx context.Context, params *FindEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindEventById(ctx context.Context, id string, params *FindEventByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindEventByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindFacilities(ctx context.Context, params *FindFacilitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindFacilitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindHardwareReservationById(ctx context.Context, id string, params *FindHardwareReservationByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindHardwareReservationByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MoveHardwareReservationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMoveHardwareReservationRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MoveHardwareReservation(ctx context.Context, id string, body MoveHardwareReservationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMoveHardwareReservationRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindIncidents(ctx context.Context, params *FindIncidentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindIncidentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindInvitations(ctx context.Context, params *FindInvitationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindInvitationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeclineInvitation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeclineInvitationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindInvitationById(ctx context.Context, id string, params *FindInvitationByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindInvitationByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptInvitation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptInvitationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIPAddress(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIPAddressRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindIPAddressById(ctx context.Context, id string, params *FindIPAddressByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindIPAddressByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIPAddress(ctx context.Context, id string, params *UpdateIPAddressParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIPAddressRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindIPAvailabilities(ctx context.Context, id string, params *FindIPAvailabilitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindIPAvailabilitiesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindIPAddressCustomdata(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindIPAddressCustomdataRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLicense(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLicenseRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindLicenseById(ctx context.Context, id string, params *FindLicenseByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindLicenseByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLicenseWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLicenseRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLicense(ctx context.Context, id string, body UpdateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLicenseRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindMetros(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindMetrosRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetro(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetroRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindSpotMarketPrices(ctx context.Context, params *FindSpotMarketPricesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindSpotMarketPricesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindSpotMarketPricesHistory(ctx context.Context, params *FindSpotMarketPricesHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindSpotMarketPricesHistoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindMetroSpotMarketPrices(ctx context.Context, params *FindMetroSpotMarketPricesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindMetroSpotMarketPricesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMembership(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMembershipRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindMembershipById(ctx context.Context, id string, params *FindMembershipByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindMembershipByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMembershipWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMembershipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMembership(ctx context.Context, id string, body UpdateMembershipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMembershipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMetalGateway(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMetalGatewayRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindMetalGatewayById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindMetalGatewayByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOperatingSystemVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOperatingSystemVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOperatingSystems(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOperatingSystemsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOrganizations(ctx context.Context, params *FindOrganizationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOrganizationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrganizationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrganizationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrganization(ctx context.Context, body CreateOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrganizationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrganization(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrganizationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOrganizationById(ctx context.Context, id string, params *FindOrganizationByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOrganizationByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrganizationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrganizationRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrganization(ctx context.Context, id string, body UpdateOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrganizationRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOrganizationCapacityPerFacility(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOrganizationCapacityPerFacilityRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOrganizationCapacityPerMetro(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOrganizationCapacityPerMetroRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOrganizationCustomdata(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOrganizationCustomdataRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOrganizationDevices(ctx context.Context, id string, params *FindOrganizationDevicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOrganizationDevicesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOrganizationEvents(ctx context.Context, id string, params *FindOrganizationEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOrganizationEventsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindFacilitiesByOrganization(ctx context.Context, id string, params *FindFacilitiesByOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindFacilitiesByOrganizationRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOrganizationInvitations(ctx context.Context, id string, params *FindOrganizationInvitationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOrganizationInvitationsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrganizationInvitationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrganizationInvitationRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrganizationInvitation(ctx context.Context, id string, body CreateOrganizationInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrganizationInvitationRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOperatingSystemsByOrganization(ctx context.Context, id string, params *FindOperatingSystemsByOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOperatingSystemsByOrganizationRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOrganizationPaymentMethods(ctx context.Context, id string, params *FindOrganizationPaymentMethodsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOrganizationPaymentMethodsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePaymentMethodWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePaymentMethodRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePaymentMethod(ctx context.Context, id string, body CreatePaymentMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePaymentMethodRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindPlansByOrganization(ctx context.Context, id string, params *FindPlansByOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindPlansByOrganizationRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOrganizationProjects(ctx context.Context, id string, params *FindOrganizationProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOrganizationProjectsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrganizationProjectWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrganizationProjectRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrganizationProject(ctx context.Context, id string, body CreateOrganizationProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrganizationProjectRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindOrganizationTransfers(ctx context.Context, id string, params *FindOrganizationTransfersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindOrganizationTransfersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrganizationListInterconnections(ctx context.Context, organizationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrganizationListInterconnectionsRequest(c.Server, organizationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrganizationInterconnectionWithBody(ctx context.Context, organizationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrganizationInterconnectionRequestWithBody(c.Server, organizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrganizationInterconnection(ctx context.Context, organizationId string, body CreateOrganizationInterconnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrganizationInterconnectionRequest(c.Server, organizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePaymentMethod(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePaymentMethodRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindPaymentMethodById(ctx context.Context, id string, params *FindPaymentMethodByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindPaymentMethodByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePaymentMethodWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePaymentMethodRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePaymentMethod(ctx context.Context, id string, body UpdatePaymentMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePaymentMethodRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindPlans(ctx context.Context, params *FindPlansParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindPlansRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindPortById(ctx context.Context, id string, params *FindPortByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindPortByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignPortWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignPortRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignPort(ctx context.Context, id string, body AssignPortJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignPortRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BondPort(ctx context.Context, id string, params *BondPortParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBondPortRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConvertLayer2WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConvertLayer2RequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConvertLayer2(ctx context.Context, id string, body ConvertLayer2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConvertLayer2Request(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConvertLayer3WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConvertLayer3RequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConvertLayer3(ctx context.Context, id string, body ConvertLayer3JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConvertLayer3Request(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisbondPort(ctx context.Context, id string, params *DisbondPortParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisbondPortRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNativeVlan(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNativeVlanRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignNativeVlan(ctx context.Context, id string, params *AssignNativeVlanParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignNativeVlanRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignPortWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignPortRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignPort(ctx context.Context, id string, body UnassignPortJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignPortRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindPortVlanAssignments(ctx context.Context, id string, params *FindPortVlanAssignmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindPortVlanAssignmentsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindPortVlanAssignmentBatches(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindPortVlanAssignmentBatchesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePortVlanAssignmentBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePortVlanAssignmentBatchRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePortVlanAssignmentBatch(ctx context.Context, id string, body CreatePortVlanAssignmentBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePortVlanAssignmentBatchRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindPortVlanAssignmentBatchByPortIdAndBatchId(ctx context.Context, id string, batchId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindPortVlanAssignmentBatchByPortIdAndBatchIdRequest(c.Server, id, batchId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindPortVlanAssignmentByPortIdAndAssignmentId(ctx context.Context, id string, assignmentId string, params *FindPortVlanAssignmentByPortIdAndAssignmentIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindPortVlanAssignmentByPortIdAndAssignmentIdRequest(c.Server, id, assignmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindProjects(ctx context.Context, params *FindProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindProjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProject(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProject(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindProjectById(ctx context.Context, id string, params *FindProjectByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindProjectByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProject(ctx context.Context, id string, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindProjectAPIKeys(ctx context.Context, id string, params *FindProjectAPIKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindProjectAPIKeysRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectAPIKeyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectAPIKeyRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectAPIKey(ctx context.Context, id string, body CreateProjectAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectAPIKeyRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindBatchesByProject(ctx context.Context, id string, params *FindBatchesByProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindBatchesByProjectRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindBgpConfigByProject(ctx context.Context, id string, params *FindBgpConfigByProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindBgpConfigByProjectRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestBgpConfigWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestBgpConfigRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestBgpConfig(ctx context.Context, id string, body RequestBgpConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestBgpConfigRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindProjectBgpSessions(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindProjectBgpSessionsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindProjectCustomdata(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindProjectCustomdataRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindProjectDevices(ctx context.Context, id string, params *FindProjectDevicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindProjectDevicesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDeviceWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeviceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDevice(ctx context.Context, id string, body CreateDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeviceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDeviceBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeviceBatchRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDeviceBatch(ctx context.Context, id string, body CreateDeviceBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeviceBatchRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindProjectEvents(ctx context.Context, id string, params *FindProjectEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindProjectEventsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindFacilitiesByProject(ctx context.Context, id string, params *FindFacilitiesByProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindFacilitiesByProjectRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindGlobalBgpRanges(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindGlobalBgpRangesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindProjectHardwareReservations(ctx context.Context, id string, params *FindProjectHardwareReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindProjectHardwareReservationsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindIPReservations(ctx context.Context, id string, params *FindIPReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindIPReservationsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestIPReservationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestIPReservationRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestIPReservation(ctx context.Context, id string, body RequestIPReservationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestIPReservationRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindProjectLicenses(ctx context.Context, id string, params *FindProjectLicensesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindProjectLicensesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLicenseWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLicenseRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLicense(ctx context.Context, id string, body CreateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLicenseRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindPlansByProject(ctx context.Context, id string, params *FindPlansByProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindPlansByProjectRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSpotMarketRequests(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSpotMarketRequestsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpotMarketRequestWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpotMarketRequestRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpotMarketRequest(ctx context.Context, id string, body CreateSpotMarketRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpotMarketRequestRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindProjectSSHKeys(ctx context.Context, id string, params *FindProjectSSHKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindProjectSSHKeysRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectSSHKeyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectSSHKeyRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectSSHKey(ctx context.Context, id string, body CreateProjectSSHKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectSSHKeyRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindVolumes(ctx context.Context, id string, params *FindVolumesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindVolumesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolumeWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolume(ctx context.Context, id string, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTransferRequestWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTransferRequestRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTransferRequest(ctx context.Context, id string, body CreateTransferRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTransferRequestRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindProjectUsage(ctx context.Context, id string, params *FindProjectUsageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindProjectUsageRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindVirtualNetworks(ctx context.Context, id string, params *FindVirtualNetworksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindVirtualNetworksRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualNetworkWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualNetworkRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualNetwork(ctx context.Context, id string, body CreateVirtualNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualNetworkRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectListInterconnections(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectListInterconnectionsRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectInterconnectionWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectInterconnectionRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectInterconnection(ctx context.Context, projectId string, body CreateProjectInterconnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectInterconnectionRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindProjectInvitations(ctx context.Context, projectId string, params *FindProjectInvitationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindProjectInvitationsRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectInvitationWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectInvitationRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectInvitation(ctx context.Context, projectId string, body CreateProjectInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectInvitationRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindIPReservationCustomdata(ctx context.Context, projectId string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindIPReservationCustomdataRequest(c.Server, projectId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindProjectMemberships(ctx context.Context, projectId string, params *FindProjectMembershipsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindProjectMembershipsRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindMetalGatewaysByProject(ctx context.Context, projectId string, params *FindMetalGatewaysByProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindMetalGatewaysByProjectRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMetalGatewayWithBody(ctx context.Context, projectId string, params *CreateMetalGatewayParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMetalGatewayRequestWithBody(c.Server, projectId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMetalGateway(ctx context.Context, projectId string, params *CreateMetalGatewayParams, body CreateMetalGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMetalGatewayRequest(c.Server, projectId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindSelfServiceReservations(ctx context.Context, projectId string, params *FindSelfServiceReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindSelfServiceReservationsRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSelfServiceReservationWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSelfServiceReservationRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSelfServiceReservation(ctx context.Context, projectId string, body CreateSelfServiceReservationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSelfServiceReservationRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindSelfServiceReservation(ctx context.Context, projectId string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindSelfServiceReservationRequest(c.Server, projectId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPassword(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePasswordResetToken(ctx context.Context, params *CreatePasswordResetTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePasswordResetTokenRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpotMarketRequest(ctx context.Context, id string, params *DeleteSpotMarketRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpotMarketRequestRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindSpotMarketRequestById(ctx context.Context, id string, params *FindSpotMarketRequestByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindSpotMarketRequestByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindSSHKeys(ctx context.Context, params *FindSSHKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindSSHKeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSSHKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSSHKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSSHKey(ctx context.Context, body CreateSSHKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSSHKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSSHKey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSSHKeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindSSHKeyById(ctx context.Context, id string, params *FindSSHKeyByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindSSHKeyByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSSHKeyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSSHKeyRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSSHKey(ctx context.Context, id string, body UpdateSSHKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSSHKeyRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVolumeAttachment(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVolumeAttachmentRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindVolumeAttachmentById(ctx context.Context, id string, params *FindVolumeAttachmentByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindVolumeAttachmentByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVolumeSnapshotPolicy(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVolumeSnapshotPolicyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolumeSnapshotPolicy(ctx context.Context, id string, params *UpdateVolumeSnapshotPolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeSnapshotPolicyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVolume(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVolumeRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindVolumeById(ctx context.Context, id string, params *FindVolumeByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindVolumeByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolumeWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolume(ctx context.Context, id string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindVolumeAttachments(ctx context.Context, id string, params *FindVolumeAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindVolumeAttachmentsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolumeAttachmentWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeAttachmentRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolumeAttachment(ctx context.Context, id string, body CreateVolumeAttachmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeAttachmentRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloneVolume(ctx context.Context, id string, params *CloneVolumeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloneVolumeRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindVolumeCustomdata(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindVolumeCustomdataRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreVolume(ctx context.Context, id string, params *RestoreVolumeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreVolumeRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolumeSnapshotPolicy(ctx context.Context, id string, params *CreateVolumeSnapshotPolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeSnapshotPolicyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindVolumeSnapshots(ctx context.Context, id string, params *FindVolumeSnapshotsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindVolumeSnapshotsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVolumeSnapshot(ctx context.Context, volumeId string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVolumeSnapshotRequest(c.Server, volumeId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestSuppertWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestSuppertRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestSuppert(ctx context.Context, body RequestSuppertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestSuppertRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeclineTransferRequest(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeclineTransferRequestRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindTransferRequestById(ctx context.Context, id string, params *FindTransferRequestByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindTransferRequestByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptTransferRequest(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptTransferRequestRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindCurrentUser(ctx context.Context, params *FindCurrentUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindCurrentUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCurrentUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCurrentUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCurrentUser(ctx context.Context, body UpdateCurrentUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCurrentUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAPIKeys(ctx context.Context, params *FindAPIKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAPIKeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAPIKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAPIKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAPIKey(ctx context.Context, body CreateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAPIKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserAPIKey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserAPIKeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableTfaApp(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableTfaAppRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableTfaApp(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableTfaAppRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindRecoveryCodes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindRecoveryCodesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegenerateCodes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegenerateCodesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableTfaSms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableTfaSmsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableTfaSms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableTfaSmsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReceiveCodes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReceiveCodesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindEnsureOtp(ctx context.Context, otp string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindEnsureOtpRequest(c.Server, otp)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateUserdata(ctx context.Context, params *ValidateUserdataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateUserdataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindUsers(ctx context.Context, params *FindUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindUserById(ctx context.Context, id string, params *FindUserByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindUserByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindUserCustomdata(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindUserCustomdataRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateValidationRequest(ctx context.Context, params *CreateValidationRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateValidationRequestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConsumeVerificationRequest(ctx context.Context, params *ConsumeVerificationRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConsumeVerificationRequestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindVirtualCircuitEvents(ctx context.Context, id string, params *FindVirtualCircuitEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindVirtualCircuitEventsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVirtualCircuit(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVirtualCircuitRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVirtualCircuit(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVirtualCircuitRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVirtualCircuitWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVirtualCircuitRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVirtualCircuit(ctx context.Context, id string, body UpdateVirtualCircuitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVirtualCircuitRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVirtualNetwork(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVirtualNetworkRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVirtualNetwork(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVirtualNetworkRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindVolumeEvents(ctx context.Context, id string, params *FindVolumeEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindVolumeEventsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDeleteAPIKeyRequest generates requests for DeleteAPIKey
func NewDeleteAPIKeyRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBatchRequest generates requests for DeleteBatch
func NewDeleteBatchRequest(server string, id string, params *DeleteBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.RemoveAssociatedInstances != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remove_associated_instances", runtime.ParamLocationQuery, *params.RemoveAssociatedInstances); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindBatchByIdRequest generates requests for FindBatchById
func NewFindBatchByIdRequest(server string, id string, params *FindBatchByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBgpSessionRequest generates requests for DeleteBgpSession
func NewDeleteBgpSessionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bgp/sessions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindBgpSessionByIdRequest generates requests for FindBgpSessionById
func NewFindBgpSessionByIdRequest(server string, id string, params *FindBgpSessionByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bgp/sessions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBgpSessionRequest calls the generic UpdateBgpSession builder with application/json body
func NewUpdateBgpSessionRequest(server string, id string, body UpdateBgpSessionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBgpSessionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateBgpSessionRequestWithBody generates requests for UpdateBgpSession with any type of body
func NewUpdateBgpSessionRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bgp/sessions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindCapacityForFacilityRequest generates requests for FindCapacityForFacility
func NewFindCapacityForFacilityRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/capacity")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckCapacityForFacilityRequest calls the generic CheckCapacityForFacility builder with application/json body
func NewCheckCapacityForFacilityRequest(server string, body CheckCapacityForFacilityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCheckCapacityForFacilityRequestWithBody(server, "application/json", bodyReader)
}

// NewCheckCapacityForFacilityRequestWithBody generates requests for CheckCapacityForFacility with any type of body
func NewCheckCapacityForFacilityRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/capacity")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindCapacityForMetroRequest generates requests for FindCapacityForMetro
func NewFindCapacityForMetroRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/capacity/metros")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckCapacityForMetroRequest calls the generic CheckCapacityForMetro builder with application/json body
func NewCheckCapacityForMetroRequest(server string, body CheckCapacityForMetroJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCheckCapacityForMetroRequestWithBody(server, "application/json", bodyReader)
}

// NewCheckCapacityForMetroRequestWithBody generates requests for CheckCapacityForMetro with any type of body
func NewCheckCapacityForMetroRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/capacity/metros")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteInterconnectionRequest generates requests for DeleteInterconnection
func NewDeleteInterconnectionRequest(server string, connectionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connection_id", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInterconnectionRequest generates requests for GetInterconnection
func NewGetInterconnectionRequest(server string, connectionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connection_id", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateInterconnectionRequest calls the generic UpdateInterconnection builder with application/json body
func NewUpdateInterconnectionRequest(server string, connectionId string, body UpdateInterconnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateInterconnectionRequestWithBody(server, connectionId, "application/json", bodyReader)
}

// NewUpdateInterconnectionRequestWithBody generates requests for UpdateInterconnection with any type of body
func NewUpdateInterconnectionRequestWithBody(server string, connectionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connection_id", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindConnectionEventsRequest generates requests for FindConnectionEvents
func NewFindConnectionEventsRequest(server string, connectionId string, params *FindConnectionEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connection_id", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connections/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListConnectionPortsRequest generates requests for ListConnectionPorts
func NewListConnectionPortsRequest(server string, connectionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connection_id", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connections/%s/ports", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConnectionPortRequest generates requests for GetConnectionPort
func NewGetConnectionPortRequest(server string, connectionId string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connection_id", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connections/%s/ports/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindConnectionPortEventsRequest generates requests for FindConnectionPortEvents
func NewFindConnectionPortEventsRequest(server string, connectionId string, id string, params *FindConnectionPortEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connection_id", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connections/%s/ports/%s/events", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListConnectionPortVirtualCircuitsRequest generates requests for ListConnectionPortVirtualCircuits
func NewListConnectionPortVirtualCircuitsRequest(server string, connectionId string, portId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connection_id", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "port_id", runtime.ParamLocationPath, portId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connections/%s/ports/%s/virtual-circuits", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateConnectionPortVirtualCircuitRequest calls the generic CreateConnectionPortVirtualCircuit builder with application/json body
func NewCreateConnectionPortVirtualCircuitRequest(server string, connectionId string, portId string, body CreateConnectionPortVirtualCircuitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateConnectionPortVirtualCircuitRequestWithBody(server, connectionId, portId, "application/json", bodyReader)
}

// NewCreateConnectionPortVirtualCircuitRequestWithBody generates requests for CreateConnectionPortVirtualCircuit with any type of body
func NewCreateConnectionPortVirtualCircuitRequestWithBody(server string, connectionId string, portId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connection_id", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "port_id", runtime.ParamLocationPath, portId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connections/%s/ports/%s/virtual-circuits", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDeviceRequest generates requests for DeleteDevice
func NewDeleteDeviceRequest(server string, id string, params *DeleteDeviceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ForceDelete != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_delete", runtime.ParamLocationQuery, *params.ForceDelete); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindDeviceByIdRequest generates requests for FindDeviceById
func NewFindDeviceByIdRequest(server string, id string, params *FindDeviceByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDeviceRequest calls the generic UpdateDevice builder with application/json body
func NewUpdateDeviceRequest(server string, id string, body UpdateDeviceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDeviceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateDeviceRequestWithBody generates requests for UpdateDevice with any type of body
func NewUpdateDeviceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPerformActionRequest generates requests for PerformAction
func NewPerformActionRequest(server string, id string, params *PerformActionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices/%s/actions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindInstanceBandwidthRequest generates requests for FindInstanceBandwidth
func NewFindInstanceBandwidthRequest(server string, id string, params *FindInstanceBandwidthParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices/%s/bandwidth", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, params.Until); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBgpNeighborDataRequest generates requests for GetBgpNeighborData
func NewGetBgpNeighborDataRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices/%s/bgp/neighbors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindBgpSessionsRequest generates requests for FindBgpSessions
func NewFindBgpSessionsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices/%s/bgp/sessions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBgpSessionRequest calls the generic CreateBgpSession builder with application/json body
func NewCreateBgpSessionRequest(server string, id string, body CreateBgpSessionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBgpSessionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateBgpSessionRequestWithBody generates requests for CreateBgpSession with any type of body
func NewCreateBgpSessionRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices/%s/bgp/sessions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindDeviceCustomdataRequest generates requests for FindDeviceCustomdata
func NewFindDeviceCustomdataRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices/%s/customdata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindDeviceEventsRequest generates requests for FindDeviceEvents
func NewFindDeviceEventsRequest(server string, id string, params *FindDeviceEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindIPAssignmentsRequest generates requests for FindIPAssignments
func NewFindIPAssignmentsRequest(server string, id string, params *FindIPAssignmentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices/%s/ips", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIPAssignmentRequest calls the generic CreateIPAssignment builder with application/json body
func NewCreateIPAssignmentRequest(server string, id string, body CreateIPAssignmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIPAssignmentRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateIPAssignmentRequestWithBody generates requests for CreateIPAssignment with any type of body
func NewCreateIPAssignmentRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices/%s/ips", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindDeviceSSHKeysRequest generates requests for FindDeviceSSHKeys
func NewFindDeviceSSHKeysRequest(server string, id string, params *FindDeviceSSHKeysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices/%s/ssh-keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.SearchString != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Search string", runtime.ParamLocationQuery, *params.SearchString); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindTrafficRequest calls the generic FindTraffic builder with application/json body
func NewFindTrafficRequest(server string, id string, params *FindTrafficParams, body FindTrafficJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindTrafficRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewFindTrafficRequestWithBody generates requests for FindTraffic with any type of body
func NewFindTrafficRequestWithBody(server string, id string, params *FindTrafficParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices/%s/traffic", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, params.Direction); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Interval != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval", runtime.ParamLocationQuery, *params.Interval); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Bucket != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bucket", runtime.ParamLocationQuery, *params.Bucket); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindDeviceUsagesRequest generates requests for FindDeviceUsages
func NewFindDeviceUsagesRequest(server string, id string, params *FindDeviceUsagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices/%s/usages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.CreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created[after]", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreatedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created[before]", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindIPAssignmentCustomdataRequest generates requests for FindIPAssignmentCustomdata
func NewFindIPAssignmentCustomdataRequest(server string, instanceId string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "instance_id", runtime.ParamLocationPath, instanceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices/%s/ips/%s/customdata", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEmailRequest calls the generic CreateEmail builder with application/json body
func NewCreateEmailRequest(server string, body CreateEmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEmailRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateEmailRequestWithBody generates requests for CreateEmail with any type of body
func NewCreateEmailRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/emails")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEmailRequest generates requests for DeleteEmail
func NewDeleteEmailRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/emails/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindEmailByIdRequest generates requests for FindEmailById
func NewFindEmailByIdRequest(server string, id string, params *FindEmailByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/emails/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEmailRequest calls the generic UpdateEmail builder with application/json body
func NewUpdateEmailRequest(server string, id string, body UpdateEmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEmailRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateEmailRequestWithBody generates requests for UpdateEmail with any type of body
func NewUpdateEmailRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/emails/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindEventsRequest generates requests for FindEvents
func NewFindEventsRequest(server string, params *FindEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindEventByIdRequest generates requests for FindEventById
func NewFindEventByIdRequest(server string, id string, params *FindEventByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindFacilitiesRequest generates requests for FindFacilities
func NewFindFacilitiesRequest(server string, params *FindFacilitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/facilities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindHardwareReservationByIdRequest generates requests for FindHardwareReservationById
func NewFindHardwareReservationByIdRequest(server string, id string, params *FindHardwareReservationByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hardware-reservations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMoveHardwareReservationRequest calls the generic MoveHardwareReservation builder with application/json body
func NewMoveHardwareReservationRequest(server string, id string, body MoveHardwareReservationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMoveHardwareReservationRequestWithBody(server, id, "application/json", bodyReader)
}

// NewMoveHardwareReservationRequestWithBody generates requests for MoveHardwareReservation with any type of body
func NewMoveHardwareReservationRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hardware-reservations/%s/move", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindIncidentsRequest generates requests for FindIncidents
func NewFindIncidentsRequest(server string, params *FindIncidentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/incidents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindInvitationsRequest generates requests for FindInvitations
func NewFindInvitationsRequest(server string, params *FindInvitationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/invitations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeclineInvitationRequest generates requests for DeclineInvitation
func NewDeclineInvitationRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/invitations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindInvitationByIdRequest generates requests for FindInvitationById
func NewFindInvitationByIdRequest(server string, id string, params *FindInvitationByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/invitations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAcceptInvitationRequest generates requests for AcceptInvitation
func NewAcceptInvitationRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/invitations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteIPAddressRequest generates requests for DeleteIPAddress
func NewDeleteIPAddressRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ips/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindIPAddressByIdRequest generates requests for FindIPAddressById
func NewFindIPAddressByIdRequest(server string, id string, params *FindIPAddressByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ips/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateIPAddressRequest generates requests for UpdateIPAddress
func NewUpdateIPAddressRequest(server string, id string, params *UpdateIPAddressParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ips/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "details", runtime.ParamLocationQuery, params.Details); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customdata", runtime.ParamLocationQuery, params.Customdata); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindIPAvailabilitiesRequest generates requests for FindIPAvailabilities
func NewFindIPAvailabilitiesRequest(server string, id string, params *FindIPAvailabilitiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ips/%s/available", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cidr", runtime.ParamLocationQuery, params.Cidr); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindIPAddressCustomdataRequest generates requests for FindIPAddressCustomdata
func NewFindIPAddressCustomdataRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ips/%s/customdata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteLicenseRequest generates requests for DeleteLicense
func NewDeleteLicenseRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/licenses/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindLicenseByIdRequest generates requests for FindLicenseById
func NewFindLicenseByIdRequest(server string, id string, params *FindLicenseByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/licenses/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLicenseRequest calls the generic UpdateLicense builder with application/json body
func NewUpdateLicenseRequest(server string, id string, body UpdateLicenseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLicenseRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateLicenseRequestWithBody generates requests for UpdateLicense with any type of body
func NewUpdateLicenseRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/licenses/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindMetrosRequest generates requests for FindMetros
func NewFindMetrosRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations/metros")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMetroRequest generates requests for GetMetro
func NewGetMetroRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations/metros/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindSpotMarketPricesRequest generates requests for FindSpotMarketPrices
func NewFindSpotMarketPricesRequest(server string, params *FindSpotMarketPricesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/market/spot/prices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Facility != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "facility", runtime.ParamLocationQuery, *params.Facility); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Plan != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "plan", runtime.ParamLocationQuery, *params.Plan); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindSpotMarketPricesHistoryRequest generates requests for FindSpotMarketPricesHistory
func NewFindSpotMarketPricesHistoryRequest(server string, params *FindSpotMarketPricesHistoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/market/spot/prices/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "facility", runtime.ParamLocationQuery, params.Facility); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "plan", runtime.ParamLocationQuery, params.Plan); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Metro != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metro", runtime.ParamLocationQuery, *params.Metro); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, params.Until); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindMetroSpotMarketPricesRequest generates requests for FindMetroSpotMarketPrices
func NewFindMetroSpotMarketPricesRequest(server string, params *FindMetroSpotMarketPricesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/market/spot/prices/metros")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Metro != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metro", runtime.ParamLocationQuery, *params.Metro); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Plan != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "plan", runtime.ParamLocationQuery, *params.Plan); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteMembershipRequest generates requests for DeleteMembership
func NewDeleteMembershipRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/memberships/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindMembershipByIdRequest generates requests for FindMembershipById
func NewFindMembershipByIdRequest(server string, id string, params *FindMembershipByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/memberships/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMembershipRequest calls the generic UpdateMembership builder with application/json body
func NewUpdateMembershipRequest(server string, id string, body UpdateMembershipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMembershipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateMembershipRequestWithBody generates requests for UpdateMembership with any type of body
func NewUpdateMembershipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/memberships/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMetalGatewayRequest generates requests for DeleteMetalGateway
func NewDeleteMetalGatewayRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metal-gateways/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindMetalGatewayByIdRequest generates requests for FindMetalGatewayById
func NewFindMetalGatewayByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metal-gateways/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOperatingSystemVersionRequest generates requests for FindOperatingSystemVersion
func NewFindOperatingSystemVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/operating-system-versions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOperatingSystemsRequest generates requests for FindOperatingSystems
func NewFindOperatingSystemsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/operating-systems")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOrganizationsRequest generates requests for FindOrganizations
func NewFindOrganizationsRequest(server string, params *FindOrganizationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Personal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personal", runtime.ParamLocationQuery, *params.Personal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.WithoutProjects != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "without_projects", runtime.ParamLocationQuery, *params.WithoutProjects); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrganizationRequest calls the generic CreateOrganization builder with application/json body
func NewCreateOrganizationRequest(server string, body CreateOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrganizationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateOrganizationRequestWithBody generates requests for CreateOrganization with any type of body
func NewCreateOrganizationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOrganizationRequest generates requests for DeleteOrganization
func NewDeleteOrganizationRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOrganizationByIdRequest generates requests for FindOrganizationById
func NewFindOrganizationByIdRequest(server string, id string, params *FindOrganizationByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOrganizationRequest calls the generic UpdateOrganization builder with application/json body
func NewUpdateOrganizationRequest(server string, id string, body UpdateOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOrganizationRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateOrganizationRequestWithBody generates requests for UpdateOrganization with any type of body
func NewUpdateOrganizationRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindOrganizationCapacityPerFacilityRequest generates requests for FindOrganizationCapacityPerFacility
func NewFindOrganizationCapacityPerFacilityRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/capacity", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOrganizationCapacityPerMetroRequest generates requests for FindOrganizationCapacityPerMetro
func NewFindOrganizationCapacityPerMetroRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/capacity/metros", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOrganizationCustomdataRequest generates requests for FindOrganizationCustomdata
func NewFindOrganizationCustomdataRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/customdata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOrganizationDevicesRequest generates requests for FindOrganizationDevices
func NewFindOrganizationDevicesRequest(server string, id string, params *FindOrganizationDevicesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/devices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOrganizationEventsRequest generates requests for FindOrganizationEvents
func NewFindOrganizationEventsRequest(server string, id string, params *FindOrganizationEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindFacilitiesByOrganizationRequest generates requests for FindFacilitiesByOrganization
func NewFindFacilitiesByOrganizationRequest(server string, id string, params *FindFacilitiesByOrganizationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/facilities", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOrganizationInvitationsRequest generates requests for FindOrganizationInvitations
func NewFindOrganizationInvitationsRequest(server string, id string, params *FindOrganizationInvitationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/invitations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrganizationInvitationRequest calls the generic CreateOrganizationInvitation builder with application/json body
func NewCreateOrganizationInvitationRequest(server string, id string, body CreateOrganizationInvitationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrganizationInvitationRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateOrganizationInvitationRequestWithBody generates requests for CreateOrganizationInvitation with any type of body
func NewCreateOrganizationInvitationRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/invitations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindOperatingSystemsByOrganizationRequest generates requests for FindOperatingSystemsByOrganization
func NewFindOperatingSystemsByOrganizationRequest(server string, id string, params *FindOperatingSystemsByOrganizationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/operating-systems", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOrganizationPaymentMethodsRequest generates requests for FindOrganizationPaymentMethods
func NewFindOrganizationPaymentMethodsRequest(server string, id string, params *FindOrganizationPaymentMethodsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/payment-methods", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePaymentMethodRequest calls the generic CreatePaymentMethod builder with application/json body
func NewCreatePaymentMethodRequest(server string, id string, body CreatePaymentMethodJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePaymentMethodRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreatePaymentMethodRequestWithBody generates requests for CreatePaymentMethod with any type of body
func NewCreatePaymentMethodRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/payment-methods", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindPlansByOrganizationRequest generates requests for FindPlansByOrganization
func NewFindPlansByOrganizationRequest(server string, id string, params *FindPlansByOrganizationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/plans", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindOrganizationProjectsRequest generates requests for FindOrganizationProjects
func NewFindOrganizationProjectsRequest(server string, id string, params *FindOrganizationProjectsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/projects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrganizationProjectRequest calls the generic CreateOrganizationProject builder with application/json body
func NewCreateOrganizationProjectRequest(server string, id string, body CreateOrganizationProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrganizationProjectRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateOrganizationProjectRequestWithBody generates requests for CreateOrganizationProject with any type of body
func NewCreateOrganizationProjectRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/projects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindOrganizationTransfersRequest generates requests for FindOrganizationTransfers
func NewFindOrganizationTransfersRequest(server string, id string, params *FindOrganizationTransfersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/transfers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrganizationListInterconnectionsRequest generates requests for OrganizationListInterconnections
func NewOrganizationListInterconnectionsRequest(server string, organizationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/connections", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrganizationInterconnectionRequest calls the generic CreateOrganizationInterconnection builder with application/json body
func NewCreateOrganizationInterconnectionRequest(server string, organizationId string, body CreateOrganizationInterconnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrganizationInterconnectionRequestWithBody(server, organizationId, "application/json", bodyReader)
}

// NewCreateOrganizationInterconnectionRequestWithBody generates requests for CreateOrganizationInterconnection with any type of body
func NewCreateOrganizationInterconnectionRequestWithBody(server string, organizationId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/connections", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePaymentMethodRequest generates requests for DeletePaymentMethod
func NewDeletePaymentMethodRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-methods/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindPaymentMethodByIdRequest generates requests for FindPaymentMethodById
func NewFindPaymentMethodByIdRequest(server string, id string, params *FindPaymentMethodByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-methods/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePaymentMethodRequest calls the generic UpdatePaymentMethod builder with application/json body
func NewUpdatePaymentMethodRequest(server string, id string, body UpdatePaymentMethodJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePaymentMethodRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdatePaymentMethodRequestWithBody generates requests for UpdatePaymentMethod with any type of body
func NewUpdatePaymentMethodRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-methods/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindPlansRequest generates requests for FindPlans
func NewFindPlansRequest(server string, params *FindPlansParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindPortByIdRequest generates requests for FindPortById
func NewFindPortByIdRequest(server string, id string, params *FindPortByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignPortRequest calls the generic AssignPort builder with application/json body
func NewAssignPortRequest(server string, id string, body AssignPortJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssignPortRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAssignPortRequestWithBody generates requests for AssignPort with any type of body
func NewAssignPortRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ports/%s/assign", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBondPortRequest generates requests for BondPort
func NewBondPortRequest(server string, id string, params *BondPortParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ports/%s/bond", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.BulkEnable != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bulk_enable", runtime.ParamLocationQuery, *params.BulkEnable); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConvertLayer2Request calls the generic ConvertLayer2 builder with application/json body
func NewConvertLayer2Request(server string, id string, body ConvertLayer2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConvertLayer2RequestWithBody(server, id, "application/json", bodyReader)
}

// NewConvertLayer2RequestWithBody generates requests for ConvertLayer2 with any type of body
func NewConvertLayer2RequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ports/%s/convert/layer-2", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConvertLayer3Request calls the generic ConvertLayer3 builder with application/json body
func NewConvertLayer3Request(server string, id string, body ConvertLayer3JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConvertLayer3RequestWithBody(server, id, "application/json", bodyReader)
}

// NewConvertLayer3RequestWithBody generates requests for ConvertLayer3 with any type of body
func NewConvertLayer3RequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ports/%s/convert/layer-3", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDisbondPortRequest generates requests for DisbondPort
func NewDisbondPortRequest(server string, id string, params *DisbondPortParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ports/%s/disbond", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.BulkDisable != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bulk_disable", runtime.ParamLocationQuery, *params.BulkDisable); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteNativeVlanRequest generates requests for DeleteNativeVlan
func NewDeleteNativeVlanRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ports/%s/native-vlan", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignNativeVlanRequest generates requests for AssignNativeVlan
func NewAssignNativeVlanRequest(server string, id string, params *AssignNativeVlanParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ports/%s/native-vlan", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vnid", runtime.ParamLocationQuery, params.Vnid); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnassignPortRequest calls the generic UnassignPort builder with application/json body
func NewUnassignPortRequest(server string, id string, body UnassignPortJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnassignPortRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUnassignPortRequestWithBody generates requests for UnassignPort with any type of body
func NewUnassignPortRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ports/%s/unassign", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindPortVlanAssignmentsRequest generates requests for FindPortVlanAssignments
func NewFindPortVlanAssignmentsRequest(server string, id string, params *FindPortVlanAssignmentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ports/%s/vlan-assignments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindPortVlanAssignmentBatchesRequest generates requests for FindPortVlanAssignmentBatches
func NewFindPortVlanAssignmentBatchesRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ports/%s/vlan-assignments/batches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePortVlanAssignmentBatchRequest calls the generic CreatePortVlanAssignmentBatch builder with application/json body
func NewCreatePortVlanAssignmentBatchRequest(server string, id string, body CreatePortVlanAssignmentBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePortVlanAssignmentBatchRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreatePortVlanAssignmentBatchRequestWithBody generates requests for CreatePortVlanAssignmentBatch with any type of body
func NewCreatePortVlanAssignmentBatchRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ports/%s/vlan-assignments/batches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindPortVlanAssignmentBatchByPortIdAndBatchIdRequest generates requests for FindPortVlanAssignmentBatchByPortIdAndBatchId
func NewFindPortVlanAssignmentBatchByPortIdAndBatchIdRequest(server string, id string, batchId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batch_id", runtime.ParamLocationPath, batchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ports/%s/vlan-assignments/batches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindPortVlanAssignmentByPortIdAndAssignmentIdRequest generates requests for FindPortVlanAssignmentByPortIdAndAssignmentId
func NewFindPortVlanAssignmentByPortIdAndAssignmentIdRequest(server string, id string, assignmentId string, params *FindPortVlanAssignmentByPortIdAndAssignmentIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "assignment_id", runtime.ParamLocationPath, assignmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ports/%s/vlan-assignments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindProjectsRequest generates requests for FindProjects
func NewFindProjectsRequest(server string, params *FindProjectsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectRequest calls the generic CreateProject builder with application/json body
func NewCreateProjectRequest(server string, body CreateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateProjectRequestWithBody generates requests for CreateProject with any type of body
func NewCreateProjectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectRequest generates requests for DeleteProject
func NewDeleteProjectRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindProjectByIdRequest generates requests for FindProjectById
func NewFindProjectByIdRequest(server string, id string, params *FindProjectByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectRequest calls the generic UpdateProject builder with application/json body
func NewUpdateProjectRequest(server string, id string, body UpdateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateProjectRequestWithBody generates requests for UpdateProject with any type of body
func NewUpdateProjectRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindProjectAPIKeysRequest generates requests for FindProjectAPIKeys
func NewFindProjectAPIKeysRequest(server string, id string, params *FindProjectAPIKeysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/api-keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectAPIKeyRequest calls the generic CreateProjectAPIKey builder with application/json body
func NewCreateProjectAPIKeyRequest(server string, id string, body CreateProjectAPIKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectAPIKeyRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateProjectAPIKeyRequestWithBody generates requests for CreateProjectAPIKey with any type of body
func NewCreateProjectAPIKeyRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/api-keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindBatchesByProjectRequest generates requests for FindBatchesByProject
func NewFindBatchesByProjectRequest(server string, id string, params *FindBatchesByProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/batches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindBgpConfigByProjectRequest generates requests for FindBgpConfigByProject
func NewFindBgpConfigByProjectRequest(server string, id string, params *FindBgpConfigByProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/bgp-config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRequestBgpConfigRequest calls the generic RequestBgpConfig builder with application/json body
func NewRequestBgpConfigRequest(server string, id string, body RequestBgpConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRequestBgpConfigRequestWithBody(server, id, "application/json", bodyReader)
}

// NewRequestBgpConfigRequestWithBody generates requests for RequestBgpConfig with any type of body
func NewRequestBgpConfigRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/bgp-configs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindProjectBgpSessionsRequest generates requests for FindProjectBgpSessions
func NewFindProjectBgpSessionsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/bgp/sessions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindProjectCustomdataRequest generates requests for FindProjectCustomdata
func NewFindProjectCustomdataRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/customdata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindProjectDevicesRequest generates requests for FindProjectDevices
func NewFindProjectDevicesRequest(server string, id string, params *FindProjectDevicesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/devices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDeviceRequest calls the generic CreateDevice builder with application/json body
func NewCreateDeviceRequest(server string, id string, body CreateDeviceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDeviceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateDeviceRequestWithBody generates requests for CreateDevice with any type of body
func NewCreateDeviceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/devices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDeviceBatchRequest calls the generic CreateDeviceBatch builder with application/json body
func NewCreateDeviceBatchRequest(server string, id string, body CreateDeviceBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDeviceBatchRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateDeviceBatchRequestWithBody generates requests for CreateDeviceBatch with any type of body
func NewCreateDeviceBatchRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/devices/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindProjectEventsRequest generates requests for FindProjectEvents
func NewFindProjectEventsRequest(server string, id string, params *FindProjectEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindFacilitiesByProjectRequest generates requests for FindFacilitiesByProject
func NewFindFacilitiesByProjectRequest(server string, id string, params *FindFacilitiesByProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/facilities", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindGlobalBgpRangesRequest generates requests for FindGlobalBgpRanges
func NewFindGlobalBgpRangesRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/global-bgp-ranges", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindProjectHardwareReservationsRequest generates requests for FindProjectHardwareReservations
func NewFindProjectHardwareReservationsRequest(server string, id string, params *FindProjectHardwareReservationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/hardware-reservations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindIPReservationsRequest generates requests for FindIPReservations
func NewFindIPReservationsRequest(server string, id string, params *FindIPReservationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/ips", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRequestIPReservationRequest calls the generic RequestIPReservation builder with application/json body
func NewRequestIPReservationRequest(server string, id string, body RequestIPReservationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRequestIPReservationRequestWithBody(server, id, "application/json", bodyReader)
}

// NewRequestIPReservationRequestWithBody generates requests for RequestIPReservation with any type of body
func NewRequestIPReservationRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/ips", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindProjectLicensesRequest generates requests for FindProjectLicenses
func NewFindProjectLicensesRequest(server string, id string, params *FindProjectLicensesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/licenses", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLicenseRequest calls the generic CreateLicense builder with application/json body
func NewCreateLicenseRequest(server string, id string, body CreateLicenseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLicenseRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateLicenseRequestWithBody generates requests for CreateLicense with any type of body
func NewCreateLicenseRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/licenses", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindPlansByProjectRequest generates requests for FindPlansByProject
func NewFindPlansByProjectRequest(server string, id string, params *FindPlansByProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/plans", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSpotMarketRequestsRequest generates requests for ListSpotMarketRequests
func NewListSpotMarketRequestsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/spot-market-requests", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSpotMarketRequestRequest calls the generic CreateSpotMarketRequest builder with application/json body
func NewCreateSpotMarketRequestRequest(server string, id string, body CreateSpotMarketRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpotMarketRequestRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateSpotMarketRequestRequestWithBody generates requests for CreateSpotMarketRequest with any type of body
func NewCreateSpotMarketRequestRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/spot-market-requests", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindProjectSSHKeysRequest generates requests for FindProjectSSHKeys
func NewFindProjectSSHKeysRequest(server string, id string, params *FindProjectSSHKeysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/ssh-keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.SearchString != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Search string", runtime.ParamLocationQuery, *params.SearchString); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectSSHKeyRequest calls the generic CreateProjectSSHKey builder with application/json body
func NewCreateProjectSSHKeyRequest(server string, id string, body CreateProjectSSHKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectSSHKeyRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateProjectSSHKeyRequestWithBody generates requests for CreateProjectSSHKey with any type of body
func NewCreateProjectSSHKeyRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/ssh-keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindVolumesRequest generates requests for FindVolumes
func NewFindVolumesRequest(server string, id string, params *FindVolumesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/storage", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVolumeRequest calls the generic CreateVolume builder with application/json body
func NewCreateVolumeRequest(server string, id string, body CreateVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVolumeRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateVolumeRequestWithBody generates requests for CreateVolume with any type of body
func NewCreateVolumeRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/storage", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateTransferRequestRequest calls the generic CreateTransferRequest builder with application/json body
func NewCreateTransferRequestRequest(server string, id string, body CreateTransferRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTransferRequestRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateTransferRequestRequestWithBody generates requests for CreateTransferRequest with any type of body
func NewCreateTransferRequestRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/transfers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindProjectUsageRequest generates requests for FindProjectUsage
func NewFindProjectUsageRequest(server string, id string, params *FindProjectUsageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/usages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.CreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created[after]", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreatedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created[before]", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindVirtualNetworksRequest generates requests for FindVirtualNetworks
func NewFindVirtualNetworksRequest(server string, id string, params *FindVirtualNetworksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/virtual-networks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Facility != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "facility", runtime.ParamLocationQuery, *params.Facility); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Metro != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metro", runtime.ParamLocationQuery, *params.Metro); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVirtualNetworkRequest calls the generic CreateVirtualNetwork builder with application/json body
func NewCreateVirtualNetworkRequest(server string, id string, body CreateVirtualNetworkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVirtualNetworkRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateVirtualNetworkRequestWithBody generates requests for CreateVirtualNetwork with any type of body
func NewCreateVirtualNetworkRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/virtual-networks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProjectListInterconnectionsRequest generates requests for ProjectListInterconnections
func NewProjectListInterconnectionsRequest(server string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/connections", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectInterconnectionRequest calls the generic CreateProjectInterconnection builder with application/json body
func NewCreateProjectInterconnectionRequest(server string, projectId string, body CreateProjectInterconnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectInterconnectionRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewCreateProjectInterconnectionRequestWithBody generates requests for CreateProjectInterconnection with any type of body
func NewCreateProjectInterconnectionRequestWithBody(server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/connections", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindProjectInvitationsRequest generates requests for FindProjectInvitations
func NewFindProjectInvitationsRequest(server string, projectId string, params *FindProjectInvitationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/invitations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectInvitationRequest calls the generic CreateProjectInvitation builder with application/json body
func NewCreateProjectInvitationRequest(server string, projectId string, body CreateProjectInvitationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectInvitationRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewCreateProjectInvitationRequestWithBody generates requests for CreateProjectInvitation with any type of body
func NewCreateProjectInvitationRequestWithBody(server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/invitations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindIPReservationCustomdataRequest generates requests for FindIPReservationCustomdata
func NewFindIPReservationCustomdataRequest(server string, projectId string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/ips/%s/customdata", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindProjectMembershipsRequest generates requests for FindProjectMemberships
func NewFindProjectMembershipsRequest(server string, projectId string, params *FindProjectMembershipsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/memberships", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindMetalGatewaysByProjectRequest generates requests for FindMetalGatewaysByProject
func NewFindMetalGatewaysByProjectRequest(server string, projectId string, params *FindMetalGatewaysByProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/metal-gateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMetalGatewayRequest calls the generic CreateMetalGateway builder with application/json body
func NewCreateMetalGatewayRequest(server string, projectId string, params *CreateMetalGatewayParams, body CreateMetalGatewayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMetalGatewayRequestWithBody(server, projectId, params, "application/json", bodyReader)
}

// NewCreateMetalGatewayRequestWithBody generates requests for CreateMetalGateway with any type of body
func NewCreateMetalGatewayRequestWithBody(server string, projectId string, params *CreateMetalGatewayParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/metal-gateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindSelfServiceReservationsRequest generates requests for FindSelfServiceReservations
func NewFindSelfServiceReservationsRequest(server string, projectId string, params *FindSelfServiceReservationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/self-service/reservations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSelfServiceReservationRequest calls the generic CreateSelfServiceReservation builder with application/json body
func NewCreateSelfServiceReservationRequest(server string, projectId string, body CreateSelfServiceReservationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSelfServiceReservationRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewCreateSelfServiceReservationRequestWithBody generates requests for CreateSelfServiceReservation with any type of body
func NewCreateSelfServiceReservationRequestWithBody(server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/self-service/reservations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindSelfServiceReservationRequest generates requests for FindSelfServiceReservation
func NewFindSelfServiceReservationRequest(server string, projectId string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/self-service/reservations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetPasswordRequest generates requests for ResetPassword
func NewResetPasswordRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reset-password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePasswordResetTokenRequest generates requests for CreatePasswordResetToken
func NewCreatePasswordResetTokenRequest(server string, params *CreatePasswordResetTokenParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reset-password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, params.Email); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSpotMarketRequestRequest generates requests for DeleteSpotMarketRequest
func NewDeleteSpotMarketRequestRequest(server string, id string, params *DeleteSpotMarketRequestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spot-market-requests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ForceTermination != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_termination", runtime.ParamLocationQuery, *params.ForceTermination); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindSpotMarketRequestByIdRequest generates requests for FindSpotMarketRequestById
func NewFindSpotMarketRequestByIdRequest(server string, id string, params *FindSpotMarketRequestByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spot-market-requests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindSSHKeysRequest generates requests for FindSSHKeys
func NewFindSSHKeysRequest(server string, params *FindSSHKeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ssh-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.SearchString != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Search string", runtime.ParamLocationQuery, *params.SearchString); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSSHKeyRequest calls the generic CreateSSHKey builder with application/json body
func NewCreateSSHKeyRequest(server string, body CreateSSHKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSSHKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSSHKeyRequestWithBody generates requests for CreateSSHKey with any type of body
func NewCreateSSHKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ssh-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSSHKeyRequest generates requests for DeleteSSHKey
func NewDeleteSSHKeyRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ssh-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindSSHKeyByIdRequest generates requests for FindSSHKeyById
func NewFindSSHKeyByIdRequest(server string, id string, params *FindSSHKeyByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ssh-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSSHKeyRequest calls the generic UpdateSSHKey builder with application/json body
func NewUpdateSSHKeyRequest(server string, id string, body UpdateSSHKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSSHKeyRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateSSHKeyRequestWithBody generates requests for UpdateSSHKey with any type of body
func NewUpdateSSHKeyRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ssh-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVolumeAttachmentRequest generates requests for DeleteVolumeAttachment
func NewDeleteVolumeAttachmentRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage/attachments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindVolumeAttachmentByIdRequest generates requests for FindVolumeAttachmentById
func NewFindVolumeAttachmentByIdRequest(server string, id string, params *FindVolumeAttachmentByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage/attachments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteVolumeSnapshotPolicyRequest generates requests for DeleteVolumeSnapshotPolicy
func NewDeleteVolumeSnapshotPolicyRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage/snapshot-policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVolumeSnapshotPolicyRequest generates requests for UpdateVolumeSnapshotPolicy
func NewUpdateVolumeSnapshotPolicyRequest(server string, id string, params *UpdateVolumeSnapshotPolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage/snapshot-policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.SnapshotCount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "snapshot_count", runtime.ParamLocationQuery, *params.SnapshotCount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "snapshot_frequency", runtime.ParamLocationQuery, params.SnapshotFrequency); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteVolumeRequest generates requests for DeleteVolume
func NewDeleteVolumeRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindVolumeByIdRequest generates requests for FindVolumeById
func NewFindVolumeByIdRequest(server string, id string, params *FindVolumeByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVolumeRequest calls the generic UpdateVolume builder with application/json body
func NewUpdateVolumeRequest(server string, id string, body UpdateVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVolumeRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateVolumeRequestWithBody generates requests for UpdateVolume with any type of body
func NewUpdateVolumeRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindVolumeAttachmentsRequest generates requests for FindVolumeAttachments
func NewFindVolumeAttachmentsRequest(server string, id string, params *FindVolumeAttachmentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage/%s/attachments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVolumeAttachmentRequest calls the generic CreateVolumeAttachment builder with application/json body
func NewCreateVolumeAttachmentRequest(server string, id string, body CreateVolumeAttachmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVolumeAttachmentRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateVolumeAttachmentRequestWithBody generates requests for CreateVolumeAttachment with any type of body
func NewCreateVolumeAttachmentRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage/%s/attachments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCloneVolumeRequest generates requests for CloneVolume
func NewCloneVolumeRequest(server string, id string, params *CloneVolumeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage/%s/clone", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.SnapshotTimestamp != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "snapshot_timestamp", runtime.ParamLocationQuery, *params.SnapshotTimestamp); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindVolumeCustomdataRequest generates requests for FindVolumeCustomdata
func NewFindVolumeCustomdataRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage/%s/customdata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreVolumeRequest generates requests for RestoreVolume
func NewRestoreVolumeRequest(server string, id string, params *RestoreVolumeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "restore_point", runtime.ParamLocationQuery, params.RestorePoint); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVolumeSnapshotPolicyRequest generates requests for CreateVolumeSnapshotPolicy
func NewCreateVolumeSnapshotPolicyRequest(server string, id string, params *CreateVolumeSnapshotPolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage/%s/snapshot-policies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.SnapshotCount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "snapshot_count", runtime.ParamLocationQuery, *params.SnapshotCount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "snapshot_frequency", runtime.ParamLocationQuery, params.SnapshotFrequency); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindVolumeSnapshotsRequest generates requests for FindVolumeSnapshots
func NewFindVolumeSnapshotsRequest(server string, id string, params *FindVolumeSnapshotsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage/%s/snapshots", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteVolumeSnapshotRequest generates requests for DeleteVolumeSnapshot
func NewDeleteVolumeSnapshotRequest(server string, volumeId string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "volume_id", runtime.ParamLocationPath, volumeId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage/%s/snapshots/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRequestSuppertRequest calls the generic RequestSuppert builder with application/json body
func NewRequestSuppertRequest(server string, body RequestSuppertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRequestSuppertRequestWithBody(server, "application/json", bodyReader)
}

// NewRequestSuppertRequestWithBody generates requests for RequestSuppert with any type of body
func NewRequestSuppertRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/support-requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeclineTransferRequestRequest generates requests for DeclineTransferRequest
func NewDeclineTransferRequestRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transfers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindTransferRequestByIdRequest generates requests for FindTransferRequestById
func NewFindTransferRequestByIdRequest(server string, id string, params *FindTransferRequestByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transfers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAcceptTransferRequestRequest generates requests for AcceptTransferRequest
func NewAcceptTransferRequestRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transfers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindCurrentUserRequest generates requests for FindCurrentUser
func NewFindCurrentUserRequest(server string, params *FindCurrentUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCurrentUserRequest calls the generic UpdateCurrentUser builder with application/json body
func NewUpdateCurrentUserRequest(server string, body UpdateCurrentUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCurrentUserRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateCurrentUserRequestWithBody generates requests for UpdateCurrentUser with any type of body
func NewUpdateCurrentUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAPIKeysRequest generates requests for FindAPIKeys
func NewFindAPIKeysRequest(server string, params *FindAPIKeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/api-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAPIKeyRequest calls the generic CreateAPIKey builder with application/json body
func NewCreateAPIKeyRequest(server string, body CreateAPIKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAPIKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAPIKeyRequestWithBody generates requests for CreateAPIKey with any type of body
func NewCreateAPIKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/api-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserAPIKeyRequest generates requests for DeleteUserAPIKey
func NewDeleteUserAPIKeyRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/api-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDisableTfaAppRequest generates requests for DisableTfaApp
func NewDisableTfaAppRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/otp/app")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnableTfaAppRequest generates requests for EnableTfaApp
func NewEnableTfaAppRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/otp/app")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindRecoveryCodesRequest generates requests for FindRecoveryCodes
func NewFindRecoveryCodesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/otp/recovery-codes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegenerateCodesRequest generates requests for RegenerateCodes
func NewRegenerateCodesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/otp/recovery-codes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDisableTfaSmsRequest generates requests for DisableTfaSms
func NewDisableTfaSmsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/otp/sms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnableTfaSmsRequest generates requests for EnableTfaSms
func NewEnableTfaSmsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/otp/sms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReceiveCodesRequest generates requests for ReceiveCodes
func NewReceiveCodesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/otp/sms/receive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindEnsureOtpRequest generates requests for FindEnsureOtp
func NewFindEnsureOtpRequest(server string, otp string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "otp", runtime.ParamLocationPath, otp)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/otp/verify/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateUserdataRequest generates requests for ValidateUserdata
func NewValidateUserdataRequest(server string, params *ValidateUserdataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/userdata/validate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Userdata != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userdata", runtime.ParamLocationQuery, *params.Userdata); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindUsersRequest generates requests for FindUsers
func NewFindUsersRequest(server string, params *FindUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindUserByIdRequest generates requests for FindUserById
func NewFindUserByIdRequest(server string, id string, params *FindUserByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindUserCustomdataRequest generates requests for FindUserCustomdata
func NewFindUserCustomdataRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/customdata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateValidationRequestRequest generates requests for CreateValidationRequest
func NewCreateValidationRequestRequest(server string, params *CreateValidationRequestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/verify-email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "login", runtime.ParamLocationQuery, params.Login); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConsumeVerificationRequestRequest generates requests for ConsumeVerificationRequest
func NewConsumeVerificationRequestRequest(server string, params *ConsumeVerificationRequestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/verify-email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, params.Token); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindVirtualCircuitEventsRequest generates requests for FindVirtualCircuitEvents
func NewFindVirtualCircuitEventsRequest(server string, id string, params *FindVirtualCircuitEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virtual-circuit/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteVirtualCircuitRequest generates requests for DeleteVirtualCircuit
func NewDeleteVirtualCircuitRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virtual-circuits/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVirtualCircuitRequest generates requests for GetVirtualCircuit
func NewGetVirtualCircuitRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virtual-circuits/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVirtualCircuitRequest calls the generic UpdateVirtualCircuit builder with application/json body
func NewUpdateVirtualCircuitRequest(server string, id string, body UpdateVirtualCircuitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVirtualCircuitRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateVirtualCircuitRequestWithBody generates requests for UpdateVirtualCircuit with any type of body
func NewUpdateVirtualCircuitRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virtual-circuits/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVirtualNetworkRequest generates requests for DeleteVirtualNetwork
func NewDeleteVirtualNetworkRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virtual-networks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVirtualNetworkRequest generates requests for GetVirtualNetwork
func NewGetVirtualNetworkRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virtual-networks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindVolumeEventsRequest generates requests for FindVolumeEvents
func NewFindVolumeEventsRequest(server string, id string, params *FindVolumeEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DeleteAPIKey request
	DeleteAPIKeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAPIKeyResponse, error)

	// DeleteBatch request
	DeleteBatchWithResponse(ctx context.Context, id string, params *DeleteBatchParams, reqEditors ...RequestEditorFn) (*DeleteBatchResponse, error)

	// FindBatchById request
	FindBatchByIdWithResponse(ctx context.Context, id string, params *FindBatchByIdParams, reqEditors ...RequestEditorFn) (*FindBatchByIdResponse, error)

	// DeleteBgpSession request
	DeleteBgpSessionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteBgpSessionResponse, error)

	// FindBgpSessionById request
	FindBgpSessionByIdWithResponse(ctx context.Context, id string, params *FindBgpSessionByIdParams, reqEditors ...RequestEditorFn) (*FindBgpSessionByIdResponse, error)

	// UpdateBgpSession request with any body
	UpdateBgpSessionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBgpSessionResponse, error)

	UpdateBgpSessionWithResponse(ctx context.Context, id string, body UpdateBgpSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBgpSessionResponse, error)

	// FindCapacityForFacility request
	FindCapacityForFacilityWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindCapacityForFacilityResponse, error)

	// CheckCapacityForFacility request with any body
	CheckCapacityForFacilityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckCapacityForFacilityResponse, error)

	CheckCapacityForFacilityWithResponse(ctx context.Context, body CheckCapacityForFacilityJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckCapacityForFacilityResponse, error)

	// FindCapacityForMetro request
	FindCapacityForMetroWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindCapacityForMetroResponse, error)

	// CheckCapacityForMetro request with any body
	CheckCapacityForMetroWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckCapacityForMetroResponse, error)

	CheckCapacityForMetroWithResponse(ctx context.Context, body CheckCapacityForMetroJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckCapacityForMetroResponse, error)

	// DeleteInterconnection request
	DeleteInterconnectionWithResponse(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*DeleteInterconnectionResponse, error)

	// GetInterconnection request
	GetInterconnectionWithResponse(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*GetInterconnectionResponse, error)

	// UpdateInterconnection request with any body
	UpdateInterconnectionWithBodyWithResponse(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInterconnectionResponse, error)

	UpdateInterconnectionWithResponse(ctx context.Context, connectionId string, body UpdateInterconnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInterconnectionResponse, error)

	// FindConnectionEvents request
	FindConnectionEventsWithResponse(ctx context.Context, connectionId string, params *FindConnectionEventsParams, reqEditors ...RequestEditorFn) (*FindConnectionEventsResponse, error)

	// ListConnectionPorts request
	ListConnectionPortsWithResponse(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*ListConnectionPortsResponse, error)

	// GetConnectionPort request
	GetConnectionPortWithResponse(ctx context.Context, connectionId string, id string, reqEditors ...RequestEditorFn) (*GetConnectionPortResponse, error)

	// FindConnectionPortEvents request
	FindConnectionPortEventsWithResponse(ctx context.Context, connectionId string, id string, params *FindConnectionPortEventsParams, reqEditors ...RequestEditorFn) (*FindConnectionPortEventsResponse, error)

	// ListConnectionPortVirtualCircuits request
	ListConnectionPortVirtualCircuitsWithResponse(ctx context.Context, connectionId string, portId string, reqEditors ...RequestEditorFn) (*ListConnectionPortVirtualCircuitsResponse, error)

	// CreateConnectionPortVirtualCircuit request with any body
	CreateConnectionPortVirtualCircuitWithBodyWithResponse(ctx context.Context, connectionId string, portId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConnectionPortVirtualCircuitResponse, error)

	CreateConnectionPortVirtualCircuitWithResponse(ctx context.Context, connectionId string, portId string, body CreateConnectionPortVirtualCircuitJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConnectionPortVirtualCircuitResponse, error)

	// DeleteDevice request
	DeleteDeviceWithResponse(ctx context.Context, id string, params *DeleteDeviceParams, reqEditors ...RequestEditorFn) (*DeleteDeviceResponse, error)

	// FindDeviceById request
	FindDeviceByIdWithResponse(ctx context.Context, id string, params *FindDeviceByIdParams, reqEditors ...RequestEditorFn) (*FindDeviceByIdResponse, error)

	// UpdateDevice request with any body
	UpdateDeviceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDeviceResponse, error)

	UpdateDeviceWithResponse(ctx context.Context, id string, body UpdateDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDeviceResponse, error)

	// PerformAction request
	PerformActionWithResponse(ctx context.Context, id string, params *PerformActionParams, reqEditors ...RequestEditorFn) (*PerformActionResponse, error)

	// FindInstanceBandwidth request
	FindInstanceBandwidthWithResponse(ctx context.Context, id string, params *FindInstanceBandwidthParams, reqEditors ...RequestEditorFn) (*FindInstanceBandwidthResponse, error)

	// GetBgpNeighborData request
	GetBgpNeighborDataWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetBgpNeighborDataResponse, error)

	// FindBgpSessions request
	FindBgpSessionsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindBgpSessionsResponse, error)

	// CreateBgpSession request with any body
	CreateBgpSessionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBgpSessionResponse, error)

	CreateBgpSessionWithResponse(ctx context.Context, id string, body CreateBgpSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBgpSessionResponse, error)

	// FindDeviceCustomdata request
	FindDeviceCustomdataWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindDeviceCustomdataResponse, error)

	// FindDeviceEvents request
	FindDeviceEventsWithResponse(ctx context.Context, id string, params *FindDeviceEventsParams, reqEditors ...RequestEditorFn) (*FindDeviceEventsResponse, error)

	// FindIPAssignments request
	FindIPAssignmentsWithResponse(ctx context.Context, id string, params *FindIPAssignmentsParams, reqEditors ...RequestEditorFn) (*FindIPAssignmentsResponse, error)

	// CreateIPAssignment request with any body
	CreateIPAssignmentWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIPAssignmentResponse, error)

	CreateIPAssignmentWithResponse(ctx context.Context, id string, body CreateIPAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIPAssignmentResponse, error)

	// FindDeviceSSHKeys request
	FindDeviceSSHKeysWithResponse(ctx context.Context, id string, params *FindDeviceSSHKeysParams, reqEditors ...RequestEditorFn) (*FindDeviceSSHKeysResponse, error)

	// FindTraffic request with any body
	FindTrafficWithBodyWithResponse(ctx context.Context, id string, params *FindTrafficParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindTrafficResponse, error)

	FindTrafficWithResponse(ctx context.Context, id string, params *FindTrafficParams, body FindTrafficJSONRequestBody, reqEditors ...RequestEditorFn) (*FindTrafficResponse, error)

	// FindDeviceUsages request
	FindDeviceUsagesWithResponse(ctx context.Context, id string, params *FindDeviceUsagesParams, reqEditors ...RequestEditorFn) (*FindDeviceUsagesResponse, error)

	// FindIPAssignmentCustomdata request
	FindIPAssignmentCustomdataWithResponse(ctx context.Context, instanceId string, id string, reqEditors ...RequestEditorFn) (*FindIPAssignmentCustomdataResponse, error)

	// CreateEmail request with any body
	CreateEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEmailResponse, error)

	CreateEmailWithResponse(ctx context.Context, body CreateEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEmailResponse, error)

	// DeleteEmail request
	DeleteEmailWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteEmailResponse, error)

	// FindEmailById request
	FindEmailByIdWithResponse(ctx context.Context, id string, params *FindEmailByIdParams, reqEditors ...RequestEditorFn) (*FindEmailByIdResponse, error)

	// UpdateEmail request with any body
	UpdateEmailWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEmailResponse, error)

	UpdateEmailWithResponse(ctx context.Context, id string, body UpdateEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEmailResponse, error)

	// FindEvents request
	FindEventsWithResponse(ctx context.Context, params *FindEventsParams, reqEditors ...RequestEditorFn) (*FindEventsResponse, error)

	// FindEventById request
	FindEventByIdWithResponse(ctx context.Context, id string, params *FindEventByIdParams, reqEditors ...RequestEditorFn) (*FindEventByIdResponse, error)

	// FindFacilities request
	FindFacilitiesWithResponse(ctx context.Context, params *FindFacilitiesParams, reqEditors ...RequestEditorFn) (*FindFacilitiesResponse, error)

	// FindHardwareReservationById request
	FindHardwareReservationByIdWithResponse(ctx context.Context, id string, params *FindHardwareReservationByIdParams, reqEditors ...RequestEditorFn) (*FindHardwareReservationByIdResponse, error)

	// MoveHardwareReservation request with any body
	MoveHardwareReservationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MoveHardwareReservationResponse, error)

	MoveHardwareReservationWithResponse(ctx context.Context, id string, body MoveHardwareReservationJSONRequestBody, reqEditors ...RequestEditorFn) (*MoveHardwareReservationResponse, error)

	// FindIncidents request
	FindIncidentsWithResponse(ctx context.Context, params *FindIncidentsParams, reqEditors ...RequestEditorFn) (*FindIncidentsResponse, error)

	// FindInvitations request
	FindInvitationsWithResponse(ctx context.Context, params *FindInvitationsParams, reqEditors ...RequestEditorFn) (*FindInvitationsResponse, error)

	// DeclineInvitation request
	DeclineInvitationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeclineInvitationResponse, error)

	// FindInvitationById request
	FindInvitationByIdWithResponse(ctx context.Context, id string, params *FindInvitationByIdParams, reqEditors ...RequestEditorFn) (*FindInvitationByIdResponse, error)

	// AcceptInvitation request
	AcceptInvitationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*AcceptInvitationResponse, error)

	// DeleteIPAddress request
	DeleteIPAddressWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteIPAddressResponse, error)

	// FindIPAddressById request
	FindIPAddressByIdWithResponse(ctx context.Context, id string, params *FindIPAddressByIdParams, reqEditors ...RequestEditorFn) (*FindIPAddressByIdResponse, error)

	// UpdateIPAddress request
	UpdateIPAddressWithResponse(ctx context.Context, id string, params *UpdateIPAddressParams, reqEditors ...RequestEditorFn) (*UpdateIPAddressResponse, error)

	// FindIPAvailabilities request
	FindIPAvailabilitiesWithResponse(ctx context.Context, id string, params *FindIPAvailabilitiesParams, reqEditors ...RequestEditorFn) (*FindIPAvailabilitiesResponse, error)

	// FindIPAddressCustomdata request
	FindIPAddressCustomdataWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindIPAddressCustomdataResponse, error)

	// DeleteLicense request
	DeleteLicenseWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLicenseResponse, error)

	// FindLicenseById request
	FindLicenseByIdWithResponse(ctx context.Context, id string, params *FindLicenseByIdParams, reqEditors ...RequestEditorFn) (*FindLicenseByIdResponse, error)

	// UpdateLicense request with any body
	UpdateLicenseWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLicenseResponse, error)

	UpdateLicenseWithResponse(ctx context.Context, id string, body UpdateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLicenseResponse, error)

	// FindMetros request
	FindMetrosWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindMetrosResponse, error)

	// GetMetro request
	GetMetroWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetMetroResponse, error)

	// FindSpotMarketPrices request
	FindSpotMarketPricesWithResponse(ctx context.Context, params *FindSpotMarketPricesParams, reqEditors ...RequestEditorFn) (*FindSpotMarketPricesResponse, error)

	// FindSpotMarketPricesHistory request
	FindSpotMarketPricesHistoryWithResponse(ctx context.Context, params *FindSpotMarketPricesHistoryParams, reqEditors ...RequestEditorFn) (*FindSpotMarketPricesHistoryResponse, error)

	// FindMetroSpotMarketPrices request
	FindMetroSpotMarketPricesWithResponse(ctx context.Context, params *FindMetroSpotMarketPricesParams, reqEditors ...RequestEditorFn) (*FindMetroSpotMarketPricesResponse, error)

	// DeleteMembership request
	DeleteMembershipWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteMembershipResponse, error)

	// FindMembershipById request
	FindMembershipByIdWithResponse(ctx context.Context, id string, params *FindMembershipByIdParams, reqEditors ...RequestEditorFn) (*FindMembershipByIdResponse, error)

	// UpdateMembership request with any body
	UpdateMembershipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMembershipResponse, error)

	UpdateMembershipWithResponse(ctx context.Context, id string, body UpdateMembershipJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMembershipResponse, error)

	// DeleteMetalGateway request
	DeleteMetalGatewayWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteMetalGatewayResponse, error)

	// FindMetalGatewayById request
	FindMetalGatewayByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindMetalGatewayByIdResponse, error)

	// FindOperatingSystemVersion request
	FindOperatingSystemVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindOperatingSystemVersionResponse, error)

	// FindOperatingSystems request
	FindOperatingSystemsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindOperatingSystemsResponse, error)

	// FindOrganizations request
	FindOrganizationsWithResponse(ctx context.Context, params *FindOrganizationsParams, reqEditors ...RequestEditorFn) (*FindOrganizationsResponse, error)

	// CreateOrganization request with any body
	CreateOrganizationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrganizationResponse, error)

	CreateOrganizationWithResponse(ctx context.Context, body CreateOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrganizationResponse, error)

	// DeleteOrganization request
	DeleteOrganizationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteOrganizationResponse, error)

	// FindOrganizationById request
	FindOrganizationByIdWithResponse(ctx context.Context, id string, params *FindOrganizationByIdParams, reqEditors ...RequestEditorFn) (*FindOrganizationByIdResponse, error)

	// UpdateOrganization request with any body
	UpdateOrganizationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrganizationResponse, error)

	UpdateOrganizationWithResponse(ctx context.Context, id string, body UpdateOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrganizationResponse, error)

	// FindOrganizationCapacityPerFacility request
	FindOrganizationCapacityPerFacilityWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindOrganizationCapacityPerFacilityResponse, error)

	// FindOrganizationCapacityPerMetro request
	FindOrganizationCapacityPerMetroWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindOrganizationCapacityPerMetroResponse, error)

	// FindOrganizationCustomdata request
	FindOrganizationCustomdataWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindOrganizationCustomdataResponse, error)

	// FindOrganizationDevices request
	FindOrganizationDevicesWithResponse(ctx context.Context, id string, params *FindOrganizationDevicesParams, reqEditors ...RequestEditorFn) (*FindOrganizationDevicesResponse, error)

	// FindOrganizationEvents request
	FindOrganizationEventsWithResponse(ctx context.Context, id string, params *FindOrganizationEventsParams, reqEditors ...RequestEditorFn) (*FindOrganizationEventsResponse, error)

	// FindFacilitiesByOrganization request
	FindFacilitiesByOrganizationWithResponse(ctx context.Context, id string, params *FindFacilitiesByOrganizationParams, reqEditors ...RequestEditorFn) (*FindFacilitiesByOrganizationResponse, error)

	// FindOrganizationInvitations request
	FindOrganizationInvitationsWithResponse(ctx context.Context, id string, params *FindOrganizationInvitationsParams, reqEditors ...RequestEditorFn) (*FindOrganizationInvitationsResponse, error)

	// CreateOrganizationInvitation request with any body
	CreateOrganizationInvitationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrganizationInvitationResponse, error)

	CreateOrganizationInvitationWithResponse(ctx context.Context, id string, body CreateOrganizationInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrganizationInvitationResponse, error)

	// FindOperatingSystemsByOrganization request
	FindOperatingSystemsByOrganizationWithResponse(ctx context.Context, id string, params *FindOperatingSystemsByOrganizationParams, reqEditors ...RequestEditorFn) (*FindOperatingSystemsByOrganizationResponse, error)

	// FindOrganizationPaymentMethods request
	FindOrganizationPaymentMethodsWithResponse(ctx context.Context, id string, params *FindOrganizationPaymentMethodsParams, reqEditors ...RequestEditorFn) (*FindOrganizationPaymentMethodsResponse, error)

	// CreatePaymentMethod request with any body
	CreatePaymentMethodWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePaymentMethodResponse, error)

	CreatePaymentMethodWithResponse(ctx context.Context, id string, body CreatePaymentMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePaymentMethodResponse, error)

	// FindPlansByOrganization request
	FindPlansByOrganizationWithResponse(ctx context.Context, id string, params *FindPlansByOrganizationParams, reqEditors ...RequestEditorFn) (*FindPlansByOrganizationResponse, error)

	// FindOrganizationProjects request
	FindOrganizationProjectsWithResponse(ctx context.Context, id string, params *FindOrganizationProjectsParams, reqEditors ...RequestEditorFn) (*FindOrganizationProjectsResponse, error)

	// CreateOrganizationProject request with any body
	CreateOrganizationProjectWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrganizationProjectResponse, error)

	CreateOrganizationProjectWithResponse(ctx context.Context, id string, body CreateOrganizationProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrganizationProjectResponse, error)

	// FindOrganizationTransfers request
	FindOrganizationTransfersWithResponse(ctx context.Context, id string, params *FindOrganizationTransfersParams, reqEditors ...RequestEditorFn) (*FindOrganizationTransfersResponse, error)

	// OrganizationListInterconnections request
	OrganizationListInterconnectionsWithResponse(ctx context.Context, organizationId string, reqEditors ...RequestEditorFn) (*OrganizationListInterconnectionsResponse, error)

	// CreateOrganizationInterconnection request with any body
	CreateOrganizationInterconnectionWithBodyWithResponse(ctx context.Context, organizationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrganizationInterconnectionResponse, error)

	CreateOrganizationInterconnectionWithResponse(ctx context.Context, organizationId string, body CreateOrganizationInterconnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrganizationInterconnectionResponse, error)

	// DeletePaymentMethod request
	DeletePaymentMethodWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePaymentMethodResponse, error)

	// FindPaymentMethodById request
	FindPaymentMethodByIdWithResponse(ctx context.Context, id string, params *FindPaymentMethodByIdParams, reqEditors ...RequestEditorFn) (*FindPaymentMethodByIdResponse, error)

	// UpdatePaymentMethod request with any body
	UpdatePaymentMethodWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePaymentMethodResponse, error)

	UpdatePaymentMethodWithResponse(ctx context.Context, id string, body UpdatePaymentMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePaymentMethodResponse, error)

	// FindPlans request
	FindPlansWithResponse(ctx context.Context, params *FindPlansParams, reqEditors ...RequestEditorFn) (*FindPlansResponse, error)

	// FindPortById request
	FindPortByIdWithResponse(ctx context.Context, id string, params *FindPortByIdParams, reqEditors ...RequestEditorFn) (*FindPortByIdResponse, error)

	// AssignPort request with any body
	AssignPortWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignPortResponse, error)

	AssignPortWithResponse(ctx context.Context, id string, body AssignPortJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignPortResponse, error)

	// BondPort request
	BondPortWithResponse(ctx context.Context, id string, params *BondPortParams, reqEditors ...RequestEditorFn) (*BondPortResponse, error)

	// ConvertLayer2 request with any body
	ConvertLayer2WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConvertLayer2Response, error)

	ConvertLayer2WithResponse(ctx context.Context, id string, body ConvertLayer2JSONRequestBody, reqEditors ...RequestEditorFn) (*ConvertLayer2Response, error)

	// ConvertLayer3 request with any body
	ConvertLayer3WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConvertLayer3Response, error)

	ConvertLayer3WithResponse(ctx context.Context, id string, body ConvertLayer3JSONRequestBody, reqEditors ...RequestEditorFn) (*ConvertLayer3Response, error)

	// DisbondPort request
	DisbondPortWithResponse(ctx context.Context, id string, params *DisbondPortParams, reqEditors ...RequestEditorFn) (*DisbondPortResponse, error)

	// DeleteNativeVlan request
	DeleteNativeVlanWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteNativeVlanResponse, error)

	// AssignNativeVlan request
	AssignNativeVlanWithResponse(ctx context.Context, id string, params *AssignNativeVlanParams, reqEditors ...RequestEditorFn) (*AssignNativeVlanResponse, error)

	// UnassignPort request with any body
	UnassignPortWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnassignPortResponse, error)

	UnassignPortWithResponse(ctx context.Context, id string, body UnassignPortJSONRequestBody, reqEditors ...RequestEditorFn) (*UnassignPortResponse, error)

	// FindPortVlanAssignments request
	FindPortVlanAssignmentsWithResponse(ctx context.Context, id string, params *FindPortVlanAssignmentsParams, reqEditors ...RequestEditorFn) (*FindPortVlanAssignmentsResponse, error)

	// FindPortVlanAssignmentBatches request
	FindPortVlanAssignmentBatchesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindPortVlanAssignmentBatchesResponse, error)

	// CreatePortVlanAssignmentBatch request with any body
	CreatePortVlanAssignmentBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePortVlanAssignmentBatchResponse, error)

	CreatePortVlanAssignmentBatchWithResponse(ctx context.Context, id string, body CreatePortVlanAssignmentBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePortVlanAssignmentBatchResponse, error)

	// FindPortVlanAssignmentBatchByPortIdAndBatchId request
	FindPortVlanAssignmentBatchByPortIdAndBatchIdWithResponse(ctx context.Context, id string, batchId string, reqEditors ...RequestEditorFn) (*FindPortVlanAssignmentBatchByPortIdAndBatchIdResponse, error)

	// FindPortVlanAssignmentByPortIdAndAssignmentId request
	FindPortVlanAssignmentByPortIdAndAssignmentIdWithResponse(ctx context.Context, id string, assignmentId string, params *FindPortVlanAssignmentByPortIdAndAssignmentIdParams, reqEditors ...RequestEditorFn) (*FindPortVlanAssignmentByPortIdAndAssignmentIdResponse, error)

	// FindProjects request
	FindProjectsWithResponse(ctx context.Context, params *FindProjectsParams, reqEditors ...RequestEditorFn) (*FindProjectsResponse, error)

	// CreateProject request with any body
	CreateProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error)

	CreateProjectWithResponse(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error)

	// DeleteProject request
	DeleteProjectWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteProjectResponse, error)

	// FindProjectById request
	FindProjectByIdWithResponse(ctx context.Context, id string, params *FindProjectByIdParams, reqEditors ...RequestEditorFn) (*FindProjectByIdResponse, error)

	// UpdateProject request with any body
	UpdateProjectWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error)

	UpdateProjectWithResponse(ctx context.Context, id string, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error)

	// FindProjectAPIKeys request
	FindProjectAPIKeysWithResponse(ctx context.Context, id string, params *FindProjectAPIKeysParams, reqEditors ...RequestEditorFn) (*FindProjectAPIKeysResponse, error)

	// CreateProjectAPIKey request with any body
	CreateProjectAPIKeyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectAPIKeyResponse, error)

	CreateProjectAPIKeyWithResponse(ctx context.Context, id string, body CreateProjectAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectAPIKeyResponse, error)

	// FindBatchesByProject request
	FindBatchesByProjectWithResponse(ctx context.Context, id string, params *FindBatchesByProjectParams, reqEditors ...RequestEditorFn) (*FindBatchesByProjectResponse, error)

	// FindBgpConfigByProject request
	FindBgpConfigByProjectWithResponse(ctx context.Context, id string, params *FindBgpConfigByProjectParams, reqEditors ...RequestEditorFn) (*FindBgpConfigByProjectResponse, error)

	// RequestBgpConfig request with any body
	RequestBgpConfigWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestBgpConfigResponse, error)

	RequestBgpConfigWithResponse(ctx context.Context, id string, body RequestBgpConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestBgpConfigResponse, error)

	// FindProjectBgpSessions request
	FindProjectBgpSessionsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindProjectBgpSessionsResponse, error)

	// FindProjectCustomdata request
	FindProjectCustomdataWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindProjectCustomdataResponse, error)

	// FindProjectDevices request
	FindProjectDevicesWithResponse(ctx context.Context, id string, params *FindProjectDevicesParams, reqEditors ...RequestEditorFn) (*FindProjectDevicesResponse, error)

	// CreateDevice request with any body
	CreateDeviceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeviceResponse, error)

	CreateDeviceWithResponse(ctx context.Context, id string, body CreateDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeviceResponse, error)

	// CreateDeviceBatch request with any body
	CreateDeviceBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeviceBatchResponse, error)

	CreateDeviceBatchWithResponse(ctx context.Context, id string, body CreateDeviceBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeviceBatchResponse, error)

	// FindProjectEvents request
	FindProjectEventsWithResponse(ctx context.Context, id string, params *FindProjectEventsParams, reqEditors ...RequestEditorFn) (*FindProjectEventsResponse, error)

	// FindFacilitiesByProject request
	FindFacilitiesByProjectWithResponse(ctx context.Context, id string, params *FindFacilitiesByProjectParams, reqEditors ...RequestEditorFn) (*FindFacilitiesByProjectResponse, error)

	// FindGlobalBgpRanges request
	FindGlobalBgpRangesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindGlobalBgpRangesResponse, error)

	// FindProjectHardwareReservations request
	FindProjectHardwareReservationsWithResponse(ctx context.Context, id string, params *FindProjectHardwareReservationsParams, reqEditors ...RequestEditorFn) (*FindProjectHardwareReservationsResponse, error)

	// FindIPReservations request
	FindIPReservationsWithResponse(ctx context.Context, id string, params *FindIPReservationsParams, reqEditors ...RequestEditorFn) (*FindIPReservationsResponse, error)

	// RequestIPReservation request with any body
	RequestIPReservationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestIPReservationResponse, error)

	RequestIPReservationWithResponse(ctx context.Context, id string, body RequestIPReservationJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestIPReservationResponse, error)

	// FindProjectLicenses request
	FindProjectLicensesWithResponse(ctx context.Context, id string, params *FindProjectLicensesParams, reqEditors ...RequestEditorFn) (*FindProjectLicensesResponse, error)

	// CreateLicense request with any body
	CreateLicenseWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLicenseResponse, error)

	CreateLicenseWithResponse(ctx context.Context, id string, body CreateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLicenseResponse, error)

	// FindPlansByProject request
	FindPlansByProjectWithResponse(ctx context.Context, id string, params *FindPlansByProjectParams, reqEditors ...RequestEditorFn) (*FindPlansByProjectResponse, error)

	// ListSpotMarketRequests request
	ListSpotMarketRequestsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ListSpotMarketRequestsResponse, error)

	// CreateSpotMarketRequest request with any body
	CreateSpotMarketRequestWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpotMarketRequestResponse, error)

	CreateSpotMarketRequestWithResponse(ctx context.Context, id string, body CreateSpotMarketRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpotMarketRequestResponse, error)

	// FindProjectSSHKeys request
	FindProjectSSHKeysWithResponse(ctx context.Context, id string, params *FindProjectSSHKeysParams, reqEditors ...RequestEditorFn) (*FindProjectSSHKeysResponse, error)

	// CreateProjectSSHKey request with any body
	CreateProjectSSHKeyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectSSHKeyResponse, error)

	CreateProjectSSHKeyWithResponse(ctx context.Context, id string, body CreateProjectSSHKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectSSHKeyResponse, error)

	// FindVolumes request
	FindVolumesWithResponse(ctx context.Context, id string, params *FindVolumesParams, reqEditors ...RequestEditorFn) (*FindVolumesResponse, error)

	// CreateVolume request with any body
	CreateVolumeWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error)

	CreateVolumeWithResponse(ctx context.Context, id string, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error)

	// CreateTransferRequest request with any body
	CreateTransferRequestWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTransferRequestResponse, error)

	CreateTransferRequestWithResponse(ctx context.Context, id string, body CreateTransferRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTransferRequestResponse, error)

	// FindProjectUsage request
	FindProjectUsageWithResponse(ctx context.Context, id string, params *FindProjectUsageParams, reqEditors ...RequestEditorFn) (*FindProjectUsageResponse, error)

	// FindVirtualNetworks request
	FindVirtualNetworksWithResponse(ctx context.Context, id string, params *FindVirtualNetworksParams, reqEditors ...RequestEditorFn) (*FindVirtualNetworksResponse, error)

	// CreateVirtualNetwork request with any body
	CreateVirtualNetworkWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualNetworkResponse, error)

	CreateVirtualNetworkWithResponse(ctx context.Context, id string, body CreateVirtualNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualNetworkResponse, error)

	// ProjectListInterconnections request
	ProjectListInterconnectionsWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*ProjectListInterconnectionsResponse, error)

	// CreateProjectInterconnection request with any body
	CreateProjectInterconnectionWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectInterconnectionResponse, error)

	CreateProjectInterconnectionWithResponse(ctx context.Context, projectId string, body CreateProjectInterconnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectInterconnectionResponse, error)

	// FindProjectInvitations request
	FindProjectInvitationsWithResponse(ctx context.Context, projectId string, params *FindProjectInvitationsParams, reqEditors ...RequestEditorFn) (*FindProjectInvitationsResponse, error)

	// CreateProjectInvitation request with any body
	CreateProjectInvitationWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectInvitationResponse, error)

	CreateProjectInvitationWithResponse(ctx context.Context, projectId string, body CreateProjectInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectInvitationResponse, error)

	// FindIPReservationCustomdata request
	FindIPReservationCustomdataWithResponse(ctx context.Context, projectId string, id string, reqEditors ...RequestEditorFn) (*FindIPReservationCustomdataResponse, error)

	// FindProjectMemberships request
	FindProjectMembershipsWithResponse(ctx context.Context, projectId string, params *FindProjectMembershipsParams, reqEditors ...RequestEditorFn) (*FindProjectMembershipsResponse, error)

	// FindMetalGatewaysByProject request
	FindMetalGatewaysByProjectWithResponse(ctx context.Context, projectId string, params *FindMetalGatewaysByProjectParams, reqEditors ...RequestEditorFn) (*FindMetalGatewaysByProjectResponse, error)

	// CreateMetalGateway request with any body
	CreateMetalGatewayWithBodyWithResponse(ctx context.Context, projectId string, params *CreateMetalGatewayParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMetalGatewayResponse, error)

	CreateMetalGatewayWithResponse(ctx context.Context, projectId string, params *CreateMetalGatewayParams, body CreateMetalGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMetalGatewayResponse, error)

	// FindSelfServiceReservations request
	FindSelfServiceReservationsWithResponse(ctx context.Context, projectId string, params *FindSelfServiceReservationsParams, reqEditors ...RequestEditorFn) (*FindSelfServiceReservationsResponse, error)

	// CreateSelfServiceReservation request with any body
	CreateSelfServiceReservationWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSelfServiceReservationResponse, error)

	CreateSelfServiceReservationWithResponse(ctx context.Context, projectId string, body CreateSelfServiceReservationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSelfServiceReservationResponse, error)

	// FindSelfServiceReservation request
	FindSelfServiceReservationWithResponse(ctx context.Context, projectId string, id string, reqEditors ...RequestEditorFn) (*FindSelfServiceReservationResponse, error)

	// ResetPassword request
	ResetPasswordWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	// CreatePasswordResetToken request
	CreatePasswordResetTokenWithResponse(ctx context.Context, params *CreatePasswordResetTokenParams, reqEditors ...RequestEditorFn) (*CreatePasswordResetTokenResponse, error)

	// DeleteSpotMarketRequest request
	DeleteSpotMarketRequestWithResponse(ctx context.Context, id string, params *DeleteSpotMarketRequestParams, reqEditors ...RequestEditorFn) (*DeleteSpotMarketRequestResponse, error)

	// FindSpotMarketRequestById request
	FindSpotMarketRequestByIdWithResponse(ctx context.Context, id string, params *FindSpotMarketRequestByIdParams, reqEditors ...RequestEditorFn) (*FindSpotMarketRequestByIdResponse, error)

	// FindSSHKeys request
	FindSSHKeysWithResponse(ctx context.Context, params *FindSSHKeysParams, reqEditors ...RequestEditorFn) (*FindSSHKeysResponse, error)

	// CreateSSHKey request with any body
	CreateSSHKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSSHKeyResponse, error)

	CreateSSHKeyWithResponse(ctx context.Context, body CreateSSHKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSSHKeyResponse, error)

	// DeleteSSHKey request
	DeleteSSHKeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSSHKeyResponse, error)

	// FindSSHKeyById request
	FindSSHKeyByIdWithResponse(ctx context.Context, id string, params *FindSSHKeyByIdParams, reqEditors ...RequestEditorFn) (*FindSSHKeyByIdResponse, error)

	// UpdateSSHKey request with any body
	UpdateSSHKeyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSSHKeyResponse, error)

	UpdateSSHKeyWithResponse(ctx context.Context, id string, body UpdateSSHKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSSHKeyResponse, error)

	// DeleteVolumeAttachment request
	DeleteVolumeAttachmentWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteVolumeAttachmentResponse, error)

	// FindVolumeAttachmentById request
	FindVolumeAttachmentByIdWithResponse(ctx context.Context, id string, params *FindVolumeAttachmentByIdParams, reqEditors ...RequestEditorFn) (*FindVolumeAttachmentByIdResponse, error)

	// DeleteVolumeSnapshotPolicy request
	DeleteVolumeSnapshotPolicyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteVolumeSnapshotPolicyResponse, error)

	// UpdateVolumeSnapshotPolicy request
	UpdateVolumeSnapshotPolicyWithResponse(ctx context.Context, id string, params *UpdateVolumeSnapshotPolicyParams, reqEditors ...RequestEditorFn) (*UpdateVolumeSnapshotPolicyResponse, error)

	// DeleteVolume request
	DeleteVolumeWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteVolumeResponse, error)

	// FindVolumeById request
	FindVolumeByIdWithResponse(ctx context.Context, id string, params *FindVolumeByIdParams, reqEditors ...RequestEditorFn) (*FindVolumeByIdResponse, error)

	// UpdateVolume request with any body
	UpdateVolumeWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error)

	UpdateVolumeWithResponse(ctx context.Context, id string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error)

	// FindVolumeAttachments request
	FindVolumeAttachmentsWithResponse(ctx context.Context, id string, params *FindVolumeAttachmentsParams, reqEditors ...RequestEditorFn) (*FindVolumeAttachmentsResponse, error)

	// CreateVolumeAttachment request with any body
	CreateVolumeAttachmentWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeAttachmentResponse, error)

	CreateVolumeAttachmentWithResponse(ctx context.Context, id string, body CreateVolumeAttachmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeAttachmentResponse, error)

	// CloneVolume request
	CloneVolumeWithResponse(ctx context.Context, id string, params *CloneVolumeParams, reqEditors ...RequestEditorFn) (*CloneVolumeResponse, error)

	// FindVolumeCustomdata request
	FindVolumeCustomdataWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindVolumeCustomdataResponse, error)

	// RestoreVolume request
	RestoreVolumeWithResponse(ctx context.Context, id string, params *RestoreVolumeParams, reqEditors ...RequestEditorFn) (*RestoreVolumeResponse, error)

	// CreateVolumeSnapshotPolicy request
	CreateVolumeSnapshotPolicyWithResponse(ctx context.Context, id string, params *CreateVolumeSnapshotPolicyParams, reqEditors ...RequestEditorFn) (*CreateVolumeSnapshotPolicyResponse, error)

	// FindVolumeSnapshots request
	FindVolumeSnapshotsWithResponse(ctx context.Context, id string, params *FindVolumeSnapshotsParams, reqEditors ...RequestEditorFn) (*FindVolumeSnapshotsResponse, error)

	// DeleteVolumeSnapshot request
	DeleteVolumeSnapshotWithResponse(ctx context.Context, volumeId string, id string, reqEditors ...RequestEditorFn) (*DeleteVolumeSnapshotResponse, error)

	// RequestSuppert request with any body
	RequestSuppertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestSuppertResponse, error)

	RequestSuppertWithResponse(ctx context.Context, body RequestSuppertJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestSuppertResponse, error)

	// DeclineTransferRequest request
	DeclineTransferRequestWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeclineTransferRequestResponse, error)

	// FindTransferRequestById request
	FindTransferRequestByIdWithResponse(ctx context.Context, id string, params *FindTransferRequestByIdParams, reqEditors ...RequestEditorFn) (*FindTransferRequestByIdResponse, error)

	// AcceptTransferRequest request
	AcceptTransferRequestWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*AcceptTransferRequestResponse, error)

	// FindCurrentUser request
	FindCurrentUserWithResponse(ctx context.Context, params *FindCurrentUserParams, reqEditors ...RequestEditorFn) (*FindCurrentUserResponse, error)

	// UpdateCurrentUser request with any body
	UpdateCurrentUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCurrentUserResponse, error)

	UpdateCurrentUserWithResponse(ctx context.Context, body UpdateCurrentUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCurrentUserResponse, error)

	// FindAPIKeys request
	FindAPIKeysWithResponse(ctx context.Context, params *FindAPIKeysParams, reqEditors ...RequestEditorFn) (*FindAPIKeysResponse, error)

	// CreateAPIKey request with any body
	CreateAPIKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAPIKeyResponse, error)

	CreateAPIKeyWithResponse(ctx context.Context, body CreateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAPIKeyResponse, error)

	// DeleteUserAPIKey request
	DeleteUserAPIKeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteUserAPIKeyResponse, error)

	// DisableTfaApp request
	DisableTfaAppWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DisableTfaAppResponse, error)

	// EnableTfaApp request
	EnableTfaAppWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*EnableTfaAppResponse, error)

	// FindRecoveryCodes request
	FindRecoveryCodesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindRecoveryCodesResponse, error)

	// RegenerateCodes request
	RegenerateCodesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RegenerateCodesResponse, error)

	// DisableTfaSms request
	DisableTfaSmsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DisableTfaSmsResponse, error)

	// EnableTfaSms request
	EnableTfaSmsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*EnableTfaSmsResponse, error)

	// ReceiveCodes request
	ReceiveCodesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ReceiveCodesResponse, error)

	// FindEnsureOtp request
	FindEnsureOtpWithResponse(ctx context.Context, otp string, reqEditors ...RequestEditorFn) (*FindEnsureOtpResponse, error)

	// ValidateUserdata request
	ValidateUserdataWithResponse(ctx context.Context, params *ValidateUserdataParams, reqEditors ...RequestEditorFn) (*ValidateUserdataResponse, error)

	// FindUsers request
	FindUsersWithResponse(ctx context.Context, params *FindUsersParams, reqEditors ...RequestEditorFn) (*FindUsersResponse, error)

	// CreateUser request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// FindUserById request
	FindUserByIdWithResponse(ctx context.Context, id string, params *FindUserByIdParams, reqEditors ...RequestEditorFn) (*FindUserByIdResponse, error)

	// FindUserCustomdata request
	FindUserCustomdataWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindUserCustomdataResponse, error)

	// CreateValidationRequest request
	CreateValidationRequestWithResponse(ctx context.Context, params *CreateValidationRequestParams, reqEditors ...RequestEditorFn) (*CreateValidationRequestResponse, error)

	// ConsumeVerificationRequest request
	ConsumeVerificationRequestWithResponse(ctx context.Context, params *ConsumeVerificationRequestParams, reqEditors ...RequestEditorFn) (*ConsumeVerificationRequestResponse, error)

	// FindVirtualCircuitEvents request
	FindVirtualCircuitEventsWithResponse(ctx context.Context, id string, params *FindVirtualCircuitEventsParams, reqEditors ...RequestEditorFn) (*FindVirtualCircuitEventsResponse, error)

	// DeleteVirtualCircuit request
	DeleteVirtualCircuitWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteVirtualCircuitResponse, error)

	// GetVirtualCircuit request
	GetVirtualCircuitWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetVirtualCircuitResponse, error)

	// UpdateVirtualCircuit request with any body
	UpdateVirtualCircuitWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVirtualCircuitResponse, error)

	UpdateVirtualCircuitWithResponse(ctx context.Context, id string, body UpdateVirtualCircuitJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVirtualCircuitResponse, error)

	// DeleteVirtualNetwork request
	DeleteVirtualNetworkWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteVirtualNetworkResponse, error)

	// GetVirtualNetwork request
	GetVirtualNetworkWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetVirtualNetworkResponse, error)

	// FindVolumeEvents request
	FindVolumeEventsWithResponse(ctx context.Context, id string, params *FindVolumeEventsParams, reqEditors ...RequestEditorFn) (*FindVolumeEventsResponse, error)
}

type DeleteAPIKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteAPIKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAPIKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindBatchByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Batch
	JSON401      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindBatchByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindBatchByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBgpSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteBgpSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBgpSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindBgpSessionByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BgpSession
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindBgpSessionByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindBgpSessionByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBgpSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateBgpSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBgpSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindCapacityForFacilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CapacityList
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r FindCapacityForFacilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindCapacityForFacilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckCapacityForFacilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CapacityCheckPerFacilityList
	JSON401      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CheckCapacityForFacilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckCapacityForFacilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindCapacityForMetroResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetroCapacityList
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r FindCapacityForMetroResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindCapacityForMetroResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckCapacityForMetroResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CapacityCheckPerMetroList
	JSON401      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CheckCapacityForMetroResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckCapacityForMetroResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInterconnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *Interconnection
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteInterconnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInterconnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInterconnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Interconnection
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r GetInterconnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInterconnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateInterconnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Interconnection
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateInterconnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateInterconnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindConnectionEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Event
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindConnectionEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindConnectionEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListConnectionPortsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InterconnectionPortList
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r ListConnectionPortsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConnectionPortsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConnectionPortResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InterconnectionPort
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r GetConnectionPortResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConnectionPortResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindConnectionPortEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Event
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindConnectionPortEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindConnectionPortEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListConnectionPortVirtualCircuitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VirtualCircuitList
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r ListConnectionPortVirtualCircuitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConnectionPortVirtualCircuitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateConnectionPortVirtualCircuitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VirtualCircuitList
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r CreateConnectionPortVirtualCircuitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateConnectionPortVirtualCircuitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDeviceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteDeviceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDeviceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindDeviceByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Device
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindDeviceByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindDeviceByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDeviceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Device
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateDeviceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDeviceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PerformActionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r PerformActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PerformActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindInstanceBandwidthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindInstanceBandwidthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindInstanceBandwidthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBgpNeighborDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BgpSessionNeighbors
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r GetBgpNeighborDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBgpNeighborDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindBgpSessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BgpSessionList
	JSON401      *Error
	JSON403      *Error
}

// Status returns HTTPResponse.Status
func (r FindBgpSessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindBgpSessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBgpSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BgpSession
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateBgpSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBgpSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindDeviceCustomdataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindDeviceCustomdataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindDeviceCustomdataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindDeviceEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindDeviceEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindDeviceEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindIPAssignmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IPAssignmentList
	JSON401      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindIPAssignmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindIPAssignmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIPAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IPAssignment
	JSON401      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateIPAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIPAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindDeviceSSHKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SSHKeyList
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r FindDeviceSSHKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindDeviceSSHKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindTrafficResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindTrafficResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindTrafficResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindDeviceUsagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeviceUsageList
	JSON401      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindDeviceUsagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindDeviceUsagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindIPAssignmentCustomdataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindIPAssignmentCustomdataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindIPAssignmentCustomdataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Email
	JSON401      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindEmailByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Email
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindEmailByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindEmailByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Email
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventList
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r FindEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindEventByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Event
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindEventByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindEventByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindFacilitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FacilityList
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r FindFacilitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindFacilitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindHardwareReservationByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Device
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindHardwareReservationByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindHardwareReservationByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MoveHardwareReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HardwareReservation
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r MoveHardwareReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MoveHardwareReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindIncidentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r FindIncidentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindIncidentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindInvitationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InvitationList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindInvitationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindInvitationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeclineInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeclineInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeclineInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindInvitationByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Invitation
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindInvitationByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindInvitationByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Membership
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r AcceptInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIPAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteIPAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIPAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindIPAddressByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IPAssignment
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindIPAddressByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindIPAddressByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateIPAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IPAssignment
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateIPAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateIPAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindIPAvailabilitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IPAvailabilitiesList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindIPAvailabilitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindIPAvailabilitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindIPAddressCustomdataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindIPAddressCustomdataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindIPAddressCustomdataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLicenseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLicenseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLicenseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindLicenseByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *License
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindLicenseByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindLicenseByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLicenseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *License
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateLicenseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLicenseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindMetrosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetroList
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r FindMetrosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindMetrosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetroResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Metro
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r GetMetroResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetroResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindSpotMarketPricesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpotMarketPricesList
}

// Status returns HTTPResponse.Status
func (r FindSpotMarketPricesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindSpotMarketPricesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindSpotMarketPricesHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpotPricesHistoryReport
}

// Status returns HTTPResponse.Status
func (r FindSpotMarketPricesHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindSpotMarketPricesHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindMetroSpotMarketPricesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpotMarketPricesPerMetroList
}

// Status returns HTTPResponse.Status
func (r FindMetroSpotMarketPricesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindMetroSpotMarketPricesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindMembershipByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Membership
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindMembershipByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindMembershipByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Membership
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMetalGatewayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteMetalGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMetalGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindMetalGatewayByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetalGateway
	JSON401      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindMetalGatewayByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindMetalGatewayByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOperatingSystemVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OperatingSystemList
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r FindOperatingSystemVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOperatingSystemVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOperatingSystemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OperatingSystemList
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r FindOperatingSystemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOperatingSystemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOrganizationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrganizationList
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r FindOrganizationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOrganizationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Organization
	JSON401      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOrganizationByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Organization
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindOrganizationByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOrganizationByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Organization
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOrganizationCapacityPerFacilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CapacityList
	JSON401      *Error
	JSON403      *Error
}

// Status returns HTTPResponse.Status
func (r FindOrganizationCapacityPerFacilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOrganizationCapacityPerFacilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOrganizationCapacityPerMetroResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetroCapacityList
	JSON401      *Error
	JSON403      *Error
}

// Status returns HTTPResponse.Status
func (r FindOrganizationCapacityPerMetroResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOrganizationCapacityPerMetroResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOrganizationCustomdataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindOrganizationCustomdataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOrganizationCustomdataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOrganizationDevicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeviceList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindOrganizationDevicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOrganizationDevicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOrganizationEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindOrganizationEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOrganizationEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindFacilitiesByOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FacilityList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindFacilitiesByOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindFacilitiesByOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOrganizationInvitationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InvitationList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindOrganizationInvitationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOrganizationInvitationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrganizationInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Invitation
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateOrganizationInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrganizationInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOperatingSystemsByOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OperatingSystemList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindOperatingSystemsByOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOperatingSystemsByOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOrganizationPaymentMethodsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentMethodList
	JSON401      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindOrganizationPaymentMethodsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOrganizationPaymentMethodsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePaymentMethodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PaymentMethod
	JSON401      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreatePaymentMethodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePaymentMethodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindPlansByOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlanList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindPlansByOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindPlansByOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOrganizationProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectList
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r FindOrganizationProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOrganizationProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrganizationProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Project
	JSON401      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateOrganizationProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrganizationProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindOrganizationTransfersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransferRequestList
	JSON401      *Error
	JSON403      *Error
}

// Status returns HTTPResponse.Status
func (r FindOrganizationTransfersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindOrganizationTransfersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrganizationListInterconnectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InterconnectionList
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r OrganizationListInterconnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrganizationListInterconnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrganizationInterconnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Interconnection
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateOrganizationInterconnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrganizationInterconnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePaymentMethodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeletePaymentMethodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePaymentMethodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindPaymentMethodByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentMethod
	JSON401      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindPaymentMethodByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindPaymentMethodByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePaymentMethodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentMethod
	JSON401      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r UpdatePaymentMethodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePaymentMethodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindPlansResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlanList
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r FindPlansResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindPlansResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindPortByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Port
	JSON401      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindPortByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindPortByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignPortResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Port
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r AssignPortResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignPortResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BondPortResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Port
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r BondPortResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BondPortResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConvertLayer2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Port
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r ConvertLayer2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConvertLayer2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConvertLayer3Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Port
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r ConvertLayer3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConvertLayer3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisbondPortResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Port
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r DisbondPortResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisbondPortResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNativeVlanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Port
	JSON401      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteNativeVlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNativeVlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignNativeVlanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Port
	JSON401      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r AssignNativeVlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignNativeVlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignPortResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Port
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r UnassignPortResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignPortResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindPortVlanAssignmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PortVlanAssignmentList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindPortVlanAssignmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindPortVlanAssignmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindPortVlanAssignmentBatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PortVlanAssignmentBatchList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindPortVlanAssignmentBatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindPortVlanAssignmentBatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePortVlanAssignmentBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PortVlanAssignmentBatch
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreatePortVlanAssignmentBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePortVlanAssignmentBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindPortVlanAssignmentBatchByPortIdAndBatchIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PortVlanAssignmentBatch
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindPortVlanAssignmentBatchByPortIdAndBatchIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindPortVlanAssignmentBatchByPortIdAndBatchIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindPortVlanAssignmentByPortIdAndAssignmentIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PortVlanAssignment
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindPortVlanAssignmentByPortIdAndAssignmentIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindPortVlanAssignmentByPortIdAndAssignmentIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectList
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r FindProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Project
	JSON401      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindProjectByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Project
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindProjectByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindProjectByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Project
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindProjectAPIKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthTokenList
	JSON401      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindProjectAPIKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindProjectAPIKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectAPIKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AuthToken
	JSON401      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateProjectAPIKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectAPIKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindBatchesByProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BatchesList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindBatchesByProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindBatchesByProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindBgpConfigByProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BgpConfig
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindBgpConfigByProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindBgpConfigByProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestBgpConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r RequestBgpConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestBgpConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindProjectBgpSessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BgpSessionList
	JSON401      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindProjectBgpSessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindProjectBgpSessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindProjectCustomdataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindProjectCustomdataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindProjectCustomdataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindProjectDevicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeviceList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindProjectDevicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindProjectDevicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDeviceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Device
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateDeviceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDeviceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDeviceBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BatchesList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateDeviceBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDeviceBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindProjectEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindProjectEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindProjectEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindFacilitiesByProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FacilityList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindFacilitiesByProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindFacilitiesByProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindGlobalBgpRangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalBgpRangeList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindGlobalBgpRangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindGlobalBgpRangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindProjectHardwareReservationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HardwareReservationList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindProjectHardwareReservationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindProjectHardwareReservationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindIPReservationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IPReservationList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindIPReservationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindIPReservationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestIPReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IPReservation
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r RequestIPReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestIPReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindProjectLicensesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LicenseList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindProjectLicensesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindProjectLicensesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLicenseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *License
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateLicenseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLicenseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindPlansByProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlanList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindPlansByProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindPlansByProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSpotMarketRequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpotMarketRequestList
	JSON401      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r ListSpotMarketRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSpotMarketRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpotMarketRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SpotMarketRequest
	JSON401      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateSpotMarketRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpotMarketRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindProjectSSHKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SSHKeyList
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r FindProjectSSHKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindProjectSSHKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectSSHKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SSHKey
	JSON401      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateProjectSSHKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectSSHKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindVolumesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VolumeList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindVolumesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindVolumesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Volume
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTransferRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TransferRequest
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateTransferRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTransferRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindProjectUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectUsageList
	JSON401      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindProjectUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindProjectUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindVirtualNetworksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VirtualNetworkList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindVirtualNetworksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindVirtualNetworksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVirtualNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VirtualNetwork
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateVirtualNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVirtualNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectListInterconnectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InterconnectionList
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r ProjectListInterconnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectListInterconnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectInterconnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Interconnection
	JSON403      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateProjectInterconnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectInterconnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindProjectInvitationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InvitationList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindProjectInvitationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindProjectInvitationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Invitation
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateProjectInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindIPReservationCustomdataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindIPReservationCustomdataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindIPReservationCustomdataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindProjectMembershipsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MembershipList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindProjectMembershipsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindProjectMembershipsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindMetalGatewaysByProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetalGatewayList
	JSON401      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindMetalGatewaysByProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindMetalGatewaysByProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMetalGatewayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MetalGateway
	JSON401      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateMetalGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMetalGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindSelfServiceReservationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SelfServiceReservationList
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r FindSelfServiceReservationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindSelfServiceReservationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSelfServiceReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SelfServiceReservationResponse
	JSON401      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateSelfServiceReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSelfServiceReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindSelfServiceReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SelfServiceReservationResponse
	JSON401      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindSelfServiceReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindSelfServiceReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *NewPassword
	JSON401      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r ResetPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePasswordResetTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreatePasswordResetTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePasswordResetTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpotMarketRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSpotMarketRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpotMarketRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindSpotMarketRequestByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpotMarketRequest
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindSpotMarketRequestByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindSpotMarketRequestByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindSSHKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SSHKeyList
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r FindSSHKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindSSHKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSSHKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SSHKey
	JSON401      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateSSHKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSSHKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSSHKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSSHKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSSHKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindSSHKeyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SSHKey
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindSSHKeyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindSSHKeyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSSHKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SSHKey
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateSSHKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSSHKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVolumeAttachmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVolumeAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVolumeAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindVolumeAttachmentByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VolumeAttachment
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindVolumeAttachmentByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindVolumeAttachmentByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVolumeSnapshotPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVolumeSnapshotPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVolumeSnapshotPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVolumeSnapshotPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SnapshotPolicy
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVolumeSnapshotPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVolumeSnapshotPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindVolumeByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Volume
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindVolumeByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindVolumeByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Volume
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindVolumeAttachmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VolumeAttachmentList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindVolumeAttachmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindVolumeAttachmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVolumeAttachmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VolumeAttachment
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateVolumeAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVolumeAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CloneVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Volume
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CloneVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CloneVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindVolumeCustomdataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindVolumeCustomdataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindVolumeCustomdataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Volume
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r RestoreVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVolumeSnapshotPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SnapshotPolicy
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateVolumeSnapshotPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVolumeSnapshotPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindVolumeSnapshotsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VolumeSnapshotList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindVolumeSnapshotsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindVolumeSnapshotsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVolumeSnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVolumeSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVolumeSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestSuppertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r RequestSuppertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestSuppertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeclineTransferRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeclineTransferRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeclineTransferRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindTransferRequestByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransferRequest
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindTransferRequestByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindTransferRequestByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptTransferRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r AcceptTransferRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptTransferRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r FindCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON401      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAPIKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthTokenList
	JSON401      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindAPIKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAPIKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAPIKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AuthToken
	JSON401      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateAPIKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAPIKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserAPIKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteUserAPIKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserAPIKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableTfaAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DisableTfaAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableTfaAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableTfaAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r EnableTfaAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableTfaAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindRecoveryCodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecoveryCodeList
	JSON401      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r FindRecoveryCodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindRecoveryCodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegenerateCodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecoveryCodeList
	JSON401      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r RegenerateCodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegenerateCodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableTfaSmsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DisableTfaSmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableTfaSmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableTfaSmsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r EnableTfaSmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableTfaSmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReceiveCodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON422      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ReceiveCodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReceiveCodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindEnsureOtpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r FindEnsureOtpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindEnsureOtpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateUserdataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r ValidateUserdataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateUserdataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserList
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r FindUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *User
	JSON401      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindUserByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindUserByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindUserByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindUserCustomdataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindUserCustomdataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindUserCustomdataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateValidationRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r CreateValidationRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateValidationRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConsumeVerificationRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ConsumeVerificationRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConsumeVerificationRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindVirtualCircuitEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Event
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindVirtualCircuitEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindVirtualCircuitEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVirtualCircuitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *VirtualCircuit
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVirtualCircuitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVirtualCircuitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVirtualCircuitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VirtualCircuit
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r GetVirtualCircuitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVirtualCircuitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVirtualCircuitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VirtualCircuit
	JSON202      *VirtualCircuit
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVirtualCircuitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVirtualCircuitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVirtualNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VirtualNetwork
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVirtualNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVirtualNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVirtualNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VirtualNetwork
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON422      *Error
}

// Status returns HTTPResponse.Status
func (r GetVirtualNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVirtualNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindVolumeEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r FindVolumeEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindVolumeEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DeleteAPIKeyWithResponse request returning *DeleteAPIKeyResponse
func (c *ClientWithResponses) DeleteAPIKeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAPIKeyResponse, error) {
	rsp, err := c.DeleteAPIKey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAPIKeyResponse(rsp)
}

// DeleteBatchWithResponse request returning *DeleteBatchResponse
func (c *ClientWithResponses) DeleteBatchWithResponse(ctx context.Context, id string, params *DeleteBatchParams, reqEditors ...RequestEditorFn) (*DeleteBatchResponse, error) {
	rsp, err := c.DeleteBatch(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBatchResponse(rsp)
}

// FindBatchByIdWithResponse request returning *FindBatchByIdResponse
func (c *ClientWithResponses) FindBatchByIdWithResponse(ctx context.Context, id string, params *FindBatchByIdParams, reqEditors ...RequestEditorFn) (*FindBatchByIdResponse, error) {
	rsp, err := c.FindBatchById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindBatchByIdResponse(rsp)
}

// DeleteBgpSessionWithResponse request returning *DeleteBgpSessionResponse
func (c *ClientWithResponses) DeleteBgpSessionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteBgpSessionResponse, error) {
	rsp, err := c.DeleteBgpSession(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBgpSessionResponse(rsp)
}

// FindBgpSessionByIdWithResponse request returning *FindBgpSessionByIdResponse
func (c *ClientWithResponses) FindBgpSessionByIdWithResponse(ctx context.Context, id string, params *FindBgpSessionByIdParams, reqEditors ...RequestEditorFn) (*FindBgpSessionByIdResponse, error) {
	rsp, err := c.FindBgpSessionById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindBgpSessionByIdResponse(rsp)
}

// UpdateBgpSessionWithBodyWithResponse request with arbitrary body returning *UpdateBgpSessionResponse
func (c *ClientWithResponses) UpdateBgpSessionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBgpSessionResponse, error) {
	rsp, err := c.UpdateBgpSessionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBgpSessionResponse(rsp)
}

func (c *ClientWithResponses) UpdateBgpSessionWithResponse(ctx context.Context, id string, body UpdateBgpSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBgpSessionResponse, error) {
	rsp, err := c.UpdateBgpSession(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBgpSessionResponse(rsp)
}

// FindCapacityForFacilityWithResponse request returning *FindCapacityForFacilityResponse
func (c *ClientWithResponses) FindCapacityForFacilityWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindCapacityForFacilityResponse, error) {
	rsp, err := c.FindCapacityForFacility(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindCapacityForFacilityResponse(rsp)
}

// CheckCapacityForFacilityWithBodyWithResponse request with arbitrary body returning *CheckCapacityForFacilityResponse
func (c *ClientWithResponses) CheckCapacityForFacilityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckCapacityForFacilityResponse, error) {
	rsp, err := c.CheckCapacityForFacilityWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckCapacityForFacilityResponse(rsp)
}

func (c *ClientWithResponses) CheckCapacityForFacilityWithResponse(ctx context.Context, body CheckCapacityForFacilityJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckCapacityForFacilityResponse, error) {
	rsp, err := c.CheckCapacityForFacility(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckCapacityForFacilityResponse(rsp)
}

// FindCapacityForMetroWithResponse request returning *FindCapacityForMetroResponse
func (c *ClientWithResponses) FindCapacityForMetroWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindCapacityForMetroResponse, error) {
	rsp, err := c.FindCapacityForMetro(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindCapacityForMetroResponse(rsp)
}

// CheckCapacityForMetroWithBodyWithResponse request with arbitrary body returning *CheckCapacityForMetroResponse
func (c *ClientWithResponses) CheckCapacityForMetroWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckCapacityForMetroResponse, error) {
	rsp, err := c.CheckCapacityForMetroWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckCapacityForMetroResponse(rsp)
}

func (c *ClientWithResponses) CheckCapacityForMetroWithResponse(ctx context.Context, body CheckCapacityForMetroJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckCapacityForMetroResponse, error) {
	rsp, err := c.CheckCapacityForMetro(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckCapacityForMetroResponse(rsp)
}

// DeleteInterconnectionWithResponse request returning *DeleteInterconnectionResponse
func (c *ClientWithResponses) DeleteInterconnectionWithResponse(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*DeleteInterconnectionResponse, error) {
	rsp, err := c.DeleteInterconnection(ctx, connectionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInterconnectionResponse(rsp)
}

// GetInterconnectionWithResponse request returning *GetInterconnectionResponse
func (c *ClientWithResponses) GetInterconnectionWithResponse(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*GetInterconnectionResponse, error) {
	rsp, err := c.GetInterconnection(ctx, connectionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInterconnectionResponse(rsp)
}

// UpdateInterconnectionWithBodyWithResponse request with arbitrary body returning *UpdateInterconnectionResponse
func (c *ClientWithResponses) UpdateInterconnectionWithBodyWithResponse(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInterconnectionResponse, error) {
	rsp, err := c.UpdateInterconnectionWithBody(ctx, connectionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInterconnectionResponse(rsp)
}

func (c *ClientWithResponses) UpdateInterconnectionWithResponse(ctx context.Context, connectionId string, body UpdateInterconnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInterconnectionResponse, error) {
	rsp, err := c.UpdateInterconnection(ctx, connectionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInterconnectionResponse(rsp)
}

// FindConnectionEventsWithResponse request returning *FindConnectionEventsResponse
func (c *ClientWithResponses) FindConnectionEventsWithResponse(ctx context.Context, connectionId string, params *FindConnectionEventsParams, reqEditors ...RequestEditorFn) (*FindConnectionEventsResponse, error) {
	rsp, err := c.FindConnectionEvents(ctx, connectionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindConnectionEventsResponse(rsp)
}

// ListConnectionPortsWithResponse request returning *ListConnectionPortsResponse
func (c *ClientWithResponses) ListConnectionPortsWithResponse(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*ListConnectionPortsResponse, error) {
	rsp, err := c.ListConnectionPorts(ctx, connectionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListConnectionPortsResponse(rsp)
}

// GetConnectionPortWithResponse request returning *GetConnectionPortResponse
func (c *ClientWithResponses) GetConnectionPortWithResponse(ctx context.Context, connectionId string, id string, reqEditors ...RequestEditorFn) (*GetConnectionPortResponse, error) {
	rsp, err := c.GetConnectionPort(ctx, connectionId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConnectionPortResponse(rsp)
}

// FindConnectionPortEventsWithResponse request returning *FindConnectionPortEventsResponse
func (c *ClientWithResponses) FindConnectionPortEventsWithResponse(ctx context.Context, connectionId string, id string, params *FindConnectionPortEventsParams, reqEditors ...RequestEditorFn) (*FindConnectionPortEventsResponse, error) {
	rsp, err := c.FindConnectionPortEvents(ctx, connectionId, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindConnectionPortEventsResponse(rsp)
}

// ListConnectionPortVirtualCircuitsWithResponse request returning *ListConnectionPortVirtualCircuitsResponse
func (c *ClientWithResponses) ListConnectionPortVirtualCircuitsWithResponse(ctx context.Context, connectionId string, portId string, reqEditors ...RequestEditorFn) (*ListConnectionPortVirtualCircuitsResponse, error) {
	rsp, err := c.ListConnectionPortVirtualCircuits(ctx, connectionId, portId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListConnectionPortVirtualCircuitsResponse(rsp)
}

// CreateConnectionPortVirtualCircuitWithBodyWithResponse request with arbitrary body returning *CreateConnectionPortVirtualCircuitResponse
func (c *ClientWithResponses) CreateConnectionPortVirtualCircuitWithBodyWithResponse(ctx context.Context, connectionId string, portId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConnectionPortVirtualCircuitResponse, error) {
	rsp, err := c.CreateConnectionPortVirtualCircuitWithBody(ctx, connectionId, portId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConnectionPortVirtualCircuitResponse(rsp)
}

func (c *ClientWithResponses) CreateConnectionPortVirtualCircuitWithResponse(ctx context.Context, connectionId string, portId string, body CreateConnectionPortVirtualCircuitJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConnectionPortVirtualCircuitResponse, error) {
	rsp, err := c.CreateConnectionPortVirtualCircuit(ctx, connectionId, portId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConnectionPortVirtualCircuitResponse(rsp)
}

// DeleteDeviceWithResponse request returning *DeleteDeviceResponse
func (c *ClientWithResponses) DeleteDeviceWithResponse(ctx context.Context, id string, params *DeleteDeviceParams, reqEditors ...RequestEditorFn) (*DeleteDeviceResponse, error) {
	rsp, err := c.DeleteDevice(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDeviceResponse(rsp)
}

// FindDeviceByIdWithResponse request returning *FindDeviceByIdResponse
func (c *ClientWithResponses) FindDeviceByIdWithResponse(ctx context.Context, id string, params *FindDeviceByIdParams, reqEditors ...RequestEditorFn) (*FindDeviceByIdResponse, error) {
	rsp, err := c.FindDeviceById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindDeviceByIdResponse(rsp)
}

// UpdateDeviceWithBodyWithResponse request with arbitrary body returning *UpdateDeviceResponse
func (c *ClientWithResponses) UpdateDeviceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDeviceResponse, error) {
	rsp, err := c.UpdateDeviceWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDeviceResponse(rsp)
}

func (c *ClientWithResponses) UpdateDeviceWithResponse(ctx context.Context, id string, body UpdateDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDeviceResponse, error) {
	rsp, err := c.UpdateDevice(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDeviceResponse(rsp)
}

// PerformActionWithResponse request returning *PerformActionResponse
func (c *ClientWithResponses) PerformActionWithResponse(ctx context.Context, id string, params *PerformActionParams, reqEditors ...RequestEditorFn) (*PerformActionResponse, error) {
	rsp, err := c.PerformAction(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePerformActionResponse(rsp)
}

// FindInstanceBandwidthWithResponse request returning *FindInstanceBandwidthResponse
func (c *ClientWithResponses) FindInstanceBandwidthWithResponse(ctx context.Context, id string, params *FindInstanceBandwidthParams, reqEditors ...RequestEditorFn) (*FindInstanceBandwidthResponse, error) {
	rsp, err := c.FindInstanceBandwidth(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindInstanceBandwidthResponse(rsp)
}

// GetBgpNeighborDataWithResponse request returning *GetBgpNeighborDataResponse
func (c *ClientWithResponses) GetBgpNeighborDataWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetBgpNeighborDataResponse, error) {
	rsp, err := c.GetBgpNeighborData(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBgpNeighborDataResponse(rsp)
}

// FindBgpSessionsWithResponse request returning *FindBgpSessionsResponse
func (c *ClientWithResponses) FindBgpSessionsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindBgpSessionsResponse, error) {
	rsp, err := c.FindBgpSessions(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindBgpSessionsResponse(rsp)
}

// CreateBgpSessionWithBodyWithResponse request with arbitrary body returning *CreateBgpSessionResponse
func (c *ClientWithResponses) CreateBgpSessionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBgpSessionResponse, error) {
	rsp, err := c.CreateBgpSessionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBgpSessionResponse(rsp)
}

func (c *ClientWithResponses) CreateBgpSessionWithResponse(ctx context.Context, id string, body CreateBgpSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBgpSessionResponse, error) {
	rsp, err := c.CreateBgpSession(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBgpSessionResponse(rsp)
}

// FindDeviceCustomdataWithResponse request returning *FindDeviceCustomdataResponse
func (c *ClientWithResponses) FindDeviceCustomdataWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindDeviceCustomdataResponse, error) {
	rsp, err := c.FindDeviceCustomdata(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindDeviceCustomdataResponse(rsp)
}

// FindDeviceEventsWithResponse request returning *FindDeviceEventsResponse
func (c *ClientWithResponses) FindDeviceEventsWithResponse(ctx context.Context, id string, params *FindDeviceEventsParams, reqEditors ...RequestEditorFn) (*FindDeviceEventsResponse, error) {
	rsp, err := c.FindDeviceEvents(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindDeviceEventsResponse(rsp)
}

// FindIPAssignmentsWithResponse request returning *FindIPAssignmentsResponse
func (c *ClientWithResponses) FindIPAssignmentsWithResponse(ctx context.Context, id string, params *FindIPAssignmentsParams, reqEditors ...RequestEditorFn) (*FindIPAssignmentsResponse, error) {
	rsp, err := c.FindIPAssignments(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindIPAssignmentsResponse(rsp)
}

// CreateIPAssignmentWithBodyWithResponse request with arbitrary body returning *CreateIPAssignmentResponse
func (c *ClientWithResponses) CreateIPAssignmentWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIPAssignmentResponse, error) {
	rsp, err := c.CreateIPAssignmentWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIPAssignmentResponse(rsp)
}

func (c *ClientWithResponses) CreateIPAssignmentWithResponse(ctx context.Context, id string, body CreateIPAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIPAssignmentResponse, error) {
	rsp, err := c.CreateIPAssignment(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIPAssignmentResponse(rsp)
}

// FindDeviceSSHKeysWithResponse request returning *FindDeviceSSHKeysResponse
func (c *ClientWithResponses) FindDeviceSSHKeysWithResponse(ctx context.Context, id string, params *FindDeviceSSHKeysParams, reqEditors ...RequestEditorFn) (*FindDeviceSSHKeysResponse, error) {
	rsp, err := c.FindDeviceSSHKeys(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindDeviceSSHKeysResponse(rsp)
}

// FindTrafficWithBodyWithResponse request with arbitrary body returning *FindTrafficResponse
func (c *ClientWithResponses) FindTrafficWithBodyWithResponse(ctx context.Context, id string, params *FindTrafficParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindTrafficResponse, error) {
	rsp, err := c.FindTrafficWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindTrafficResponse(rsp)
}

func (c *ClientWithResponses) FindTrafficWithResponse(ctx context.Context, id string, params *FindTrafficParams, body FindTrafficJSONRequestBody, reqEditors ...RequestEditorFn) (*FindTrafficResponse, error) {
	rsp, err := c.FindTraffic(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindTrafficResponse(rsp)
}

// FindDeviceUsagesWithResponse request returning *FindDeviceUsagesResponse
func (c *ClientWithResponses) FindDeviceUsagesWithResponse(ctx context.Context, id string, params *FindDeviceUsagesParams, reqEditors ...RequestEditorFn) (*FindDeviceUsagesResponse, error) {
	rsp, err := c.FindDeviceUsages(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindDeviceUsagesResponse(rsp)
}

// FindIPAssignmentCustomdataWithResponse request returning *FindIPAssignmentCustomdataResponse
func (c *ClientWithResponses) FindIPAssignmentCustomdataWithResponse(ctx context.Context, instanceId string, id string, reqEditors ...RequestEditorFn) (*FindIPAssignmentCustomdataResponse, error) {
	rsp, err := c.FindIPAssignmentCustomdata(ctx, instanceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindIPAssignmentCustomdataResponse(rsp)
}

// CreateEmailWithBodyWithResponse request with arbitrary body returning *CreateEmailResponse
func (c *ClientWithResponses) CreateEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEmailResponse, error) {
	rsp, err := c.CreateEmailWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEmailResponse(rsp)
}

func (c *ClientWithResponses) CreateEmailWithResponse(ctx context.Context, body CreateEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEmailResponse, error) {
	rsp, err := c.CreateEmail(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEmailResponse(rsp)
}

// DeleteEmailWithResponse request returning *DeleteEmailResponse
func (c *ClientWithResponses) DeleteEmailWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteEmailResponse, error) {
	rsp, err := c.DeleteEmail(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEmailResponse(rsp)
}

// FindEmailByIdWithResponse request returning *FindEmailByIdResponse
func (c *ClientWithResponses) FindEmailByIdWithResponse(ctx context.Context, id string, params *FindEmailByIdParams, reqEditors ...RequestEditorFn) (*FindEmailByIdResponse, error) {
	rsp, err := c.FindEmailById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindEmailByIdResponse(rsp)
}

// UpdateEmailWithBodyWithResponse request with arbitrary body returning *UpdateEmailResponse
func (c *ClientWithResponses) UpdateEmailWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEmailResponse, error) {
	rsp, err := c.UpdateEmailWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEmailResponse(rsp)
}

func (c *ClientWithResponses) UpdateEmailWithResponse(ctx context.Context, id string, body UpdateEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEmailResponse, error) {
	rsp, err := c.UpdateEmail(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEmailResponse(rsp)
}

// FindEventsWithResponse request returning *FindEventsResponse
func (c *ClientWithResponses) FindEventsWithResponse(ctx context.Context, params *FindEventsParams, reqEditors ...RequestEditorFn) (*FindEventsResponse, error) {
	rsp, err := c.FindEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindEventsResponse(rsp)
}

// FindEventByIdWithResponse request returning *FindEventByIdResponse
func (c *ClientWithResponses) FindEventByIdWithResponse(ctx context.Context, id string, params *FindEventByIdParams, reqEditors ...RequestEditorFn) (*FindEventByIdResponse, error) {
	rsp, err := c.FindEventById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindEventByIdResponse(rsp)
}

// FindFacilitiesWithResponse request returning *FindFacilitiesResponse
func (c *ClientWithResponses) FindFacilitiesWithResponse(ctx context.Context, params *FindFacilitiesParams, reqEditors ...RequestEditorFn) (*FindFacilitiesResponse, error) {
	rsp, err := c.FindFacilities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindFacilitiesResponse(rsp)
}

// FindHardwareReservationByIdWithResponse request returning *FindHardwareReservationByIdResponse
func (c *ClientWithResponses) FindHardwareReservationByIdWithResponse(ctx context.Context, id string, params *FindHardwareReservationByIdParams, reqEditors ...RequestEditorFn) (*FindHardwareReservationByIdResponse, error) {
	rsp, err := c.FindHardwareReservationById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindHardwareReservationByIdResponse(rsp)
}

// MoveHardwareReservationWithBodyWithResponse request with arbitrary body returning *MoveHardwareReservationResponse
func (c *ClientWithResponses) MoveHardwareReservationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MoveHardwareReservationResponse, error) {
	rsp, err := c.MoveHardwareReservationWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMoveHardwareReservationResponse(rsp)
}

func (c *ClientWithResponses) MoveHardwareReservationWithResponse(ctx context.Context, id string, body MoveHardwareReservationJSONRequestBody, reqEditors ...RequestEditorFn) (*MoveHardwareReservationResponse, error) {
	rsp, err := c.MoveHardwareReservation(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMoveHardwareReservationResponse(rsp)
}

// FindIncidentsWithResponse request returning *FindIncidentsResponse
func (c *ClientWithResponses) FindIncidentsWithResponse(ctx context.Context, params *FindIncidentsParams, reqEditors ...RequestEditorFn) (*FindIncidentsResponse, error) {
	rsp, err := c.FindIncidents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindIncidentsResponse(rsp)
}

// FindInvitationsWithResponse request returning *FindInvitationsResponse
func (c *ClientWithResponses) FindInvitationsWithResponse(ctx context.Context, params *FindInvitationsParams, reqEditors ...RequestEditorFn) (*FindInvitationsResponse, error) {
	rsp, err := c.FindInvitations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindInvitationsResponse(rsp)
}

// DeclineInvitationWithResponse request returning *DeclineInvitationResponse
func (c *ClientWithResponses) DeclineInvitationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeclineInvitationResponse, error) {
	rsp, err := c.DeclineInvitation(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeclineInvitationResponse(rsp)
}

// FindInvitationByIdWithResponse request returning *FindInvitationByIdResponse
func (c *ClientWithResponses) FindInvitationByIdWithResponse(ctx context.Context, id string, params *FindInvitationByIdParams, reqEditors ...RequestEditorFn) (*FindInvitationByIdResponse, error) {
	rsp, err := c.FindInvitationById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindInvitationByIdResponse(rsp)
}

// AcceptInvitationWithResponse request returning *AcceptInvitationResponse
func (c *ClientWithResponses) AcceptInvitationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*AcceptInvitationResponse, error) {
	rsp, err := c.AcceptInvitation(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptInvitationResponse(rsp)
}

// DeleteIPAddressWithResponse request returning *DeleteIPAddressResponse
func (c *ClientWithResponses) DeleteIPAddressWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteIPAddressResponse, error) {
	rsp, err := c.DeleteIPAddress(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIPAddressResponse(rsp)
}

// FindIPAddressByIdWithResponse request returning *FindIPAddressByIdResponse
func (c *ClientWithResponses) FindIPAddressByIdWithResponse(ctx context.Context, id string, params *FindIPAddressByIdParams, reqEditors ...RequestEditorFn) (*FindIPAddressByIdResponse, error) {
	rsp, err := c.FindIPAddressById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindIPAddressByIdResponse(rsp)
}

// UpdateIPAddressWithResponse request returning *UpdateIPAddressResponse
func (c *ClientWithResponses) UpdateIPAddressWithResponse(ctx context.Context, id string, params *UpdateIPAddressParams, reqEditors ...RequestEditorFn) (*UpdateIPAddressResponse, error) {
	rsp, err := c.UpdateIPAddress(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIPAddressResponse(rsp)
}

// FindIPAvailabilitiesWithResponse request returning *FindIPAvailabilitiesResponse
func (c *ClientWithResponses) FindIPAvailabilitiesWithResponse(ctx context.Context, id string, params *FindIPAvailabilitiesParams, reqEditors ...RequestEditorFn) (*FindIPAvailabilitiesResponse, error) {
	rsp, err := c.FindIPAvailabilities(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindIPAvailabilitiesResponse(rsp)
}

// FindIPAddressCustomdataWithResponse request returning *FindIPAddressCustomdataResponse
func (c *ClientWithResponses) FindIPAddressCustomdataWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindIPAddressCustomdataResponse, error) {
	rsp, err := c.FindIPAddressCustomdata(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindIPAddressCustomdataResponse(rsp)
}

// DeleteLicenseWithResponse request returning *DeleteLicenseResponse
func (c *ClientWithResponses) DeleteLicenseWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLicenseResponse, error) {
	rsp, err := c.DeleteLicense(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLicenseResponse(rsp)
}

// FindLicenseByIdWithResponse request returning *FindLicenseByIdResponse
func (c *ClientWithResponses) FindLicenseByIdWithResponse(ctx context.Context, id string, params *FindLicenseByIdParams, reqEditors ...RequestEditorFn) (*FindLicenseByIdResponse, error) {
	rsp, err := c.FindLicenseById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindLicenseByIdResponse(rsp)
}

// UpdateLicenseWithBodyWithResponse request with arbitrary body returning *UpdateLicenseResponse
func (c *ClientWithResponses) UpdateLicenseWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLicenseResponse, error) {
	rsp, err := c.UpdateLicenseWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLicenseResponse(rsp)
}

func (c *ClientWithResponses) UpdateLicenseWithResponse(ctx context.Context, id string, body UpdateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLicenseResponse, error) {
	rsp, err := c.UpdateLicense(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLicenseResponse(rsp)
}

// FindMetrosWithResponse request returning *FindMetrosResponse
func (c *ClientWithResponses) FindMetrosWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindMetrosResponse, error) {
	rsp, err := c.FindMetros(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindMetrosResponse(rsp)
}

// GetMetroWithResponse request returning *GetMetroResponse
func (c *ClientWithResponses) GetMetroWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetMetroResponse, error) {
	rsp, err := c.GetMetro(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetroResponse(rsp)
}

// FindSpotMarketPricesWithResponse request returning *FindSpotMarketPricesResponse
func (c *ClientWithResponses) FindSpotMarketPricesWithResponse(ctx context.Context, params *FindSpotMarketPricesParams, reqEditors ...RequestEditorFn) (*FindSpotMarketPricesResponse, error) {
	rsp, err := c.FindSpotMarketPrices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindSpotMarketPricesResponse(rsp)
}

// FindSpotMarketPricesHistoryWithResponse request returning *FindSpotMarketPricesHistoryResponse
func (c *ClientWithResponses) FindSpotMarketPricesHistoryWithResponse(ctx context.Context, params *FindSpotMarketPricesHistoryParams, reqEditors ...RequestEditorFn) (*FindSpotMarketPricesHistoryResponse, error) {
	rsp, err := c.FindSpotMarketPricesHistory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindSpotMarketPricesHistoryResponse(rsp)
}

// FindMetroSpotMarketPricesWithResponse request returning *FindMetroSpotMarketPricesResponse
func (c *ClientWithResponses) FindMetroSpotMarketPricesWithResponse(ctx context.Context, params *FindMetroSpotMarketPricesParams, reqEditors ...RequestEditorFn) (*FindMetroSpotMarketPricesResponse, error) {
	rsp, err := c.FindMetroSpotMarketPrices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindMetroSpotMarketPricesResponse(rsp)
}

// DeleteMembershipWithResponse request returning *DeleteMembershipResponse
func (c *ClientWithResponses) DeleteMembershipWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteMembershipResponse, error) {
	rsp, err := c.DeleteMembership(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMembershipResponse(rsp)
}

// FindMembershipByIdWithResponse request returning *FindMembershipByIdResponse
func (c *ClientWithResponses) FindMembershipByIdWithResponse(ctx context.Context, id string, params *FindMembershipByIdParams, reqEditors ...RequestEditorFn) (*FindMembershipByIdResponse, error) {
	rsp, err := c.FindMembershipById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindMembershipByIdResponse(rsp)
}

// UpdateMembershipWithBodyWithResponse request with arbitrary body returning *UpdateMembershipResponse
func (c *ClientWithResponses) UpdateMembershipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMembershipResponse, error) {
	rsp, err := c.UpdateMembershipWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMembershipResponse(rsp)
}

func (c *ClientWithResponses) UpdateMembershipWithResponse(ctx context.Context, id string, body UpdateMembershipJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMembershipResponse, error) {
	rsp, err := c.UpdateMembership(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMembershipResponse(rsp)
}

// DeleteMetalGatewayWithResponse request returning *DeleteMetalGatewayResponse
func (c *ClientWithResponses) DeleteMetalGatewayWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteMetalGatewayResponse, error) {
	rsp, err := c.DeleteMetalGateway(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMetalGatewayResponse(rsp)
}

// FindMetalGatewayByIdWithResponse request returning *FindMetalGatewayByIdResponse
func (c *ClientWithResponses) FindMetalGatewayByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindMetalGatewayByIdResponse, error) {
	rsp, err := c.FindMetalGatewayById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindMetalGatewayByIdResponse(rsp)
}

// FindOperatingSystemVersionWithResponse request returning *FindOperatingSystemVersionResponse
func (c *ClientWithResponses) FindOperatingSystemVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindOperatingSystemVersionResponse, error) {
	rsp, err := c.FindOperatingSystemVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOperatingSystemVersionResponse(rsp)
}

// FindOperatingSystemsWithResponse request returning *FindOperatingSystemsResponse
func (c *ClientWithResponses) FindOperatingSystemsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindOperatingSystemsResponse, error) {
	rsp, err := c.FindOperatingSystems(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOperatingSystemsResponse(rsp)
}

// FindOrganizationsWithResponse request returning *FindOrganizationsResponse
func (c *ClientWithResponses) FindOrganizationsWithResponse(ctx context.Context, params *FindOrganizationsParams, reqEditors ...RequestEditorFn) (*FindOrganizationsResponse, error) {
	rsp, err := c.FindOrganizations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOrganizationsResponse(rsp)
}

// CreateOrganizationWithBodyWithResponse request with arbitrary body returning *CreateOrganizationResponse
func (c *ClientWithResponses) CreateOrganizationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrganizationResponse, error) {
	rsp, err := c.CreateOrganizationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrganizationResponse(rsp)
}

func (c *ClientWithResponses) CreateOrganizationWithResponse(ctx context.Context, body CreateOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrganizationResponse, error) {
	rsp, err := c.CreateOrganization(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrganizationResponse(rsp)
}

// DeleteOrganizationWithResponse request returning *DeleteOrganizationResponse
func (c *ClientWithResponses) DeleteOrganizationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteOrganizationResponse, error) {
	rsp, err := c.DeleteOrganization(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrganizationResponse(rsp)
}

// FindOrganizationByIdWithResponse request returning *FindOrganizationByIdResponse
func (c *ClientWithResponses) FindOrganizationByIdWithResponse(ctx context.Context, id string, params *FindOrganizationByIdParams, reqEditors ...RequestEditorFn) (*FindOrganizationByIdResponse, error) {
	rsp, err := c.FindOrganizationById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOrganizationByIdResponse(rsp)
}

// UpdateOrganizationWithBodyWithResponse request with arbitrary body returning *UpdateOrganizationResponse
func (c *ClientWithResponses) UpdateOrganizationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrganizationResponse, error) {
	rsp, err := c.UpdateOrganizationWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrganizationResponse(rsp)
}

func (c *ClientWithResponses) UpdateOrganizationWithResponse(ctx context.Context, id string, body UpdateOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrganizationResponse, error) {
	rsp, err := c.UpdateOrganization(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrganizationResponse(rsp)
}

// FindOrganizationCapacityPerFacilityWithResponse request returning *FindOrganizationCapacityPerFacilityResponse
func (c *ClientWithResponses) FindOrganizationCapacityPerFacilityWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindOrganizationCapacityPerFacilityResponse, error) {
	rsp, err := c.FindOrganizationCapacityPerFacility(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOrganizationCapacityPerFacilityResponse(rsp)
}

// FindOrganizationCapacityPerMetroWithResponse request returning *FindOrganizationCapacityPerMetroResponse
func (c *ClientWithResponses) FindOrganizationCapacityPerMetroWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindOrganizationCapacityPerMetroResponse, error) {
	rsp, err := c.FindOrganizationCapacityPerMetro(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOrganizationCapacityPerMetroResponse(rsp)
}

// FindOrganizationCustomdataWithResponse request returning *FindOrganizationCustomdataResponse
func (c *ClientWithResponses) FindOrganizationCustomdataWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindOrganizationCustomdataResponse, error) {
	rsp, err := c.FindOrganizationCustomdata(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOrganizationCustomdataResponse(rsp)
}

// FindOrganizationDevicesWithResponse request returning *FindOrganizationDevicesResponse
func (c *ClientWithResponses) FindOrganizationDevicesWithResponse(ctx context.Context, id string, params *FindOrganizationDevicesParams, reqEditors ...RequestEditorFn) (*FindOrganizationDevicesResponse, error) {
	rsp, err := c.FindOrganizationDevices(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOrganizationDevicesResponse(rsp)
}

// FindOrganizationEventsWithResponse request returning *FindOrganizationEventsResponse
func (c *ClientWithResponses) FindOrganizationEventsWithResponse(ctx context.Context, id string, params *FindOrganizationEventsParams, reqEditors ...RequestEditorFn) (*FindOrganizationEventsResponse, error) {
	rsp, err := c.FindOrganizationEvents(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOrganizationEventsResponse(rsp)
}

// FindFacilitiesByOrganizationWithResponse request returning *FindFacilitiesByOrganizationResponse
func (c *ClientWithResponses) FindFacilitiesByOrganizationWithResponse(ctx context.Context, id string, params *FindFacilitiesByOrganizationParams, reqEditors ...RequestEditorFn) (*FindFacilitiesByOrganizationResponse, error) {
	rsp, err := c.FindFacilitiesByOrganization(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindFacilitiesByOrganizationResponse(rsp)
}

// FindOrganizationInvitationsWithResponse request returning *FindOrganizationInvitationsResponse
func (c *ClientWithResponses) FindOrganizationInvitationsWithResponse(ctx context.Context, id string, params *FindOrganizationInvitationsParams, reqEditors ...RequestEditorFn) (*FindOrganizationInvitationsResponse, error) {
	rsp, err := c.FindOrganizationInvitations(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOrganizationInvitationsResponse(rsp)
}

// CreateOrganizationInvitationWithBodyWithResponse request with arbitrary body returning *CreateOrganizationInvitationResponse
func (c *ClientWithResponses) CreateOrganizationInvitationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrganizationInvitationResponse, error) {
	rsp, err := c.CreateOrganizationInvitationWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrganizationInvitationResponse(rsp)
}

func (c *ClientWithResponses) CreateOrganizationInvitationWithResponse(ctx context.Context, id string, body CreateOrganizationInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrganizationInvitationResponse, error) {
	rsp, err := c.CreateOrganizationInvitation(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrganizationInvitationResponse(rsp)
}

// FindOperatingSystemsByOrganizationWithResponse request returning *FindOperatingSystemsByOrganizationResponse
func (c *ClientWithResponses) FindOperatingSystemsByOrganizationWithResponse(ctx context.Context, id string, params *FindOperatingSystemsByOrganizationParams, reqEditors ...RequestEditorFn) (*FindOperatingSystemsByOrganizationResponse, error) {
	rsp, err := c.FindOperatingSystemsByOrganization(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOperatingSystemsByOrganizationResponse(rsp)
}

// FindOrganizationPaymentMethodsWithResponse request returning *FindOrganizationPaymentMethodsResponse
func (c *ClientWithResponses) FindOrganizationPaymentMethodsWithResponse(ctx context.Context, id string, params *FindOrganizationPaymentMethodsParams, reqEditors ...RequestEditorFn) (*FindOrganizationPaymentMethodsResponse, error) {
	rsp, err := c.FindOrganizationPaymentMethods(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOrganizationPaymentMethodsResponse(rsp)
}

// CreatePaymentMethodWithBodyWithResponse request with arbitrary body returning *CreatePaymentMethodResponse
func (c *ClientWithResponses) CreatePaymentMethodWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePaymentMethodResponse, error) {
	rsp, err := c.CreatePaymentMethodWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePaymentMethodResponse(rsp)
}

func (c *ClientWithResponses) CreatePaymentMethodWithResponse(ctx context.Context, id string, body CreatePaymentMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePaymentMethodResponse, error) {
	rsp, err := c.CreatePaymentMethod(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePaymentMethodResponse(rsp)
}

// FindPlansByOrganizationWithResponse request returning *FindPlansByOrganizationResponse
func (c *ClientWithResponses) FindPlansByOrganizationWithResponse(ctx context.Context, id string, params *FindPlansByOrganizationParams, reqEditors ...RequestEditorFn) (*FindPlansByOrganizationResponse, error) {
	rsp, err := c.FindPlansByOrganization(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindPlansByOrganizationResponse(rsp)
}

// FindOrganizationProjectsWithResponse request returning *FindOrganizationProjectsResponse
func (c *ClientWithResponses) FindOrganizationProjectsWithResponse(ctx context.Context, id string, params *FindOrganizationProjectsParams, reqEditors ...RequestEditorFn) (*FindOrganizationProjectsResponse, error) {
	rsp, err := c.FindOrganizationProjects(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOrganizationProjectsResponse(rsp)
}

// CreateOrganizationProjectWithBodyWithResponse request with arbitrary body returning *CreateOrganizationProjectResponse
func (c *ClientWithResponses) CreateOrganizationProjectWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrganizationProjectResponse, error) {
	rsp, err := c.CreateOrganizationProjectWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrganizationProjectResponse(rsp)
}

func (c *ClientWithResponses) CreateOrganizationProjectWithResponse(ctx context.Context, id string, body CreateOrganizationProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrganizationProjectResponse, error) {
	rsp, err := c.CreateOrganizationProject(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrganizationProjectResponse(rsp)
}

// FindOrganizationTransfersWithResponse request returning *FindOrganizationTransfersResponse
func (c *ClientWithResponses) FindOrganizationTransfersWithResponse(ctx context.Context, id string, params *FindOrganizationTransfersParams, reqEditors ...RequestEditorFn) (*FindOrganizationTransfersResponse, error) {
	rsp, err := c.FindOrganizationTransfers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindOrganizationTransfersResponse(rsp)
}

// OrganizationListInterconnectionsWithResponse request returning *OrganizationListInterconnectionsResponse
func (c *ClientWithResponses) OrganizationListInterconnectionsWithResponse(ctx context.Context, organizationId string, reqEditors ...RequestEditorFn) (*OrganizationListInterconnectionsResponse, error) {
	rsp, err := c.OrganizationListInterconnections(ctx, organizationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrganizationListInterconnectionsResponse(rsp)
}

// CreateOrganizationInterconnectionWithBodyWithResponse request with arbitrary body returning *CreateOrganizationInterconnectionResponse
func (c *ClientWithResponses) CreateOrganizationInterconnectionWithBodyWithResponse(ctx context.Context, organizationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrganizationInterconnectionResponse, error) {
	rsp, err := c.CreateOrganizationInterconnectionWithBody(ctx, organizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrganizationInterconnectionResponse(rsp)
}

func (c *ClientWithResponses) CreateOrganizationInterconnectionWithResponse(ctx context.Context, organizationId string, body CreateOrganizationInterconnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrganizationInterconnectionResponse, error) {
	rsp, err := c.CreateOrganizationInterconnection(ctx, organizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrganizationInterconnectionResponse(rsp)
}

// DeletePaymentMethodWithResponse request returning *DeletePaymentMethodResponse
func (c *ClientWithResponses) DeletePaymentMethodWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePaymentMethodResponse, error) {
	rsp, err := c.DeletePaymentMethod(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePaymentMethodResponse(rsp)
}

// FindPaymentMethodByIdWithResponse request returning *FindPaymentMethodByIdResponse
func (c *ClientWithResponses) FindPaymentMethodByIdWithResponse(ctx context.Context, id string, params *FindPaymentMethodByIdParams, reqEditors ...RequestEditorFn) (*FindPaymentMethodByIdResponse, error) {
	rsp, err := c.FindPaymentMethodById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindPaymentMethodByIdResponse(rsp)
}

// UpdatePaymentMethodWithBodyWithResponse request with arbitrary body returning *UpdatePaymentMethodResponse
func (c *ClientWithResponses) UpdatePaymentMethodWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePaymentMethodResponse, error) {
	rsp, err := c.UpdatePaymentMethodWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePaymentMethodResponse(rsp)
}

func (c *ClientWithResponses) UpdatePaymentMethodWithResponse(ctx context.Context, id string, body UpdatePaymentMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePaymentMethodResponse, error) {
	rsp, err := c.UpdatePaymentMethod(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePaymentMethodResponse(rsp)
}

// FindPlansWithResponse request returning *FindPlansResponse
func (c *ClientWithResponses) FindPlansWithResponse(ctx context.Context, params *FindPlansParams, reqEditors ...RequestEditorFn) (*FindPlansResponse, error) {
	rsp, err := c.FindPlans(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindPlansResponse(rsp)
}

// FindPortByIdWithResponse request returning *FindPortByIdResponse
func (c *ClientWithResponses) FindPortByIdWithResponse(ctx context.Context, id string, params *FindPortByIdParams, reqEditors ...RequestEditorFn) (*FindPortByIdResponse, error) {
	rsp, err := c.FindPortById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindPortByIdResponse(rsp)
}

// AssignPortWithBodyWithResponse request with arbitrary body returning *AssignPortResponse
func (c *ClientWithResponses) AssignPortWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignPortResponse, error) {
	rsp, err := c.AssignPortWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignPortResponse(rsp)
}

func (c *ClientWithResponses) AssignPortWithResponse(ctx context.Context, id string, body AssignPortJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignPortResponse, error) {
	rsp, err := c.AssignPort(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignPortResponse(rsp)
}

// BondPortWithResponse request returning *BondPortResponse
func (c *ClientWithResponses) BondPortWithResponse(ctx context.Context, id string, params *BondPortParams, reqEditors ...RequestEditorFn) (*BondPortResponse, error) {
	rsp, err := c.BondPort(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBondPortResponse(rsp)
}

// ConvertLayer2WithBodyWithResponse request with arbitrary body returning *ConvertLayer2Response
func (c *ClientWithResponses) ConvertLayer2WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConvertLayer2Response, error) {
	rsp, err := c.ConvertLayer2WithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConvertLayer2Response(rsp)
}

func (c *ClientWithResponses) ConvertLayer2WithResponse(ctx context.Context, id string, body ConvertLayer2JSONRequestBody, reqEditors ...RequestEditorFn) (*ConvertLayer2Response, error) {
	rsp, err := c.ConvertLayer2(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConvertLayer2Response(rsp)
}

// ConvertLayer3WithBodyWithResponse request with arbitrary body returning *ConvertLayer3Response
func (c *ClientWithResponses) ConvertLayer3WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConvertLayer3Response, error) {
	rsp, err := c.ConvertLayer3WithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConvertLayer3Response(rsp)
}

func (c *ClientWithResponses) ConvertLayer3WithResponse(ctx context.Context, id string, body ConvertLayer3JSONRequestBody, reqEditors ...RequestEditorFn) (*ConvertLayer3Response, error) {
	rsp, err := c.ConvertLayer3(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConvertLayer3Response(rsp)
}

// DisbondPortWithResponse request returning *DisbondPortResponse
func (c *ClientWithResponses) DisbondPortWithResponse(ctx context.Context, id string, params *DisbondPortParams, reqEditors ...RequestEditorFn) (*DisbondPortResponse, error) {
	rsp, err := c.DisbondPort(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisbondPortResponse(rsp)
}

// DeleteNativeVlanWithResponse request returning *DeleteNativeVlanResponse
func (c *ClientWithResponses) DeleteNativeVlanWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteNativeVlanResponse, error) {
	rsp, err := c.DeleteNativeVlan(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNativeVlanResponse(rsp)
}

// AssignNativeVlanWithResponse request returning *AssignNativeVlanResponse
func (c *ClientWithResponses) AssignNativeVlanWithResponse(ctx context.Context, id string, params *AssignNativeVlanParams, reqEditors ...RequestEditorFn) (*AssignNativeVlanResponse, error) {
	rsp, err := c.AssignNativeVlan(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignNativeVlanResponse(rsp)
}

// UnassignPortWithBodyWithResponse request with arbitrary body returning *UnassignPortResponse
func (c *ClientWithResponses) UnassignPortWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnassignPortResponse, error) {
	rsp, err := c.UnassignPortWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignPortResponse(rsp)
}

func (c *ClientWithResponses) UnassignPortWithResponse(ctx context.Context, id string, body UnassignPortJSONRequestBody, reqEditors ...RequestEditorFn) (*UnassignPortResponse, error) {
	rsp, err := c.UnassignPort(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignPortResponse(rsp)
}

// FindPortVlanAssignmentsWithResponse request returning *FindPortVlanAssignmentsResponse
func (c *ClientWithResponses) FindPortVlanAssignmentsWithResponse(ctx context.Context, id string, params *FindPortVlanAssignmentsParams, reqEditors ...RequestEditorFn) (*FindPortVlanAssignmentsResponse, error) {
	rsp, err := c.FindPortVlanAssignments(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindPortVlanAssignmentsResponse(rsp)
}

// FindPortVlanAssignmentBatchesWithResponse request returning *FindPortVlanAssignmentBatchesResponse
func (c *ClientWithResponses) FindPortVlanAssignmentBatchesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindPortVlanAssignmentBatchesResponse, error) {
	rsp, err := c.FindPortVlanAssignmentBatches(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindPortVlanAssignmentBatchesResponse(rsp)
}

// CreatePortVlanAssignmentBatchWithBodyWithResponse request with arbitrary body returning *CreatePortVlanAssignmentBatchResponse
func (c *ClientWithResponses) CreatePortVlanAssignmentBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePortVlanAssignmentBatchResponse, error) {
	rsp, err := c.CreatePortVlanAssignmentBatchWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePortVlanAssignmentBatchResponse(rsp)
}

func (c *ClientWithResponses) CreatePortVlanAssignmentBatchWithResponse(ctx context.Context, id string, body CreatePortVlanAssignmentBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePortVlanAssignmentBatchResponse, error) {
	rsp, err := c.CreatePortVlanAssignmentBatch(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePortVlanAssignmentBatchResponse(rsp)
}

// FindPortVlanAssignmentBatchByPortIdAndBatchIdWithResponse request returning *FindPortVlanAssignmentBatchByPortIdAndBatchIdResponse
func (c *ClientWithResponses) FindPortVlanAssignmentBatchByPortIdAndBatchIdWithResponse(ctx context.Context, id string, batchId string, reqEditors ...RequestEditorFn) (*FindPortVlanAssignmentBatchByPortIdAndBatchIdResponse, error) {
	rsp, err := c.FindPortVlanAssignmentBatchByPortIdAndBatchId(ctx, id, batchId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindPortVlanAssignmentBatchByPortIdAndBatchIdResponse(rsp)
}

// FindPortVlanAssignmentByPortIdAndAssignmentIdWithResponse request returning *FindPortVlanAssignmentByPortIdAndAssignmentIdResponse
func (c *ClientWithResponses) FindPortVlanAssignmentByPortIdAndAssignmentIdWithResponse(ctx context.Context, id string, assignmentId string, params *FindPortVlanAssignmentByPortIdAndAssignmentIdParams, reqEditors ...RequestEditorFn) (*FindPortVlanAssignmentByPortIdAndAssignmentIdResponse, error) {
	rsp, err := c.FindPortVlanAssignmentByPortIdAndAssignmentId(ctx, id, assignmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindPortVlanAssignmentByPortIdAndAssignmentIdResponse(rsp)
}

// FindProjectsWithResponse request returning *FindProjectsResponse
func (c *ClientWithResponses) FindProjectsWithResponse(ctx context.Context, params *FindProjectsParams, reqEditors ...RequestEditorFn) (*FindProjectsResponse, error) {
	rsp, err := c.FindProjects(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindProjectsResponse(rsp)
}

// CreateProjectWithBodyWithResponse request with arbitrary body returning *CreateProjectResponse
func (c *ClientWithResponses) CreateProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error) {
	rsp, err := c.CreateProjectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectWithResponse(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error) {
	rsp, err := c.CreateProject(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResponse(rsp)
}

// DeleteProjectWithResponse request returning *DeleteProjectResponse
func (c *ClientWithResponses) DeleteProjectWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteProjectResponse, error) {
	rsp, err := c.DeleteProject(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectResponse(rsp)
}

// FindProjectByIdWithResponse request returning *FindProjectByIdResponse
func (c *ClientWithResponses) FindProjectByIdWithResponse(ctx context.Context, id string, params *FindProjectByIdParams, reqEditors ...RequestEditorFn) (*FindProjectByIdResponse, error) {
	rsp, err := c.FindProjectById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindProjectByIdResponse(rsp)
}

// UpdateProjectWithBodyWithResponse request with arbitrary body returning *UpdateProjectResponse
func (c *ClientWithResponses) UpdateProjectWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error) {
	rsp, err := c.UpdateProjectWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectWithResponse(ctx context.Context, id string, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error) {
	rsp, err := c.UpdateProject(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectResponse(rsp)
}

// FindProjectAPIKeysWithResponse request returning *FindProjectAPIKeysResponse
func (c *ClientWithResponses) FindProjectAPIKeysWithResponse(ctx context.Context, id string, params *FindProjectAPIKeysParams, reqEditors ...RequestEditorFn) (*FindProjectAPIKeysResponse, error) {
	rsp, err := c.FindProjectAPIKeys(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindProjectAPIKeysResponse(rsp)
}

// CreateProjectAPIKeyWithBodyWithResponse request with arbitrary body returning *CreateProjectAPIKeyResponse
func (c *ClientWithResponses) CreateProjectAPIKeyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectAPIKeyResponse, error) {
	rsp, err := c.CreateProjectAPIKeyWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectAPIKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectAPIKeyWithResponse(ctx context.Context, id string, body CreateProjectAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectAPIKeyResponse, error) {
	rsp, err := c.CreateProjectAPIKey(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectAPIKeyResponse(rsp)
}

// FindBatchesByProjectWithResponse request returning *FindBatchesByProjectResponse
func (c *ClientWithResponses) FindBatchesByProjectWithResponse(ctx context.Context, id string, params *FindBatchesByProjectParams, reqEditors ...RequestEditorFn) (*FindBatchesByProjectResponse, error) {
	rsp, err := c.FindBatchesByProject(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindBatchesByProjectResponse(rsp)
}

// FindBgpConfigByProjectWithResponse request returning *FindBgpConfigByProjectResponse
func (c *ClientWithResponses) FindBgpConfigByProjectWithResponse(ctx context.Context, id string, params *FindBgpConfigByProjectParams, reqEditors ...RequestEditorFn) (*FindBgpConfigByProjectResponse, error) {
	rsp, err := c.FindBgpConfigByProject(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindBgpConfigByProjectResponse(rsp)
}

// RequestBgpConfigWithBodyWithResponse request with arbitrary body returning *RequestBgpConfigResponse
func (c *ClientWithResponses) RequestBgpConfigWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestBgpConfigResponse, error) {
	rsp, err := c.RequestBgpConfigWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestBgpConfigResponse(rsp)
}

func (c *ClientWithResponses) RequestBgpConfigWithResponse(ctx context.Context, id string, body RequestBgpConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestBgpConfigResponse, error) {
	rsp, err := c.RequestBgpConfig(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestBgpConfigResponse(rsp)
}

// FindProjectBgpSessionsWithResponse request returning *FindProjectBgpSessionsResponse
func (c *ClientWithResponses) FindProjectBgpSessionsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindProjectBgpSessionsResponse, error) {
	rsp, err := c.FindProjectBgpSessions(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindProjectBgpSessionsResponse(rsp)
}

// FindProjectCustomdataWithResponse request returning *FindProjectCustomdataResponse
func (c *ClientWithResponses) FindProjectCustomdataWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindProjectCustomdataResponse, error) {
	rsp, err := c.FindProjectCustomdata(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindProjectCustomdataResponse(rsp)
}

// FindProjectDevicesWithResponse request returning *FindProjectDevicesResponse
func (c *ClientWithResponses) FindProjectDevicesWithResponse(ctx context.Context, id string, params *FindProjectDevicesParams, reqEditors ...RequestEditorFn) (*FindProjectDevicesResponse, error) {
	rsp, err := c.FindProjectDevices(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindProjectDevicesResponse(rsp)
}

// CreateDeviceWithBodyWithResponse request with arbitrary body returning *CreateDeviceResponse
func (c *ClientWithResponses) CreateDeviceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeviceResponse, error) {
	rsp, err := c.CreateDeviceWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeviceResponse(rsp)
}

func (c *ClientWithResponses) CreateDeviceWithResponse(ctx context.Context, id string, body CreateDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeviceResponse, error) {
	rsp, err := c.CreateDevice(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeviceResponse(rsp)
}

// CreateDeviceBatchWithBodyWithResponse request with arbitrary body returning *CreateDeviceBatchResponse
func (c *ClientWithResponses) CreateDeviceBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeviceBatchResponse, error) {
	rsp, err := c.CreateDeviceBatchWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeviceBatchResponse(rsp)
}

func (c *ClientWithResponses) CreateDeviceBatchWithResponse(ctx context.Context, id string, body CreateDeviceBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeviceBatchResponse, error) {
	rsp, err := c.CreateDeviceBatch(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeviceBatchResponse(rsp)
}

// FindProjectEventsWithResponse request returning *FindProjectEventsResponse
func (c *ClientWithResponses) FindProjectEventsWithResponse(ctx context.Context, id string, params *FindProjectEventsParams, reqEditors ...RequestEditorFn) (*FindProjectEventsResponse, error) {
	rsp, err := c.FindProjectEvents(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindProjectEventsResponse(rsp)
}

// FindFacilitiesByProjectWithResponse request returning *FindFacilitiesByProjectResponse
func (c *ClientWithResponses) FindFacilitiesByProjectWithResponse(ctx context.Context, id string, params *FindFacilitiesByProjectParams, reqEditors ...RequestEditorFn) (*FindFacilitiesByProjectResponse, error) {
	rsp, err := c.FindFacilitiesByProject(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindFacilitiesByProjectResponse(rsp)
}

// FindGlobalBgpRangesWithResponse request returning *FindGlobalBgpRangesResponse
func (c *ClientWithResponses) FindGlobalBgpRangesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindGlobalBgpRangesResponse, error) {
	rsp, err := c.FindGlobalBgpRanges(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindGlobalBgpRangesResponse(rsp)
}

// FindProjectHardwareReservationsWithResponse request returning *FindProjectHardwareReservationsResponse
func (c *ClientWithResponses) FindProjectHardwareReservationsWithResponse(ctx context.Context, id string, params *FindProjectHardwareReservationsParams, reqEditors ...RequestEditorFn) (*FindProjectHardwareReservationsResponse, error) {
	rsp, err := c.FindProjectHardwareReservations(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindProjectHardwareReservationsResponse(rsp)
}

// FindIPReservationsWithResponse request returning *FindIPReservationsResponse
func (c *ClientWithResponses) FindIPReservationsWithResponse(ctx context.Context, id string, params *FindIPReservationsParams, reqEditors ...RequestEditorFn) (*FindIPReservationsResponse, error) {
	rsp, err := c.FindIPReservations(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindIPReservationsResponse(rsp)
}

// RequestIPReservationWithBodyWithResponse request with arbitrary body returning *RequestIPReservationResponse
func (c *ClientWithResponses) RequestIPReservationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestIPReservationResponse, error) {
	rsp, err := c.RequestIPReservationWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestIPReservationResponse(rsp)
}

func (c *ClientWithResponses) RequestIPReservationWithResponse(ctx context.Context, id string, body RequestIPReservationJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestIPReservationResponse, error) {
	rsp, err := c.RequestIPReservation(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestIPReservationResponse(rsp)
}

// FindProjectLicensesWithResponse request returning *FindProjectLicensesResponse
func (c *ClientWithResponses) FindProjectLicensesWithResponse(ctx context.Context, id string, params *FindProjectLicensesParams, reqEditors ...RequestEditorFn) (*FindProjectLicensesResponse, error) {
	rsp, err := c.FindProjectLicenses(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindProjectLicensesResponse(rsp)
}

// CreateLicenseWithBodyWithResponse request with arbitrary body returning *CreateLicenseResponse
func (c *ClientWithResponses) CreateLicenseWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLicenseResponse, error) {
	rsp, err := c.CreateLicenseWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLicenseResponse(rsp)
}

func (c *ClientWithResponses) CreateLicenseWithResponse(ctx context.Context, id string, body CreateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLicenseResponse, error) {
	rsp, err := c.CreateLicense(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLicenseResponse(rsp)
}

// FindPlansByProjectWithResponse request returning *FindPlansByProjectResponse
func (c *ClientWithResponses) FindPlansByProjectWithResponse(ctx context.Context, id string, params *FindPlansByProjectParams, reqEditors ...RequestEditorFn) (*FindPlansByProjectResponse, error) {
	rsp, err := c.FindPlansByProject(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindPlansByProjectResponse(rsp)
}

// ListSpotMarketRequestsWithResponse request returning *ListSpotMarketRequestsResponse
func (c *ClientWithResponses) ListSpotMarketRequestsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ListSpotMarketRequestsResponse, error) {
	rsp, err := c.ListSpotMarketRequests(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSpotMarketRequestsResponse(rsp)
}

// CreateSpotMarketRequestWithBodyWithResponse request with arbitrary body returning *CreateSpotMarketRequestResponse
func (c *ClientWithResponses) CreateSpotMarketRequestWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpotMarketRequestResponse, error) {
	rsp, err := c.CreateSpotMarketRequestWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpotMarketRequestResponse(rsp)
}

func (c *ClientWithResponses) CreateSpotMarketRequestWithResponse(ctx context.Context, id string, body CreateSpotMarketRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpotMarketRequestResponse, error) {
	rsp, err := c.CreateSpotMarketRequest(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpotMarketRequestResponse(rsp)
}

// FindProjectSSHKeysWithResponse request returning *FindProjectSSHKeysResponse
func (c *ClientWithResponses) FindProjectSSHKeysWithResponse(ctx context.Context, id string, params *FindProjectSSHKeysParams, reqEditors ...RequestEditorFn) (*FindProjectSSHKeysResponse, error) {
	rsp, err := c.FindProjectSSHKeys(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindProjectSSHKeysResponse(rsp)
}

// CreateProjectSSHKeyWithBodyWithResponse request with arbitrary body returning *CreateProjectSSHKeyResponse
func (c *ClientWithResponses) CreateProjectSSHKeyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectSSHKeyResponse, error) {
	rsp, err := c.CreateProjectSSHKeyWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectSSHKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectSSHKeyWithResponse(ctx context.Context, id string, body CreateProjectSSHKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectSSHKeyResponse, error) {
	rsp, err := c.CreateProjectSSHKey(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectSSHKeyResponse(rsp)
}

// FindVolumesWithResponse request returning *FindVolumesResponse
func (c *ClientWithResponses) FindVolumesWithResponse(ctx context.Context, id string, params *FindVolumesParams, reqEditors ...RequestEditorFn) (*FindVolumesResponse, error) {
	rsp, err := c.FindVolumes(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindVolumesResponse(rsp)
}

// CreateVolumeWithBodyWithResponse request with arbitrary body returning *CreateVolumeResponse
func (c *ClientWithResponses) CreateVolumeWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error) {
	rsp, err := c.CreateVolumeWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeResponse(rsp)
}

func (c *ClientWithResponses) CreateVolumeWithResponse(ctx context.Context, id string, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error) {
	rsp, err := c.CreateVolume(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeResponse(rsp)
}

// CreateTransferRequestWithBodyWithResponse request with arbitrary body returning *CreateTransferRequestResponse
func (c *ClientWithResponses) CreateTransferRequestWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTransferRequestResponse, error) {
	rsp, err := c.CreateTransferRequestWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTransferRequestResponse(rsp)
}

func (c *ClientWithResponses) CreateTransferRequestWithResponse(ctx context.Context, id string, body CreateTransferRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTransferRequestResponse, error) {
	rsp, err := c.CreateTransferRequest(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTransferRequestResponse(rsp)
}

// FindProjectUsageWithResponse request returning *FindProjectUsageResponse
func (c *ClientWithResponses) FindProjectUsageWithResponse(ctx context.Context, id string, params *FindProjectUsageParams, reqEditors ...RequestEditorFn) (*FindProjectUsageResponse, error) {
	rsp, err := c.FindProjectUsage(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindProjectUsageResponse(rsp)
}

// FindVirtualNetworksWithResponse request returning *FindVirtualNetworksResponse
func (c *ClientWithResponses) FindVirtualNetworksWithResponse(ctx context.Context, id string, params *FindVirtualNetworksParams, reqEditors ...RequestEditorFn) (*FindVirtualNetworksResponse, error) {
	rsp, err := c.FindVirtualNetworks(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindVirtualNetworksResponse(rsp)
}

// CreateVirtualNetworkWithBodyWithResponse request with arbitrary body returning *CreateVirtualNetworkResponse
func (c *ClientWithResponses) CreateVirtualNetworkWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualNetworkResponse, error) {
	rsp, err := c.CreateVirtualNetworkWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualNetworkResponse(rsp)
}

func (c *ClientWithResponses) CreateVirtualNetworkWithResponse(ctx context.Context, id string, body CreateVirtualNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualNetworkResponse, error) {
	rsp, err := c.CreateVirtualNetwork(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualNetworkResponse(rsp)
}

// ProjectListInterconnectionsWithResponse request returning *ProjectListInterconnectionsResponse
func (c *ClientWithResponses) ProjectListInterconnectionsWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*ProjectListInterconnectionsResponse, error) {
	rsp, err := c.ProjectListInterconnections(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectListInterconnectionsResponse(rsp)
}

// CreateProjectInterconnectionWithBodyWithResponse request with arbitrary body returning *CreateProjectInterconnectionResponse
func (c *ClientWithResponses) CreateProjectInterconnectionWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectInterconnectionResponse, error) {
	rsp, err := c.CreateProjectInterconnectionWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectInterconnectionResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectInterconnectionWithResponse(ctx context.Context, projectId string, body CreateProjectInterconnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectInterconnectionResponse, error) {
	rsp, err := c.CreateProjectInterconnection(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectInterconnectionResponse(rsp)
}

// FindProjectInvitationsWithResponse request returning *FindProjectInvitationsResponse
func (c *ClientWithResponses) FindProjectInvitationsWithResponse(ctx context.Context, projectId string, params *FindProjectInvitationsParams, reqEditors ...RequestEditorFn) (*FindProjectInvitationsResponse, error) {
	rsp, err := c.FindProjectInvitations(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindProjectInvitationsResponse(rsp)
}

// CreateProjectInvitationWithBodyWithResponse request with arbitrary body returning *CreateProjectInvitationResponse
func (c *ClientWithResponses) CreateProjectInvitationWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectInvitationResponse, error) {
	rsp, err := c.CreateProjectInvitationWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectInvitationResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectInvitationWithResponse(ctx context.Context, projectId string, body CreateProjectInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectInvitationResponse, error) {
	rsp, err := c.CreateProjectInvitation(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectInvitationResponse(rsp)
}

// FindIPReservationCustomdataWithResponse request returning *FindIPReservationCustomdataResponse
func (c *ClientWithResponses) FindIPReservationCustomdataWithResponse(ctx context.Context, projectId string, id string, reqEditors ...RequestEditorFn) (*FindIPReservationCustomdataResponse, error) {
	rsp, err := c.FindIPReservationCustomdata(ctx, projectId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindIPReservationCustomdataResponse(rsp)
}

// FindProjectMembershipsWithResponse request returning *FindProjectMembershipsResponse
func (c *ClientWithResponses) FindProjectMembershipsWithResponse(ctx context.Context, projectId string, params *FindProjectMembershipsParams, reqEditors ...RequestEditorFn) (*FindProjectMembershipsResponse, error) {
	rsp, err := c.FindProjectMemberships(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindProjectMembershipsResponse(rsp)
}

// FindMetalGatewaysByProjectWithResponse request returning *FindMetalGatewaysByProjectResponse
func (c *ClientWithResponses) FindMetalGatewaysByProjectWithResponse(ctx context.Context, projectId string, params *FindMetalGatewaysByProjectParams, reqEditors ...RequestEditorFn) (*FindMetalGatewaysByProjectResponse, error) {
	rsp, err := c.FindMetalGatewaysByProject(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindMetalGatewaysByProjectResponse(rsp)
}

// CreateMetalGatewayWithBodyWithResponse request with arbitrary body returning *CreateMetalGatewayResponse
func (c *ClientWithResponses) CreateMetalGatewayWithBodyWithResponse(ctx context.Context, projectId string, params *CreateMetalGatewayParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMetalGatewayResponse, error) {
	rsp, err := c.CreateMetalGatewayWithBody(ctx, projectId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMetalGatewayResponse(rsp)
}

func (c *ClientWithResponses) CreateMetalGatewayWithResponse(ctx context.Context, projectId string, params *CreateMetalGatewayParams, body CreateMetalGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMetalGatewayResponse, error) {
	rsp, err := c.CreateMetalGateway(ctx, projectId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMetalGatewayResponse(rsp)
}

// FindSelfServiceReservationsWithResponse request returning *FindSelfServiceReservationsResponse
func (c *ClientWithResponses) FindSelfServiceReservationsWithResponse(ctx context.Context, projectId string, params *FindSelfServiceReservationsParams, reqEditors ...RequestEditorFn) (*FindSelfServiceReservationsResponse, error) {
	rsp, err := c.FindSelfServiceReservations(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindSelfServiceReservationsResponse(rsp)
}

// CreateSelfServiceReservationWithBodyWithResponse request with arbitrary body returning *CreateSelfServiceReservationResponse
func (c *ClientWithResponses) CreateSelfServiceReservationWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSelfServiceReservationResponse, error) {
	rsp, err := c.CreateSelfServiceReservationWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSelfServiceReservationResponse(rsp)
}

func (c *ClientWithResponses) CreateSelfServiceReservationWithResponse(ctx context.Context, projectId string, body CreateSelfServiceReservationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSelfServiceReservationResponse, error) {
	rsp, err := c.CreateSelfServiceReservation(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSelfServiceReservationResponse(rsp)
}

// FindSelfServiceReservationWithResponse request returning *FindSelfServiceReservationResponse
func (c *ClientWithResponses) FindSelfServiceReservationWithResponse(ctx context.Context, projectId string, id string, reqEditors ...RequestEditorFn) (*FindSelfServiceReservationResponse, error) {
	rsp, err := c.FindSelfServiceReservation(ctx, projectId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindSelfServiceReservationResponse(rsp)
}

// ResetPasswordWithResponse request returning *ResetPasswordResponse
func (c *ClientWithResponses) ResetPasswordWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPassword(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

// CreatePasswordResetTokenWithResponse request returning *CreatePasswordResetTokenResponse
func (c *ClientWithResponses) CreatePasswordResetTokenWithResponse(ctx context.Context, params *CreatePasswordResetTokenParams, reqEditors ...RequestEditorFn) (*CreatePasswordResetTokenResponse, error) {
	rsp, err := c.CreatePasswordResetToken(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePasswordResetTokenResponse(rsp)
}

// DeleteSpotMarketRequestWithResponse request returning *DeleteSpotMarketRequestResponse
func (c *ClientWithResponses) DeleteSpotMarketRequestWithResponse(ctx context.Context, id string, params *DeleteSpotMarketRequestParams, reqEditors ...RequestEditorFn) (*DeleteSpotMarketRequestResponse, error) {
	rsp, err := c.DeleteSpotMarketRequest(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpotMarketRequestResponse(rsp)
}

// FindSpotMarketRequestByIdWithResponse request returning *FindSpotMarketRequestByIdResponse
func (c *ClientWithResponses) FindSpotMarketRequestByIdWithResponse(ctx context.Context, id string, params *FindSpotMarketRequestByIdParams, reqEditors ...RequestEditorFn) (*FindSpotMarketRequestByIdResponse, error) {
	rsp, err := c.FindSpotMarketRequestById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindSpotMarketRequestByIdResponse(rsp)
}

// FindSSHKeysWithResponse request returning *FindSSHKeysResponse
func (c *ClientWithResponses) FindSSHKeysWithResponse(ctx context.Context, params *FindSSHKeysParams, reqEditors ...RequestEditorFn) (*FindSSHKeysResponse, error) {
	rsp, err := c.FindSSHKeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindSSHKeysResponse(rsp)
}

// CreateSSHKeyWithBodyWithResponse request with arbitrary body returning *CreateSSHKeyResponse
func (c *ClientWithResponses) CreateSSHKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSSHKeyResponse, error) {
	rsp, err := c.CreateSSHKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSSHKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateSSHKeyWithResponse(ctx context.Context, body CreateSSHKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSSHKeyResponse, error) {
	rsp, err := c.CreateSSHKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSSHKeyResponse(rsp)
}

// DeleteSSHKeyWithResponse request returning *DeleteSSHKeyResponse
func (c *ClientWithResponses) DeleteSSHKeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSSHKeyResponse, error) {
	rsp, err := c.DeleteSSHKey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSSHKeyResponse(rsp)
}

// FindSSHKeyByIdWithResponse request returning *FindSSHKeyByIdResponse
func (c *ClientWithResponses) FindSSHKeyByIdWithResponse(ctx context.Context, id string, params *FindSSHKeyByIdParams, reqEditors ...RequestEditorFn) (*FindSSHKeyByIdResponse, error) {
	rsp, err := c.FindSSHKeyById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindSSHKeyByIdResponse(rsp)
}

// UpdateSSHKeyWithBodyWithResponse request with arbitrary body returning *UpdateSSHKeyResponse
func (c *ClientWithResponses) UpdateSSHKeyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSSHKeyResponse, error) {
	rsp, err := c.UpdateSSHKeyWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSSHKeyResponse(rsp)
}

func (c *ClientWithResponses) UpdateSSHKeyWithResponse(ctx context.Context, id string, body UpdateSSHKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSSHKeyResponse, error) {
	rsp, err := c.UpdateSSHKey(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSSHKeyResponse(rsp)
}

// DeleteVolumeAttachmentWithResponse request returning *DeleteVolumeAttachmentResponse
func (c *ClientWithResponses) DeleteVolumeAttachmentWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteVolumeAttachmentResponse, error) {
	rsp, err := c.DeleteVolumeAttachment(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVolumeAttachmentResponse(rsp)
}

// FindVolumeAttachmentByIdWithResponse request returning *FindVolumeAttachmentByIdResponse
func (c *ClientWithResponses) FindVolumeAttachmentByIdWithResponse(ctx context.Context, id string, params *FindVolumeAttachmentByIdParams, reqEditors ...RequestEditorFn) (*FindVolumeAttachmentByIdResponse, error) {
	rsp, err := c.FindVolumeAttachmentById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindVolumeAttachmentByIdResponse(rsp)
}

// DeleteVolumeSnapshotPolicyWithResponse request returning *DeleteVolumeSnapshotPolicyResponse
func (c *ClientWithResponses) DeleteVolumeSnapshotPolicyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteVolumeSnapshotPolicyResponse, error) {
	rsp, err := c.DeleteVolumeSnapshotPolicy(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVolumeSnapshotPolicyResponse(rsp)
}

// UpdateVolumeSnapshotPolicyWithResponse request returning *UpdateVolumeSnapshotPolicyResponse
func (c *ClientWithResponses) UpdateVolumeSnapshotPolicyWithResponse(ctx context.Context, id string, params *UpdateVolumeSnapshotPolicyParams, reqEditors ...RequestEditorFn) (*UpdateVolumeSnapshotPolicyResponse, error) {
	rsp, err := c.UpdateVolumeSnapshotPolicy(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeSnapshotPolicyResponse(rsp)
}

// DeleteVolumeWithResponse request returning *DeleteVolumeResponse
func (c *ClientWithResponses) DeleteVolumeWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteVolumeResponse, error) {
	rsp, err := c.DeleteVolume(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVolumeResponse(rsp)
}

// FindVolumeByIdWithResponse request returning *FindVolumeByIdResponse
func (c *ClientWithResponses) FindVolumeByIdWithResponse(ctx context.Context, id string, params *FindVolumeByIdParams, reqEditors ...RequestEditorFn) (*FindVolumeByIdResponse, error) {
	rsp, err := c.FindVolumeById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindVolumeByIdResponse(rsp)
}

// UpdateVolumeWithBodyWithResponse request with arbitrary body returning *UpdateVolumeResponse
func (c *ClientWithResponses) UpdateVolumeWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error) {
	rsp, err := c.UpdateVolumeWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeResponse(rsp)
}

func (c *ClientWithResponses) UpdateVolumeWithResponse(ctx context.Context, id string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error) {
	rsp, err := c.UpdateVolume(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeResponse(rsp)
}

// FindVolumeAttachmentsWithResponse request returning *FindVolumeAttachmentsResponse
func (c *ClientWithResponses) FindVolumeAttachmentsWithResponse(ctx context.Context, id string, params *FindVolumeAttachmentsParams, reqEditors ...RequestEditorFn) (*FindVolumeAttachmentsResponse, error) {
	rsp, err := c.FindVolumeAttachments(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindVolumeAttachmentsResponse(rsp)
}

// CreateVolumeAttachmentWithBodyWithResponse request with arbitrary body returning *CreateVolumeAttachmentResponse
func (c *ClientWithResponses) CreateVolumeAttachmentWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeAttachmentResponse, error) {
	rsp, err := c.CreateVolumeAttachmentWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeAttachmentResponse(rsp)
}

func (c *ClientWithResponses) CreateVolumeAttachmentWithResponse(ctx context.Context, id string, body CreateVolumeAttachmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeAttachmentResponse, error) {
	rsp, err := c.CreateVolumeAttachment(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeAttachmentResponse(rsp)
}

// CloneVolumeWithResponse request returning *CloneVolumeResponse
func (c *ClientWithResponses) CloneVolumeWithResponse(ctx context.Context, id string, params *CloneVolumeParams, reqEditors ...RequestEditorFn) (*CloneVolumeResponse, error) {
	rsp, err := c.CloneVolume(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloneVolumeResponse(rsp)
}

// FindVolumeCustomdataWithResponse request returning *FindVolumeCustomdataResponse
func (c *ClientWithResponses) FindVolumeCustomdataWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindVolumeCustomdataResponse, error) {
	rsp, err := c.FindVolumeCustomdata(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindVolumeCustomdataResponse(rsp)
}

// RestoreVolumeWithResponse request returning *RestoreVolumeResponse
func (c *ClientWithResponses) RestoreVolumeWithResponse(ctx context.Context, id string, params *RestoreVolumeParams, reqEditors ...RequestEditorFn) (*RestoreVolumeResponse, error) {
	rsp, err := c.RestoreVolume(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreVolumeResponse(rsp)
}

// CreateVolumeSnapshotPolicyWithResponse request returning *CreateVolumeSnapshotPolicyResponse
func (c *ClientWithResponses) CreateVolumeSnapshotPolicyWithResponse(ctx context.Context, id string, params *CreateVolumeSnapshotPolicyParams, reqEditors ...RequestEditorFn) (*CreateVolumeSnapshotPolicyResponse, error) {
	rsp, err := c.CreateVolumeSnapshotPolicy(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeSnapshotPolicyResponse(rsp)
}

// FindVolumeSnapshotsWithResponse request returning *FindVolumeSnapshotsResponse
func (c *ClientWithResponses) FindVolumeSnapshotsWithResponse(ctx context.Context, id string, params *FindVolumeSnapshotsParams, reqEditors ...RequestEditorFn) (*FindVolumeSnapshotsResponse, error) {
	rsp, err := c.FindVolumeSnapshots(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindVolumeSnapshotsResponse(rsp)
}

// DeleteVolumeSnapshotWithResponse request returning *DeleteVolumeSnapshotResponse
func (c *ClientWithResponses) DeleteVolumeSnapshotWithResponse(ctx context.Context, volumeId string, id string, reqEditors ...RequestEditorFn) (*DeleteVolumeSnapshotResponse, error) {
	rsp, err := c.DeleteVolumeSnapshot(ctx, volumeId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVolumeSnapshotResponse(rsp)
}

// RequestSuppertWithBodyWithResponse request with arbitrary body returning *RequestSuppertResponse
func (c *ClientWithResponses) RequestSuppertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestSuppertResponse, error) {
	rsp, err := c.RequestSuppertWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestSuppertResponse(rsp)
}

func (c *ClientWithResponses) RequestSuppertWithResponse(ctx context.Context, body RequestSuppertJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestSuppertResponse, error) {
	rsp, err := c.RequestSuppert(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestSuppertResponse(rsp)
}

// DeclineTransferRequestWithResponse request returning *DeclineTransferRequestResponse
func (c *ClientWithResponses) DeclineTransferRequestWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeclineTransferRequestResponse, error) {
	rsp, err := c.DeclineTransferRequest(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeclineTransferRequestResponse(rsp)
}

// FindTransferRequestByIdWithResponse request returning *FindTransferRequestByIdResponse
func (c *ClientWithResponses) FindTransferRequestByIdWithResponse(ctx context.Context, id string, params *FindTransferRequestByIdParams, reqEditors ...RequestEditorFn) (*FindTransferRequestByIdResponse, error) {
	rsp, err := c.FindTransferRequestById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindTransferRequestByIdResponse(rsp)
}

// AcceptTransferRequestWithResponse request returning *AcceptTransferRequestResponse
func (c *ClientWithResponses) AcceptTransferRequestWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*AcceptTransferRequestResponse, error) {
	rsp, err := c.AcceptTransferRequest(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptTransferRequestResponse(rsp)
}

// FindCurrentUserWithResponse request returning *FindCurrentUserResponse
func (c *ClientWithResponses) FindCurrentUserWithResponse(ctx context.Context, params *FindCurrentUserParams, reqEditors ...RequestEditorFn) (*FindCurrentUserResponse, error) {
	rsp, err := c.FindCurrentUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindCurrentUserResponse(rsp)
}

// UpdateCurrentUserWithBodyWithResponse request with arbitrary body returning *UpdateCurrentUserResponse
func (c *ClientWithResponses) UpdateCurrentUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCurrentUserResponse, error) {
	rsp, err := c.UpdateCurrentUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCurrentUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateCurrentUserWithResponse(ctx context.Context, body UpdateCurrentUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCurrentUserResponse, error) {
	rsp, err := c.UpdateCurrentUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCurrentUserResponse(rsp)
}

// FindAPIKeysWithResponse request returning *FindAPIKeysResponse
func (c *ClientWithResponses) FindAPIKeysWithResponse(ctx context.Context, params *FindAPIKeysParams, reqEditors ...RequestEditorFn) (*FindAPIKeysResponse, error) {
	rsp, err := c.FindAPIKeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAPIKeysResponse(rsp)
}

// CreateAPIKeyWithBodyWithResponse request with arbitrary body returning *CreateAPIKeyResponse
func (c *ClientWithResponses) CreateAPIKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAPIKeyResponse, error) {
	rsp, err := c.CreateAPIKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAPIKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateAPIKeyWithResponse(ctx context.Context, body CreateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAPIKeyResponse, error) {
	rsp, err := c.CreateAPIKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAPIKeyResponse(rsp)
}

// DeleteUserAPIKeyWithResponse request returning *DeleteUserAPIKeyResponse
func (c *ClientWithResponses) DeleteUserAPIKeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteUserAPIKeyResponse, error) {
	rsp, err := c.DeleteUserAPIKey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserAPIKeyResponse(rsp)
}

// DisableTfaAppWithResponse request returning *DisableTfaAppResponse
func (c *ClientWithResponses) DisableTfaAppWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DisableTfaAppResponse, error) {
	rsp, err := c.DisableTfaApp(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableTfaAppResponse(rsp)
}

// EnableTfaAppWithResponse request returning *EnableTfaAppResponse
func (c *ClientWithResponses) EnableTfaAppWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*EnableTfaAppResponse, error) {
	rsp, err := c.EnableTfaApp(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableTfaAppResponse(rsp)
}

// FindRecoveryCodesWithResponse request returning *FindRecoveryCodesResponse
func (c *ClientWithResponses) FindRecoveryCodesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindRecoveryCodesResponse, error) {
	rsp, err := c.FindRecoveryCodes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindRecoveryCodesResponse(rsp)
}

// RegenerateCodesWithResponse request returning *RegenerateCodesResponse
func (c *ClientWithResponses) RegenerateCodesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RegenerateCodesResponse, error) {
	rsp, err := c.RegenerateCodes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegenerateCodesResponse(rsp)
}

// DisableTfaSmsWithResponse request returning *DisableTfaSmsResponse
func (c *ClientWithResponses) DisableTfaSmsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DisableTfaSmsResponse, error) {
	rsp, err := c.DisableTfaSms(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableTfaSmsResponse(rsp)
}

// EnableTfaSmsWithResponse request returning *EnableTfaSmsResponse
func (c *ClientWithResponses) EnableTfaSmsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*EnableTfaSmsResponse, error) {
	rsp, err := c.EnableTfaSms(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableTfaSmsResponse(rsp)
}

// ReceiveCodesWithResponse request returning *ReceiveCodesResponse
func (c *ClientWithResponses) ReceiveCodesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ReceiveCodesResponse, error) {
	rsp, err := c.ReceiveCodes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReceiveCodesResponse(rsp)
}

// FindEnsureOtpWithResponse request returning *FindEnsureOtpResponse
func (c *ClientWithResponses) FindEnsureOtpWithResponse(ctx context.Context, otp string, reqEditors ...RequestEditorFn) (*FindEnsureOtpResponse, error) {
	rsp, err := c.FindEnsureOtp(ctx, otp, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindEnsureOtpResponse(rsp)
}

// ValidateUserdataWithResponse request returning *ValidateUserdataResponse
func (c *ClientWithResponses) ValidateUserdataWithResponse(ctx context.Context, params *ValidateUserdataParams, reqEditors ...RequestEditorFn) (*ValidateUserdataResponse, error) {
	rsp, err := c.ValidateUserdata(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateUserdataResponse(rsp)
}

// FindUsersWithResponse request returning *FindUsersResponse
func (c *ClientWithResponses) FindUsersWithResponse(ctx context.Context, params *FindUsersParams, reqEditors ...RequestEditorFn) (*FindUsersResponse, error) {
	rsp, err := c.FindUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// FindUserByIdWithResponse request returning *FindUserByIdResponse
func (c *ClientWithResponses) FindUserByIdWithResponse(ctx context.Context, id string, params *FindUserByIdParams, reqEditors ...RequestEditorFn) (*FindUserByIdResponse, error) {
	rsp, err := c.FindUserById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindUserByIdResponse(rsp)
}

// FindUserCustomdataWithResponse request returning *FindUserCustomdataResponse
func (c *ClientWithResponses) FindUserCustomdataWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindUserCustomdataResponse, error) {
	rsp, err := c.FindUserCustomdata(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindUserCustomdataResponse(rsp)
}

// CreateValidationRequestWithResponse request returning *CreateValidationRequestResponse
func (c *ClientWithResponses) CreateValidationRequestWithResponse(ctx context.Context, params *CreateValidationRequestParams, reqEditors ...RequestEditorFn) (*CreateValidationRequestResponse, error) {
	rsp, err := c.CreateValidationRequest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateValidationRequestResponse(rsp)
}

// ConsumeVerificationRequestWithResponse request returning *ConsumeVerificationRequestResponse
func (c *ClientWithResponses) ConsumeVerificationRequestWithResponse(ctx context.Context, params *ConsumeVerificationRequestParams, reqEditors ...RequestEditorFn) (*ConsumeVerificationRequestResponse, error) {
	rsp, err := c.ConsumeVerificationRequest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConsumeVerificationRequestResponse(rsp)
}

// FindVirtualCircuitEventsWithResponse request returning *FindVirtualCircuitEventsResponse
func (c *ClientWithResponses) FindVirtualCircuitEventsWithResponse(ctx context.Context, id string, params *FindVirtualCircuitEventsParams, reqEditors ...RequestEditorFn) (*FindVirtualCircuitEventsResponse, error) {
	rsp, err := c.FindVirtualCircuitEvents(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindVirtualCircuitEventsResponse(rsp)
}

// DeleteVirtualCircuitWithResponse request returning *DeleteVirtualCircuitResponse
func (c *ClientWithResponses) DeleteVirtualCircuitWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteVirtualCircuitResponse, error) {
	rsp, err := c.DeleteVirtualCircuit(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVirtualCircuitResponse(rsp)
}

// GetVirtualCircuitWithResponse request returning *GetVirtualCircuitResponse
func (c *ClientWithResponses) GetVirtualCircuitWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetVirtualCircuitResponse, error) {
	rsp, err := c.GetVirtualCircuit(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVirtualCircuitResponse(rsp)
}

// UpdateVirtualCircuitWithBodyWithResponse request with arbitrary body returning *UpdateVirtualCircuitResponse
func (c *ClientWithResponses) UpdateVirtualCircuitWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVirtualCircuitResponse, error) {
	rsp, err := c.UpdateVirtualCircuitWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVirtualCircuitResponse(rsp)
}

func (c *ClientWithResponses) UpdateVirtualCircuitWithResponse(ctx context.Context, id string, body UpdateVirtualCircuitJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVirtualCircuitResponse, error) {
	rsp, err := c.UpdateVirtualCircuit(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVirtualCircuitResponse(rsp)
}

// DeleteVirtualNetworkWithResponse request returning *DeleteVirtualNetworkResponse
func (c *ClientWithResponses) DeleteVirtualNetworkWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteVirtualNetworkResponse, error) {
	rsp, err := c.DeleteVirtualNetwork(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVirtualNetworkResponse(rsp)
}

// GetVirtualNetworkWithResponse request returning *GetVirtualNetworkResponse
func (c *ClientWithResponses) GetVirtualNetworkWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetVirtualNetworkResponse, error) {
	rsp, err := c.GetVirtualNetwork(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVirtualNetworkResponse(rsp)
}

// FindVolumeEventsWithResponse request returning *FindVolumeEventsResponse
func (c *ClientWithResponses) FindVolumeEventsWithResponse(ctx context.Context, id string, params *FindVolumeEventsParams, reqEditors ...RequestEditorFn) (*FindVolumeEventsResponse, error) {
	rsp, err := c.FindVolumeEvents(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindVolumeEventsResponse(rsp)
}

// ParseDeleteAPIKeyResponse parses an HTTP response from a DeleteAPIKeyWithResponse call
func ParseDeleteAPIKeyResponse(rsp *http.Response) (*DeleteAPIKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAPIKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteBatchResponse parses an HTTP response from a DeleteBatchWithResponse call
func ParseDeleteBatchResponse(rsp *http.Response) (*DeleteBatchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindBatchByIdResponse parses an HTTP response from a FindBatchByIdWithResponse call
func ParseFindBatchByIdResponse(rsp *http.Response) (*FindBatchByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindBatchByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Batch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteBgpSessionResponse parses an HTTP response from a DeleteBgpSessionWithResponse call
func ParseDeleteBgpSessionResponse(rsp *http.Response) (*DeleteBgpSessionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBgpSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindBgpSessionByIdResponse parses an HTTP response from a FindBgpSessionByIdWithResponse call
func ParseFindBgpSessionByIdResponse(rsp *http.Response) (*FindBgpSessionByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindBgpSessionByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BgpSession
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateBgpSessionResponse parses an HTTP response from a UpdateBgpSessionWithResponse call
func ParseUpdateBgpSessionResponse(rsp *http.Response) (*UpdateBgpSessionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBgpSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindCapacityForFacilityResponse parses an HTTP response from a FindCapacityForFacilityWithResponse call
func ParseFindCapacityForFacilityResponse(rsp *http.Response) (*FindCapacityForFacilityResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindCapacityForFacilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CapacityList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCheckCapacityForFacilityResponse parses an HTTP response from a CheckCapacityForFacilityWithResponse call
func ParseCheckCapacityForFacilityResponse(rsp *http.Response) (*CheckCapacityForFacilityResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckCapacityForFacilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CapacityCheckPerFacilityList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindCapacityForMetroResponse parses an HTTP response from a FindCapacityForMetroWithResponse call
func ParseFindCapacityForMetroResponse(rsp *http.Response) (*FindCapacityForMetroResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindCapacityForMetroResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetroCapacityList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCheckCapacityForMetroResponse parses an HTTP response from a CheckCapacityForMetroWithResponse call
func ParseCheckCapacityForMetroResponse(rsp *http.Response) (*CheckCapacityForMetroResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckCapacityForMetroResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CapacityCheckPerMetroList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteInterconnectionResponse parses an HTTP response from a DeleteInterconnectionWithResponse call
func ParseDeleteInterconnectionResponse(rsp *http.Response) (*DeleteInterconnectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInterconnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Interconnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetInterconnectionResponse parses an HTTP response from a GetInterconnectionWithResponse call
func ParseGetInterconnectionResponse(rsp *http.Response) (*GetInterconnectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInterconnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Interconnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateInterconnectionResponse parses an HTTP response from a UpdateInterconnectionWithResponse call
func ParseUpdateInterconnectionResponse(rsp *http.Response) (*UpdateInterconnectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateInterconnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Interconnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindConnectionEventsResponse parses an HTTP response from a FindConnectionEventsWithResponse call
func ParseFindConnectionEventsResponse(rsp *http.Response) (*FindConnectionEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindConnectionEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListConnectionPortsResponse parses an HTTP response from a ListConnectionPortsWithResponse call
func ParseListConnectionPortsResponse(rsp *http.Response) (*ListConnectionPortsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListConnectionPortsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InterconnectionPortList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetConnectionPortResponse parses an HTTP response from a GetConnectionPortWithResponse call
func ParseGetConnectionPortResponse(rsp *http.Response) (*GetConnectionPortResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConnectionPortResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InterconnectionPort
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindConnectionPortEventsResponse parses an HTTP response from a FindConnectionPortEventsWithResponse call
func ParseFindConnectionPortEventsResponse(rsp *http.Response) (*FindConnectionPortEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindConnectionPortEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListConnectionPortVirtualCircuitsResponse parses an HTTP response from a ListConnectionPortVirtualCircuitsWithResponse call
func ParseListConnectionPortVirtualCircuitsResponse(rsp *http.Response) (*ListConnectionPortVirtualCircuitsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListConnectionPortVirtualCircuitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VirtualCircuitList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateConnectionPortVirtualCircuitResponse parses an HTTP response from a CreateConnectionPortVirtualCircuitWithResponse call
func ParseCreateConnectionPortVirtualCircuitResponse(rsp *http.Response) (*CreateConnectionPortVirtualCircuitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateConnectionPortVirtualCircuitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VirtualCircuitList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteDeviceResponse parses an HTTP response from a DeleteDeviceWithResponse call
func ParseDeleteDeviceResponse(rsp *http.Response) (*DeleteDeviceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDeviceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindDeviceByIdResponse parses an HTTP response from a FindDeviceByIdWithResponse call
func ParseFindDeviceByIdResponse(rsp *http.Response) (*FindDeviceByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindDeviceByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Device
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateDeviceResponse parses an HTTP response from a UpdateDeviceWithResponse call
func ParseUpdateDeviceResponse(rsp *http.Response) (*UpdateDeviceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDeviceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Device
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePerformActionResponse parses an HTTP response from a PerformActionWithResponse call
func ParsePerformActionResponse(rsp *http.Response) (*PerformActionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PerformActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindInstanceBandwidthResponse parses an HTTP response from a FindInstanceBandwidthWithResponse call
func ParseFindInstanceBandwidthResponse(rsp *http.Response) (*FindInstanceBandwidthResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindInstanceBandwidthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetBgpNeighborDataResponse parses an HTTP response from a GetBgpNeighborDataWithResponse call
func ParseGetBgpNeighborDataResponse(rsp *http.Response) (*GetBgpNeighborDataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBgpNeighborDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BgpSessionNeighbors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindBgpSessionsResponse parses an HTTP response from a FindBgpSessionsWithResponse call
func ParseFindBgpSessionsResponse(rsp *http.Response) (*FindBgpSessionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindBgpSessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BgpSessionList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateBgpSessionResponse parses an HTTP response from a CreateBgpSessionWithResponse call
func ParseCreateBgpSessionResponse(rsp *http.Response) (*CreateBgpSessionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBgpSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BgpSession
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindDeviceCustomdataResponse parses an HTTP response from a FindDeviceCustomdataWithResponse call
func ParseFindDeviceCustomdataResponse(rsp *http.Response) (*FindDeviceCustomdataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindDeviceCustomdataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindDeviceEventsResponse parses an HTTP response from a FindDeviceEventsWithResponse call
func ParseFindDeviceEventsResponse(rsp *http.Response) (*FindDeviceEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindDeviceEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindIPAssignmentsResponse parses an HTTP response from a FindIPAssignmentsWithResponse call
func ParseFindIPAssignmentsResponse(rsp *http.Response) (*FindIPAssignmentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindIPAssignmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IPAssignmentList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateIPAssignmentResponse parses an HTTP response from a CreateIPAssignmentWithResponse call
func ParseCreateIPAssignmentResponse(rsp *http.Response) (*CreateIPAssignmentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIPAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IPAssignment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindDeviceSSHKeysResponse parses an HTTP response from a FindDeviceSSHKeysWithResponse call
func ParseFindDeviceSSHKeysResponse(rsp *http.Response) (*FindDeviceSSHKeysResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindDeviceSSHKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SSHKeyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindTrafficResponse parses an HTTP response from a FindTrafficWithResponse call
func ParseFindTrafficResponse(rsp *http.Response) (*FindTrafficResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindTrafficResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindDeviceUsagesResponse parses an HTTP response from a FindDeviceUsagesWithResponse call
func ParseFindDeviceUsagesResponse(rsp *http.Response) (*FindDeviceUsagesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindDeviceUsagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeviceUsageList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindIPAssignmentCustomdataResponse parses an HTTP response from a FindIPAssignmentCustomdataWithResponse call
func ParseFindIPAssignmentCustomdataResponse(rsp *http.Response) (*FindIPAssignmentCustomdataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindIPAssignmentCustomdataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateEmailResponse parses an HTTP response from a CreateEmailWithResponse call
func ParseCreateEmailResponse(rsp *http.Response) (*CreateEmailResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Email
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteEmailResponse parses an HTTP response from a DeleteEmailWithResponse call
func ParseDeleteEmailResponse(rsp *http.Response) (*DeleteEmailResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindEmailByIdResponse parses an HTTP response from a FindEmailByIdWithResponse call
func ParseFindEmailByIdResponse(rsp *http.Response) (*FindEmailByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindEmailByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Email
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateEmailResponse parses an HTTP response from a UpdateEmailWithResponse call
func ParseUpdateEmailResponse(rsp *http.Response) (*UpdateEmailResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Email
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindEventsResponse parses an HTTP response from a FindEventsWithResponse call
func ParseFindEventsResponse(rsp *http.Response) (*FindEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindEventByIdResponse parses an HTTP response from a FindEventByIdWithResponse call
func ParseFindEventByIdResponse(rsp *http.Response) (*FindEventByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindEventByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindFacilitiesResponse parses an HTTP response from a FindFacilitiesWithResponse call
func ParseFindFacilitiesResponse(rsp *http.Response) (*FindFacilitiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindFacilitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FacilityList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindHardwareReservationByIdResponse parses an HTTP response from a FindHardwareReservationByIdWithResponse call
func ParseFindHardwareReservationByIdResponse(rsp *http.Response) (*FindHardwareReservationByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindHardwareReservationByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Device
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseMoveHardwareReservationResponse parses an HTTP response from a MoveHardwareReservationWithResponse call
func ParseMoveHardwareReservationResponse(rsp *http.Response) (*MoveHardwareReservationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MoveHardwareReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HardwareReservation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindIncidentsResponse parses an HTTP response from a FindIncidentsWithResponse call
func ParseFindIncidentsResponse(rsp *http.Response) (*FindIncidentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindIncidentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindInvitationsResponse parses an HTTP response from a FindInvitationsWithResponse call
func ParseFindInvitationsResponse(rsp *http.Response) (*FindInvitationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindInvitationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InvitationList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeclineInvitationResponse parses an HTTP response from a DeclineInvitationWithResponse call
func ParseDeclineInvitationResponse(rsp *http.Response) (*DeclineInvitationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeclineInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindInvitationByIdResponse parses an HTTP response from a FindInvitationByIdWithResponse call
func ParseFindInvitationByIdResponse(rsp *http.Response) (*FindInvitationByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindInvitationByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Invitation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAcceptInvitationResponse parses an HTTP response from a AcceptInvitationWithResponse call
func ParseAcceptInvitationResponse(rsp *http.Response) (*AcceptInvitationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Membership
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteIPAddressResponse parses an HTTP response from a DeleteIPAddressWithResponse call
func ParseDeleteIPAddressResponse(rsp *http.Response) (*DeleteIPAddressResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIPAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindIPAddressByIdResponse parses an HTTP response from a FindIPAddressByIdWithResponse call
func ParseFindIPAddressByIdResponse(rsp *http.Response) (*FindIPAddressByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindIPAddressByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IPAssignment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateIPAddressResponse parses an HTTP response from a UpdateIPAddressWithResponse call
func ParseUpdateIPAddressResponse(rsp *http.Response) (*UpdateIPAddressResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateIPAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IPAssignment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindIPAvailabilitiesResponse parses an HTTP response from a FindIPAvailabilitiesWithResponse call
func ParseFindIPAvailabilitiesResponse(rsp *http.Response) (*FindIPAvailabilitiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindIPAvailabilitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IPAvailabilitiesList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindIPAddressCustomdataResponse parses an HTTP response from a FindIPAddressCustomdataWithResponse call
func ParseFindIPAddressCustomdataResponse(rsp *http.Response) (*FindIPAddressCustomdataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindIPAddressCustomdataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteLicenseResponse parses an HTTP response from a DeleteLicenseWithResponse call
func ParseDeleteLicenseResponse(rsp *http.Response) (*DeleteLicenseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLicenseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindLicenseByIdResponse parses an HTTP response from a FindLicenseByIdWithResponse call
func ParseFindLicenseByIdResponse(rsp *http.Response) (*FindLicenseByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindLicenseByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest License
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateLicenseResponse parses an HTTP response from a UpdateLicenseWithResponse call
func ParseUpdateLicenseResponse(rsp *http.Response) (*UpdateLicenseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLicenseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest License
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindMetrosResponse parses an HTTP response from a FindMetrosWithResponse call
func ParseFindMetrosResponse(rsp *http.Response) (*FindMetrosResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindMetrosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetroList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetMetroResponse parses an HTTP response from a GetMetroWithResponse call
func ParseGetMetroResponse(rsp *http.Response) (*GetMetroResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMetroResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Metro
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindSpotMarketPricesResponse parses an HTTP response from a FindSpotMarketPricesWithResponse call
func ParseFindSpotMarketPricesResponse(rsp *http.Response) (*FindSpotMarketPricesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindSpotMarketPricesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpotMarketPricesList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindSpotMarketPricesHistoryResponse parses an HTTP response from a FindSpotMarketPricesHistoryWithResponse call
func ParseFindSpotMarketPricesHistoryResponse(rsp *http.Response) (*FindSpotMarketPricesHistoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindSpotMarketPricesHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpotPricesHistoryReport
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindMetroSpotMarketPricesResponse parses an HTTP response from a FindMetroSpotMarketPricesWithResponse call
func ParseFindMetroSpotMarketPricesResponse(rsp *http.Response) (*FindMetroSpotMarketPricesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindMetroSpotMarketPricesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpotMarketPricesPerMetroList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteMembershipResponse parses an HTTP response from a DeleteMembershipWithResponse call
func ParseDeleteMembershipResponse(rsp *http.Response) (*DeleteMembershipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindMembershipByIdResponse parses an HTTP response from a FindMembershipByIdWithResponse call
func ParseFindMembershipByIdResponse(rsp *http.Response) (*FindMembershipByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindMembershipByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Membership
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateMembershipResponse parses an HTTP response from a UpdateMembershipWithResponse call
func ParseUpdateMembershipResponse(rsp *http.Response) (*UpdateMembershipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Membership
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteMetalGatewayResponse parses an HTTP response from a DeleteMetalGatewayWithResponse call
func ParseDeleteMetalGatewayResponse(rsp *http.Response) (*DeleteMetalGatewayResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMetalGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindMetalGatewayByIdResponse parses an HTTP response from a FindMetalGatewayByIdWithResponse call
func ParseFindMetalGatewayByIdResponse(rsp *http.Response) (*FindMetalGatewayByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindMetalGatewayByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetalGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindOperatingSystemVersionResponse parses an HTTP response from a FindOperatingSystemVersionWithResponse call
func ParseFindOperatingSystemVersionResponse(rsp *http.Response) (*FindOperatingSystemVersionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOperatingSystemVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OperatingSystemList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOperatingSystemsResponse parses an HTTP response from a FindOperatingSystemsWithResponse call
func ParseFindOperatingSystemsResponse(rsp *http.Response) (*FindOperatingSystemsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOperatingSystemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OperatingSystemList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindOrganizationsResponse parses an HTTP response from a FindOrganizationsWithResponse call
func ParseFindOrganizationsResponse(rsp *http.Response) (*FindOrganizationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOrganizationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrganizationList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOrganizationResponse parses an HTTP response from a CreateOrganizationWithResponse call
func ParseCreateOrganizationResponse(rsp *http.Response) (*CreateOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Organization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteOrganizationResponse parses an HTTP response from a DeleteOrganizationWithResponse call
func ParseDeleteOrganizationResponse(rsp *http.Response) (*DeleteOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindOrganizationByIdResponse parses an HTTP response from a FindOrganizationByIdWithResponse call
func ParseFindOrganizationByIdResponse(rsp *http.Response) (*FindOrganizationByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOrganizationByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Organization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateOrganizationResponse parses an HTTP response from a UpdateOrganizationWithResponse call
func ParseUpdateOrganizationResponse(rsp *http.Response) (*UpdateOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Organization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindOrganizationCapacityPerFacilityResponse parses an HTTP response from a FindOrganizationCapacityPerFacilityWithResponse call
func ParseFindOrganizationCapacityPerFacilityResponse(rsp *http.Response) (*FindOrganizationCapacityPerFacilityResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOrganizationCapacityPerFacilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CapacityList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseFindOrganizationCapacityPerMetroResponse parses an HTTP response from a FindOrganizationCapacityPerMetroWithResponse call
func ParseFindOrganizationCapacityPerMetroResponse(rsp *http.Response) (*FindOrganizationCapacityPerMetroResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOrganizationCapacityPerMetroResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetroCapacityList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseFindOrganizationCustomdataResponse parses an HTTP response from a FindOrganizationCustomdataWithResponse call
func ParseFindOrganizationCustomdataResponse(rsp *http.Response) (*FindOrganizationCustomdataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOrganizationCustomdataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindOrganizationDevicesResponse parses an HTTP response from a FindOrganizationDevicesWithResponse call
func ParseFindOrganizationDevicesResponse(rsp *http.Response) (*FindOrganizationDevicesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOrganizationDevicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeviceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindOrganizationEventsResponse parses an HTTP response from a FindOrganizationEventsWithResponse call
func ParseFindOrganizationEventsResponse(rsp *http.Response) (*FindOrganizationEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOrganizationEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindFacilitiesByOrganizationResponse parses an HTTP response from a FindFacilitiesByOrganizationWithResponse call
func ParseFindFacilitiesByOrganizationResponse(rsp *http.Response) (*FindFacilitiesByOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindFacilitiesByOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FacilityList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindOrganizationInvitationsResponse parses an HTTP response from a FindOrganizationInvitationsWithResponse call
func ParseFindOrganizationInvitationsResponse(rsp *http.Response) (*FindOrganizationInvitationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOrganizationInvitationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InvitationList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateOrganizationInvitationResponse parses an HTTP response from a CreateOrganizationInvitationWithResponse call
func ParseCreateOrganizationInvitationResponse(rsp *http.Response) (*CreateOrganizationInvitationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrganizationInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Invitation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindOperatingSystemsByOrganizationResponse parses an HTTP response from a FindOperatingSystemsByOrganizationWithResponse call
func ParseFindOperatingSystemsByOrganizationResponse(rsp *http.Response) (*FindOperatingSystemsByOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOperatingSystemsByOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OperatingSystemList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindOrganizationPaymentMethodsResponse parses an HTTP response from a FindOrganizationPaymentMethodsWithResponse call
func ParseFindOrganizationPaymentMethodsResponse(rsp *http.Response) (*FindOrganizationPaymentMethodsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOrganizationPaymentMethodsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentMethodList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreatePaymentMethodResponse parses an HTTP response from a CreatePaymentMethodWithResponse call
func ParseCreatePaymentMethodResponse(rsp *http.Response) (*CreatePaymentMethodResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePaymentMethodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PaymentMethod
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindPlansByOrganizationResponse parses an HTTP response from a FindPlansByOrganizationWithResponse call
func ParseFindPlansByOrganizationResponse(rsp *http.Response) (*FindPlansByOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindPlansByOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlanList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindOrganizationProjectsResponse parses an HTTP response from a FindOrganizationProjectsWithResponse call
func ParseFindOrganizationProjectsResponse(rsp *http.Response) (*FindOrganizationProjectsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOrganizationProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateOrganizationProjectResponse parses an HTTP response from a CreateOrganizationProjectWithResponse call
func ParseCreateOrganizationProjectResponse(rsp *http.Response) (*CreateOrganizationProjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrganizationProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindOrganizationTransfersResponse parses an HTTP response from a FindOrganizationTransfersWithResponse call
func ParseFindOrganizationTransfersResponse(rsp *http.Response) (*FindOrganizationTransfersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindOrganizationTransfersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransferRequestList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseOrganizationListInterconnectionsResponse parses an HTTP response from a OrganizationListInterconnectionsWithResponse call
func ParseOrganizationListInterconnectionsResponse(rsp *http.Response) (*OrganizationListInterconnectionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrganizationListInterconnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InterconnectionList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateOrganizationInterconnectionResponse parses an HTTP response from a CreateOrganizationInterconnectionWithResponse call
func ParseCreateOrganizationInterconnectionResponse(rsp *http.Response) (*CreateOrganizationInterconnectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrganizationInterconnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Interconnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeletePaymentMethodResponse parses an HTTP response from a DeletePaymentMethodWithResponse call
func ParseDeletePaymentMethodResponse(rsp *http.Response) (*DeletePaymentMethodResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePaymentMethodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindPaymentMethodByIdResponse parses an HTTP response from a FindPaymentMethodByIdWithResponse call
func ParseFindPaymentMethodByIdResponse(rsp *http.Response) (*FindPaymentMethodByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindPaymentMethodByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentMethod
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdatePaymentMethodResponse parses an HTTP response from a UpdatePaymentMethodWithResponse call
func ParseUpdatePaymentMethodResponse(rsp *http.Response) (*UpdatePaymentMethodResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePaymentMethodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentMethod
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindPlansResponse parses an HTTP response from a FindPlansWithResponse call
func ParseFindPlansResponse(rsp *http.Response) (*FindPlansResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindPlansResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlanList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindPortByIdResponse parses an HTTP response from a FindPortByIdWithResponse call
func ParseFindPortByIdResponse(rsp *http.Response) (*FindPortByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindPortByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Port
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAssignPortResponse parses an HTTP response from a AssignPortWithResponse call
func ParseAssignPortResponse(rsp *http.Response) (*AssignPortResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignPortResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Port
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseBondPortResponse parses an HTTP response from a BondPortWithResponse call
func ParseBondPortResponse(rsp *http.Response) (*BondPortResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BondPortResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Port
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseConvertLayer2Response parses an HTTP response from a ConvertLayer2WithResponse call
func ParseConvertLayer2Response(rsp *http.Response) (*ConvertLayer2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConvertLayer2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Port
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseConvertLayer3Response parses an HTTP response from a ConvertLayer3WithResponse call
func ParseConvertLayer3Response(rsp *http.Response) (*ConvertLayer3Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConvertLayer3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Port
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDisbondPortResponse parses an HTTP response from a DisbondPortWithResponse call
func ParseDisbondPortResponse(rsp *http.Response) (*DisbondPortResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisbondPortResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Port
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteNativeVlanResponse parses an HTTP response from a DeleteNativeVlanWithResponse call
func ParseDeleteNativeVlanResponse(rsp *http.Response) (*DeleteNativeVlanResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNativeVlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Port
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseAssignNativeVlanResponse parses an HTTP response from a AssignNativeVlanWithResponse call
func ParseAssignNativeVlanResponse(rsp *http.Response) (*AssignNativeVlanResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignNativeVlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Port
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUnassignPortResponse parses an HTTP response from a UnassignPortWithResponse call
func ParseUnassignPortResponse(rsp *http.Response) (*UnassignPortResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignPortResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Port
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindPortVlanAssignmentsResponse parses an HTTP response from a FindPortVlanAssignmentsWithResponse call
func ParseFindPortVlanAssignmentsResponse(rsp *http.Response) (*FindPortVlanAssignmentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindPortVlanAssignmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PortVlanAssignmentList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindPortVlanAssignmentBatchesResponse parses an HTTP response from a FindPortVlanAssignmentBatchesWithResponse call
func ParseFindPortVlanAssignmentBatchesResponse(rsp *http.Response) (*FindPortVlanAssignmentBatchesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindPortVlanAssignmentBatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PortVlanAssignmentBatchList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreatePortVlanAssignmentBatchResponse parses an HTTP response from a CreatePortVlanAssignmentBatchWithResponse call
func ParseCreatePortVlanAssignmentBatchResponse(rsp *http.Response) (*CreatePortVlanAssignmentBatchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePortVlanAssignmentBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PortVlanAssignmentBatch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindPortVlanAssignmentBatchByPortIdAndBatchIdResponse parses an HTTP response from a FindPortVlanAssignmentBatchByPortIdAndBatchIdWithResponse call
func ParseFindPortVlanAssignmentBatchByPortIdAndBatchIdResponse(rsp *http.Response) (*FindPortVlanAssignmentBatchByPortIdAndBatchIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindPortVlanAssignmentBatchByPortIdAndBatchIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PortVlanAssignmentBatch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindPortVlanAssignmentByPortIdAndAssignmentIdResponse parses an HTTP response from a FindPortVlanAssignmentByPortIdAndAssignmentIdWithResponse call
func ParseFindPortVlanAssignmentByPortIdAndAssignmentIdResponse(rsp *http.Response) (*FindPortVlanAssignmentByPortIdAndAssignmentIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindPortVlanAssignmentByPortIdAndAssignmentIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PortVlanAssignment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindProjectsResponse parses an HTTP response from a FindProjectsWithResponse call
func ParseFindProjectsResponse(rsp *http.Response) (*FindProjectsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateProjectResponse parses an HTTP response from a CreateProjectWithResponse call
func ParseCreateProjectResponse(rsp *http.Response) (*CreateProjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteProjectResponse parses an HTTP response from a DeleteProjectWithResponse call
func ParseDeleteProjectResponse(rsp *http.Response) (*DeleteProjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindProjectByIdResponse parses an HTTP response from a FindProjectByIdWithResponse call
func ParseFindProjectByIdResponse(rsp *http.Response) (*FindProjectByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindProjectByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateProjectResponse parses an HTTP response from a UpdateProjectWithResponse call
func ParseUpdateProjectResponse(rsp *http.Response) (*UpdateProjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindProjectAPIKeysResponse parses an HTTP response from a FindProjectAPIKeysWithResponse call
func ParseFindProjectAPIKeysResponse(rsp *http.Response) (*FindProjectAPIKeysResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindProjectAPIKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthTokenList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateProjectAPIKeyResponse parses an HTTP response from a CreateProjectAPIKeyWithResponse call
func ParseCreateProjectAPIKeyResponse(rsp *http.Response) (*CreateProjectAPIKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectAPIKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AuthToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindBatchesByProjectResponse parses an HTTP response from a FindBatchesByProjectWithResponse call
func ParseFindBatchesByProjectResponse(rsp *http.Response) (*FindBatchesByProjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindBatchesByProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchesList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindBgpConfigByProjectResponse parses an HTTP response from a FindBgpConfigByProjectWithResponse call
func ParseFindBgpConfigByProjectResponse(rsp *http.Response) (*FindBgpConfigByProjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindBgpConfigByProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BgpConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRequestBgpConfigResponse parses an HTTP response from a RequestBgpConfigWithResponse call
func ParseRequestBgpConfigResponse(rsp *http.Response) (*RequestBgpConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestBgpConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindProjectBgpSessionsResponse parses an HTTP response from a FindProjectBgpSessionsWithResponse call
func ParseFindProjectBgpSessionsResponse(rsp *http.Response) (*FindProjectBgpSessionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindProjectBgpSessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BgpSessionList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindProjectCustomdataResponse parses an HTTP response from a FindProjectCustomdataWithResponse call
func ParseFindProjectCustomdataResponse(rsp *http.Response) (*FindProjectCustomdataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindProjectCustomdataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindProjectDevicesResponse parses an HTTP response from a FindProjectDevicesWithResponse call
func ParseFindProjectDevicesResponse(rsp *http.Response) (*FindProjectDevicesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindProjectDevicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeviceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateDeviceResponse parses an HTTP response from a CreateDeviceWithResponse call
func ParseCreateDeviceResponse(rsp *http.Response) (*CreateDeviceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDeviceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Device
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCreateDeviceBatchResponse parses an HTTP response from a CreateDeviceBatchWithResponse call
func ParseCreateDeviceBatchResponse(rsp *http.Response) (*CreateDeviceBatchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDeviceBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BatchesList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindProjectEventsResponse parses an HTTP response from a FindProjectEventsWithResponse call
func ParseFindProjectEventsResponse(rsp *http.Response) (*FindProjectEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindProjectEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindFacilitiesByProjectResponse parses an HTTP response from a FindFacilitiesByProjectWithResponse call
func ParseFindFacilitiesByProjectResponse(rsp *http.Response) (*FindFacilitiesByProjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindFacilitiesByProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FacilityList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindGlobalBgpRangesResponse parses an HTTP response from a FindGlobalBgpRangesWithResponse call
func ParseFindGlobalBgpRangesResponse(rsp *http.Response) (*FindGlobalBgpRangesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindGlobalBgpRangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalBgpRangeList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindProjectHardwareReservationsResponse parses an HTTP response from a FindProjectHardwareReservationsWithResponse call
func ParseFindProjectHardwareReservationsResponse(rsp *http.Response) (*FindProjectHardwareReservationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindProjectHardwareReservationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HardwareReservationList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindIPReservationsResponse parses an HTTP response from a FindIPReservationsWithResponse call
func ParseFindIPReservationsResponse(rsp *http.Response) (*FindIPReservationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindIPReservationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IPReservationList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRequestIPReservationResponse parses an HTTP response from a RequestIPReservationWithResponse call
func ParseRequestIPReservationResponse(rsp *http.Response) (*RequestIPReservationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestIPReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IPReservation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindProjectLicensesResponse parses an HTTP response from a FindProjectLicensesWithResponse call
func ParseFindProjectLicensesResponse(rsp *http.Response) (*FindProjectLicensesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindProjectLicensesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LicenseList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateLicenseResponse parses an HTTP response from a CreateLicenseWithResponse call
func ParseCreateLicenseResponse(rsp *http.Response) (*CreateLicenseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLicenseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest License
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindPlansByProjectResponse parses an HTTP response from a FindPlansByProjectWithResponse call
func ParseFindPlansByProjectResponse(rsp *http.Response) (*FindPlansByProjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindPlansByProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlanList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListSpotMarketRequestsResponse parses an HTTP response from a ListSpotMarketRequestsWithResponse call
func ParseListSpotMarketRequestsResponse(rsp *http.Response) (*ListSpotMarketRequestsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSpotMarketRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpotMarketRequestList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateSpotMarketRequestResponse parses an HTTP response from a CreateSpotMarketRequestWithResponse call
func ParseCreateSpotMarketRequestResponse(rsp *http.Response) (*CreateSpotMarketRequestResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpotMarketRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SpotMarketRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindProjectSSHKeysResponse parses an HTTP response from a FindProjectSSHKeysWithResponse call
func ParseFindProjectSSHKeysResponse(rsp *http.Response) (*FindProjectSSHKeysResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindProjectSSHKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SSHKeyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateProjectSSHKeyResponse parses an HTTP response from a CreateProjectSSHKeyWithResponse call
func ParseCreateProjectSSHKeyResponse(rsp *http.Response) (*CreateProjectSSHKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectSSHKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SSHKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindVolumesResponse parses an HTTP response from a FindVolumesWithResponse call
func ParseFindVolumesResponse(rsp *http.Response) (*FindVolumesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindVolumesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VolumeList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateVolumeResponse parses an HTTP response from a CreateVolumeWithResponse call
func ParseCreateVolumeResponse(rsp *http.Response) (*CreateVolumeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCreateTransferRequestResponse parses an HTTP response from a CreateTransferRequestWithResponse call
func ParseCreateTransferRequestResponse(rsp *http.Response) (*CreateTransferRequestResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTransferRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TransferRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindProjectUsageResponse parses an HTTP response from a FindProjectUsageWithResponse call
func ParseFindProjectUsageResponse(rsp *http.Response) (*FindProjectUsageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindProjectUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectUsageList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindVirtualNetworksResponse parses an HTTP response from a FindVirtualNetworksWithResponse call
func ParseFindVirtualNetworksResponse(rsp *http.Response) (*FindVirtualNetworksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindVirtualNetworksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VirtualNetworkList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateVirtualNetworkResponse parses an HTTP response from a CreateVirtualNetworkWithResponse call
func ParseCreateVirtualNetworkResponse(rsp *http.Response) (*CreateVirtualNetworkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVirtualNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VirtualNetwork
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseProjectListInterconnectionsResponse parses an HTTP response from a ProjectListInterconnectionsWithResponse call
func ParseProjectListInterconnectionsResponse(rsp *http.Response) (*ProjectListInterconnectionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectListInterconnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InterconnectionList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateProjectInterconnectionResponse parses an HTTP response from a CreateProjectInterconnectionWithResponse call
func ParseCreateProjectInterconnectionResponse(rsp *http.Response) (*CreateProjectInterconnectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectInterconnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Interconnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindProjectInvitationsResponse parses an HTTP response from a FindProjectInvitationsWithResponse call
func ParseFindProjectInvitationsResponse(rsp *http.Response) (*FindProjectInvitationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindProjectInvitationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InvitationList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateProjectInvitationResponse parses an HTTP response from a CreateProjectInvitationWithResponse call
func ParseCreateProjectInvitationResponse(rsp *http.Response) (*CreateProjectInvitationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Invitation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindIPReservationCustomdataResponse parses an HTTP response from a FindIPReservationCustomdataWithResponse call
func ParseFindIPReservationCustomdataResponse(rsp *http.Response) (*FindIPReservationCustomdataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindIPReservationCustomdataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindProjectMembershipsResponse parses an HTTP response from a FindProjectMembershipsWithResponse call
func ParseFindProjectMembershipsResponse(rsp *http.Response) (*FindProjectMembershipsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindProjectMembershipsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MembershipList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindMetalGatewaysByProjectResponse parses an HTTP response from a FindMetalGatewaysByProjectWithResponse call
func ParseFindMetalGatewaysByProjectResponse(rsp *http.Response) (*FindMetalGatewaysByProjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindMetalGatewaysByProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetalGatewayList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateMetalGatewayResponse parses an HTTP response from a CreateMetalGatewayWithResponse call
func ParseCreateMetalGatewayResponse(rsp *http.Response) (*CreateMetalGatewayResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMetalGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MetalGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindSelfServiceReservationsResponse parses an HTTP response from a FindSelfServiceReservationsWithResponse call
func ParseFindSelfServiceReservationsResponse(rsp *http.Response) (*FindSelfServiceReservationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindSelfServiceReservationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SelfServiceReservationList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateSelfServiceReservationResponse parses an HTTP response from a CreateSelfServiceReservationWithResponse call
func ParseCreateSelfServiceReservationResponse(rsp *http.Response) (*CreateSelfServiceReservationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSelfServiceReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SelfServiceReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindSelfServiceReservationResponse parses an HTTP response from a FindSelfServiceReservationWithResponse call
func ParseFindSelfServiceReservationResponse(rsp *http.Response) (*FindSelfServiceReservationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindSelfServiceReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SelfServiceReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseResetPasswordResponse parses an HTTP response from a ResetPasswordWithResponse call
func ParseResetPasswordResponse(rsp *http.Response) (*ResetPasswordResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NewPassword
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCreatePasswordResetTokenResponse parses an HTTP response from a CreatePasswordResetTokenWithResponse call
func ParseCreatePasswordResetTokenResponse(rsp *http.Response) (*CreatePasswordResetTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePasswordResetTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteSpotMarketRequestResponse parses an HTTP response from a DeleteSpotMarketRequestWithResponse call
func ParseDeleteSpotMarketRequestResponse(rsp *http.Response) (*DeleteSpotMarketRequestResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpotMarketRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindSpotMarketRequestByIdResponse parses an HTTP response from a FindSpotMarketRequestByIdWithResponse call
func ParseFindSpotMarketRequestByIdResponse(rsp *http.Response) (*FindSpotMarketRequestByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindSpotMarketRequestByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpotMarketRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindSSHKeysResponse parses an HTTP response from a FindSSHKeysWithResponse call
func ParseFindSSHKeysResponse(rsp *http.Response) (*FindSSHKeysResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindSSHKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SSHKeyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateSSHKeyResponse parses an HTTP response from a CreateSSHKeyWithResponse call
func ParseCreateSSHKeyResponse(rsp *http.Response) (*CreateSSHKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSSHKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SSHKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteSSHKeyResponse parses an HTTP response from a DeleteSSHKeyWithResponse call
func ParseDeleteSSHKeyResponse(rsp *http.Response) (*DeleteSSHKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSSHKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindSSHKeyByIdResponse parses an HTTP response from a FindSSHKeyByIdWithResponse call
func ParseFindSSHKeyByIdResponse(rsp *http.Response) (*FindSSHKeyByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindSSHKeyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SSHKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateSSHKeyResponse parses an HTTP response from a UpdateSSHKeyWithResponse call
func ParseUpdateSSHKeyResponse(rsp *http.Response) (*UpdateSSHKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSSHKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SSHKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteVolumeAttachmentResponse parses an HTTP response from a DeleteVolumeAttachmentWithResponse call
func ParseDeleteVolumeAttachmentResponse(rsp *http.Response) (*DeleteVolumeAttachmentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVolumeAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindVolumeAttachmentByIdResponse parses an HTTP response from a FindVolumeAttachmentByIdWithResponse call
func ParseFindVolumeAttachmentByIdResponse(rsp *http.Response) (*FindVolumeAttachmentByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindVolumeAttachmentByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VolumeAttachment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteVolumeSnapshotPolicyResponse parses an HTTP response from a DeleteVolumeSnapshotPolicyWithResponse call
func ParseDeleteVolumeSnapshotPolicyResponse(rsp *http.Response) (*DeleteVolumeSnapshotPolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVolumeSnapshotPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateVolumeSnapshotPolicyResponse parses an HTTP response from a UpdateVolumeSnapshotPolicyWithResponse call
func ParseUpdateVolumeSnapshotPolicyResponse(rsp *http.Response) (*UpdateVolumeSnapshotPolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVolumeSnapshotPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SnapshotPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteVolumeResponse parses an HTTP response from a DeleteVolumeWithResponse call
func ParseDeleteVolumeResponse(rsp *http.Response) (*DeleteVolumeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindVolumeByIdResponse parses an HTTP response from a FindVolumeByIdWithResponse call
func ParseFindVolumeByIdResponse(rsp *http.Response) (*FindVolumeByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindVolumeByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateVolumeResponse parses an HTTP response from a UpdateVolumeWithResponse call
func ParseUpdateVolumeResponse(rsp *http.Response) (*UpdateVolumeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindVolumeAttachmentsResponse parses an HTTP response from a FindVolumeAttachmentsWithResponse call
func ParseFindVolumeAttachmentsResponse(rsp *http.Response) (*FindVolumeAttachmentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindVolumeAttachmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VolumeAttachmentList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateVolumeAttachmentResponse parses an HTTP response from a CreateVolumeAttachmentWithResponse call
func ParseCreateVolumeAttachmentResponse(rsp *http.Response) (*CreateVolumeAttachmentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVolumeAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VolumeAttachment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCloneVolumeResponse parses an HTTP response from a CloneVolumeWithResponse call
func ParseCloneVolumeResponse(rsp *http.Response) (*CloneVolumeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CloneVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindVolumeCustomdataResponse parses an HTTP response from a FindVolumeCustomdataWithResponse call
func ParseFindVolumeCustomdataResponse(rsp *http.Response) (*FindVolumeCustomdataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindVolumeCustomdataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRestoreVolumeResponse parses an HTTP response from a RestoreVolumeWithResponse call
func ParseRestoreVolumeResponse(rsp *http.Response) (*RestoreVolumeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCreateVolumeSnapshotPolicyResponse parses an HTTP response from a CreateVolumeSnapshotPolicyWithResponse call
func ParseCreateVolumeSnapshotPolicyResponse(rsp *http.Response) (*CreateVolumeSnapshotPolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVolumeSnapshotPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SnapshotPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindVolumeSnapshotsResponse parses an HTTP response from a FindVolumeSnapshotsWithResponse call
func ParseFindVolumeSnapshotsResponse(rsp *http.Response) (*FindVolumeSnapshotsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindVolumeSnapshotsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VolumeSnapshotList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteVolumeSnapshotResponse parses an HTTP response from a DeleteVolumeSnapshotWithResponse call
func ParseDeleteVolumeSnapshotResponse(rsp *http.Response) (*DeleteVolumeSnapshotResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVolumeSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRequestSuppertResponse parses an HTTP response from a RequestSuppertWithResponse call
func ParseRequestSuppertResponse(rsp *http.Response) (*RequestSuppertResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestSuppertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeclineTransferRequestResponse parses an HTTP response from a DeclineTransferRequestWithResponse call
func ParseDeclineTransferRequestResponse(rsp *http.Response) (*DeclineTransferRequestResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeclineTransferRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindTransferRequestByIdResponse parses an HTTP response from a FindTransferRequestByIdWithResponse call
func ParseFindTransferRequestByIdResponse(rsp *http.Response) (*FindTransferRequestByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindTransferRequestByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransferRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAcceptTransferRequestResponse parses an HTTP response from a AcceptTransferRequestWithResponse call
func ParseAcceptTransferRequestResponse(rsp *http.Response) (*AcceptTransferRequestResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptTransferRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindCurrentUserResponse parses an HTTP response from a FindCurrentUserWithResponse call
func ParseFindCurrentUserResponse(rsp *http.Response) (*FindCurrentUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUpdateCurrentUserResponse parses an HTTP response from a UpdateCurrentUserWithResponse call
func ParseUpdateCurrentUserResponse(rsp *http.Response) (*UpdateCurrentUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindAPIKeysResponse parses an HTTP response from a FindAPIKeysWithResponse call
func ParseFindAPIKeysResponse(rsp *http.Response) (*FindAPIKeysResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAPIKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthTokenList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateAPIKeyResponse parses an HTTP response from a CreateAPIKeyWithResponse call
func ParseCreateAPIKeyResponse(rsp *http.Response) (*CreateAPIKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAPIKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AuthToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteUserAPIKeyResponse parses an HTTP response from a DeleteUserAPIKeyWithResponse call
func ParseDeleteUserAPIKeyResponse(rsp *http.Response) (*DeleteUserAPIKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserAPIKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDisableTfaAppResponse parses an HTTP response from a DisableTfaAppWithResponse call
func ParseDisableTfaAppResponse(rsp *http.Response) (*DisableTfaAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableTfaAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseEnableTfaAppResponse parses an HTTP response from a EnableTfaAppWithResponse call
func ParseEnableTfaAppResponse(rsp *http.Response) (*EnableTfaAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableTfaAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseFindRecoveryCodesResponse parses an HTTP response from a FindRecoveryCodesWithResponse call
func ParseFindRecoveryCodesResponse(rsp *http.Response) (*FindRecoveryCodesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindRecoveryCodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoveryCodeList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseRegenerateCodesResponse parses an HTTP response from a RegenerateCodesWithResponse call
func ParseRegenerateCodesResponse(rsp *http.Response) (*RegenerateCodesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegenerateCodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoveryCodeList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDisableTfaSmsResponse parses an HTTP response from a DisableTfaSmsWithResponse call
func ParseDisableTfaSmsResponse(rsp *http.Response) (*DisableTfaSmsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableTfaSmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseEnableTfaSmsResponse parses an HTTP response from a EnableTfaSmsWithResponse call
func ParseEnableTfaSmsResponse(rsp *http.Response) (*EnableTfaSmsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableTfaSmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseReceiveCodesResponse parses an HTTP response from a ReceiveCodesWithResponse call
func ParseReceiveCodesResponse(rsp *http.Response) (*ReceiveCodesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReceiveCodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseFindEnsureOtpResponse parses an HTTP response from a FindEnsureOtpWithResponse call
func ParseFindEnsureOtpResponse(rsp *http.Response) (*FindEnsureOtpResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindEnsureOtpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseValidateUserdataResponse parses an HTTP response from a ValidateUserdataWithResponse call
func ParseValidateUserdataResponse(rsp *http.Response) (*ValidateUserdataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateUserdataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindUsersResponse parses an HTTP response from a FindUsersWithResponse call
func ParseFindUsersResponse(rsp *http.Response) (*FindUsersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindUserByIdResponse parses an HTTP response from a FindUserByIdWithResponse call
func ParseFindUserByIdResponse(rsp *http.Response) (*FindUserByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindUserByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindUserCustomdataResponse parses an HTTP response from a FindUserCustomdataWithResponse call
func ParseFindUserCustomdataResponse(rsp *http.Response) (*FindUserCustomdataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindUserCustomdataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateValidationRequestResponse parses an HTTP response from a CreateValidationRequestWithResponse call
func ParseCreateValidationRequestResponse(rsp *http.Response) (*CreateValidationRequestResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateValidationRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseConsumeVerificationRequestResponse parses an HTTP response from a ConsumeVerificationRequestWithResponse call
func ParseConsumeVerificationRequestResponse(rsp *http.Response) (*ConsumeVerificationRequestResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConsumeVerificationRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindVirtualCircuitEventsResponse parses an HTTP response from a FindVirtualCircuitEventsWithResponse call
func ParseFindVirtualCircuitEventsResponse(rsp *http.Response) (*FindVirtualCircuitEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindVirtualCircuitEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteVirtualCircuitResponse parses an HTTP response from a DeleteVirtualCircuitWithResponse call
func ParseDeleteVirtualCircuitResponse(rsp *http.Response) (*DeleteVirtualCircuitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVirtualCircuitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest VirtualCircuit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetVirtualCircuitResponse parses an HTTP response from a GetVirtualCircuitWithResponse call
func ParseGetVirtualCircuitResponse(rsp *http.Response) (*GetVirtualCircuitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVirtualCircuitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VirtualCircuit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateVirtualCircuitResponse parses an HTTP response from a UpdateVirtualCircuitWithResponse call
func ParseUpdateVirtualCircuitResponse(rsp *http.Response) (*UpdateVirtualCircuitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVirtualCircuitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VirtualCircuit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest VirtualCircuit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteVirtualNetworkResponse parses an HTTP response from a DeleteVirtualNetworkWithResponse call
func ParseDeleteVirtualNetworkResponse(rsp *http.Response) (*DeleteVirtualNetworkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVirtualNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VirtualNetwork
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetVirtualNetworkResponse parses an HTTP response from a GetVirtualNetworkWithResponse call
func ParseGetVirtualNetworkResponse(rsp *http.Response) (*GetVirtualNetworkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVirtualNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VirtualNetwork
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFindVolumeEventsResponse parses an HTTP response from a FindVolumeEventsWithResponse call
func ParseFindVolumeEventsResponse(rsp *http.Response) (*FindVolumeEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindVolumeEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

